# Эволюционная оптимизация {#sec-lab-model-evolutionary}

### Jeely

Для производства

Требуется минимизировать общее время выполнения задач распределённых по машинам.

M машин, N работ, каждая работа состоит из задач, задачи привязаны к машинам. Учитывая и не учитывая порядок выполнения работ. Завод Белжди должен сделать столько то машин разных марок. На заводе цеха, а в цехах рабочие станции. Каждая машина изготавливается из блоков, а блоки получаются применением некоторых работ. Необходимо минимизировать суммарное время. Есть предположение, что это перестановочная задача.

Два ограничения: одна машина одна работа одновременно. Одна работа не может выполняться на двух машинах и две работы не могут выполняться на одной машине. Объяснить как выбирается cost

Часто бывает полезно свести новую задачу к уже известным и хорошо проработанным. Попробовать rep и разные методы, сравнить результаты, подготовить итог.

Попробовать на задачах разного размера. Рассмотреть специфичные эвристики для задачи коммивояжера. При сдаче объяснить на каких принципах построена наиболее успешная эвристика.

Время старта задачи определяется как максимум от времени занятия текущей машины и времени освобождения работы. Оптимальных решений может быть несколько.

Что у jsp задачи есть несколько методов решения, например её можно сформулировать как задачу смешано-линейного программирования, как задачу потока минимальной стоимости. Но можно и по другому применяя весь мощнейший аппарат эвристик для tsp

#### Пример

Файл со вспомогательными функциями

:::: {.content-visible when-format='html'}
::: {.callout appearance='minimal'}
⤓ [JSP.R](../../../r/helper/JSP.R)
:::
::::

:::: {.content-visible unless-format='html'}
::: {.callout appearance='minimal'}
`\faFile*[regular].`{=latex} [JSP.R](r/helper/model/JSP.R)
:::
::::

Рассмотрим для примера рассмотрим следующую задачу с 3 машинами и 3 работами.

```{r}
#| echo: false

t <- tibble::tibble(name = paste0('o',1:9),
                    job = c(1,1,1,2,2,2,3,3,3), 
                    machine = c(1,3,2,2,1,3,3,1,2), 
                    cost = c(2,3,4,1,5,2,4,6,4))
knitr::kable(t)
```

Преобразуя задания в города задачи коммивояжера получим следующую матрицу:

```{r}
source('../../../r/helper/JSP.R')
jsp_data <- make_task_data(3,3,t$cost)
D <- JSP_to_TSP(jsp_data)
```

```{r}
#| echo: false
Ddf <- as.data.frame(D)
colnames(Ddf) <- rownames(Ddf) <- t$name
knitr::kable(Ddf, row.names = TRUE)
```

Решим задачу получив путь @sec-r-tools-evolutionary-tsp

```{r}
#| message: false
#| warning: false

path <- D |> TSP::as.TSP() |> 
  TSP::solve_TSP(control = list(rep = 10))
path
```

```{r}
#| include: false
path <- c(6, 1, 4, 8, 3, 7, 5, 9, 2)
```

Получим расписание из этого пути

```{r}
#| results: false

sh <- TSP_to_JSP(jsp_data, path)
sh$schedule
```

::: callout-warning
Функция `TSP_to_JSP` написана через костыль и копирует весь датасет при добавлении нового элемента. Рекомендуется вызывать её только один раз, при уже полученном оптимальном решении задачи коммивояжера.
:::

```{r}
knitr::kable(sh$schedule)
```

и итоговую стоимость

```{r}
sh$cost
```

Изобразим результат на графике

```{r}
plot_jsp_schedule(sh$schedule)
```


::: {.callout-note appearance='minimal'}
Уровень 3
:::

