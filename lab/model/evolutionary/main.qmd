# Эволюционная оптимизация {#sec-lab-model-evolutionary}

::::::::: {#exr-lab-model-evolutionary-jsp}
## Alma Meter

Эвристические алгоритмы часто применяются для решения вычислительно трудных задач, для которых доказано, что не существует алгоритма, получающего решение за полиномиальное время ([NP полнотоа](https://ru.wikipedia.org/wiki/NP-%D0%BF%D0%BE%D0%BB%D0%BD%D0%B0%D1%8F_%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0)). Наиболее известные из них это [Задача ](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0_%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D0%B2%D0%BE%D1%8F%D0%B6%D1%91%D1%80%D0%B0)[коммивояжёра](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0_%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D0%B2%D0%BE%D1%8F%D0%B6%D1%91%D1%80%D0%B0), [Задача о рюкзаке](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0_%D0%BE_%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5), [Задача поиска изоморфного подграфа](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0_%D0%B8%D0%B7%D0%BE%D0%BC%D0%BE%D1%80%D1%84%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BF%D0%BE%D0%B4%D0%B3%D1%80%D0%B0%D1%84%D0%B0). Примечательной особенностью таких задач является их эквивалентность. Любую из этих задач можно конвертировать в другую за полиномиальное время. Таким образом можно применить весь накопленный объём подходов и эвристик для решения хорошо известной задачи в решении более специализированной.

Рассмотрим [Задачу планирования производства](https://en.wikipedia.org/wiki/Job-shop_scheduling) (JSP). В ней $N$ заготовок (работ) должны быть обработаны на $M$ различных машинах в произвольном порядке. Ограничениями является то, что одна заготовка не может обрабатываться параллельно двумя машинами и одна машина обрабатывает только одну заготовку за раз. В условии задачи дано время обработки заготовки на машине $C_{ij}$, и требуется определить план, при котором суммарное время обработки будет минимальным.

У JSP задачи есть несколько популярных методов решения. Например её можно сформулировать как задачу смешано-линейного программирования, задачу поиска потока минимальной стоимости. В данном мы рассмотрим способ сведения JSP к задаче коммивояжера для применения высоко-оптимизированных методов решения.

### Пример {#sec-lab-model-evolutionary-jsp-example}

В файле со вспомогательными функциями определяются три функции для визуализации решения: `TSP_to_JSP`, `make_task_data` и `plot_jsp_schedule`. Их применение продемонстрировано ниже

:::: {.content-visible when-format="html"}
::: {.callout appearance="minimal"}
⤓ [JSP.R](../../../r/helper/JSP.R)
:::
::::

:::: {.content-visible unless-format="html"}
::: {.callout appearance="minimal"}
`\faFile*[regular].`{=latex} [JSP.R](r/helper/model/JSP.R)
:::
::::

Рассмотрим для примера рассмотрим следующую задачу с 3 машинами и 3 работами. Таблице $o$ -- это имя "города" задачи коммивояжера. Также номер работы, номер машины и время выполнения этой работы на заданной машине.

```{r}
#| echo: false

t <- tibble::tibble(name = paste0('o',1:9),
                    job = c(1,1,1,2,2,2,3,3,3), 
                    machine = c(1,3,2,2,1,3,3,1,2), 
                    cost = c(2,3,4,1,5,2,4,6,4))
knitr::kable(t)
```

Каждая работа должна быть выполнена на каждой машине за определённое время, указанное в таблице. Для поиска оптимального порядка операций преобразуем пары работа-машина в города задачи коммивояжера. Например: 3 город это комбинация работы-1 на машине-2.

Для начала сохраним структура задачи, основываясь на матрице стоимости в переменную `jsp_data`.

```{r}
source('../../../r/helper/JSP.R')
jsp_data <- make_task_data(3,3,t$cost)
```

Расстояния между "городами" $i$ и $j$ вычисляются следующим образом. Если совместно используется одна работа или она машина, общее время выполнения рассчитываемый как суммарное. В таком случае обработка производится последовательно. Иначе работы могу выполнятся параллельно, тогда стоимость пути это максимальная из стоимостей обработки. Таким образом строится матрица задачи коммивояжера `D`

```{r}
#| include: false
D <- JSP_to_TSP(jsp_data)
```

```{r}
#| echo: false
Ddf <- as.data.frame(D)
colnames(Ddf) <- rownames(Ddf) <- t$name
knitr::kable(Ddf, row.names = TRUE)
```

Решим задачу получив путь @sec-r-tools-solver-evolutionary-tsp

```{r}
#| message: false
#| warning: false

path <- D |> 
  TSP::as.TSP() |> 
  TSP::solve_TSP(control = list(rep = 10))
path
```

После решением задачи полученный вектор, представляющий собой путь, очерёдность посещения городов и следовательно порядок выполнения работ на машинах.

```{r}
#| include: false

path <- c(6, 1, 4, 8, 3, 7, 5, 9, 2)
```

```{r}
as.integer(path)
```

Далее из пути получим расписание работ в привычном формате. Для этого полученную ранее структуру `jsp_data` и найденный путь передаём в функцию `TSP_to_JSP`. Таблица с расписанием хранится по ключу `$schedule`. Столбцы `from` и `to` определяют время старта и завершения работы.

```{r}
#| results: false

sh <- TSP_to_JSP(jsp_data, path)
sh$schedule
```

```{r}
knitr::kable(sh$schedule)
```

По ключу `$cost` получаем общую продолжительност выполнения всех работ

```{r}
sh$cost
```

И с помощью функции `plot_jsp_schedule` Изобразим результат на графике

```{r}
plot_jsp_schedule(sh$schedule)
```

::: callout-warning
Функция `TSP_to_JSP` написана через костыль и копирует весь `data.frame` при добавлении нового элемента. Рекомендуется вызывать её только один раз, при уже полученном оптимальном решении задачи коммивояжера.
:::

### Задача {#sec-lab-model-evolutionary-jsp-task}

В основном ходит мнение, что студенты провалившие сессию попадают в армию. Но особо отличившихся может ждать ещё более незавидная судьба. Они попадут в подвал 4 кафедры, где организована сборочная линия производства измерительных приборов --- **Альма метров**. Теперь у них есть вечность, чтобы осознать свою ошибку. Узнав про бедственное положение своих бывших коллег и стремясь их поддержать, вы решаете помочь кафедре извлечь больше прибыли. Преобразовав JSP к задаче коммивояжера получите с помощью эвристических алгоритмов близкие к оптимальному расписания технологического процесса.

В таблице приведен один из этапов сборки **альма метра** третьего поколения, который сможет заменить умную колонку в свободное от работы время.

![](device.png){fig-align="center"}

| Элемент | Зона на плате | Время, минут |
|----|----|----|
| Установка микроконтроллера (ESP32-WROOM-32D/E) | Центр платы | 5 |
| Пайка датчика температуры/влажности (SHT20 или DHT22) | Сенсоры | 3 |
| Подключение реле (SRD-12VDC-SL) | Силовая часть | 2 |
| Монтаж разъема питания (DC Jack) |  | 3 |
| Установка светодиодов | Индикация | 2 |
| Добавление кнопки Reset | Внешние элементы | 1 |
| Установка аудио разъема 3.5 мм |  | 2 |

Определите оптимальное расписание для сборки:

-   одного изделия
-   10
-   20

::: {.callout-note appearance="minimal"}
Уровень 3
:::
:::::::::
