---
cache: false
freeze: false
---

# Эволюционная оптимизация {#sec-lab-extra-evolutionary}

А что, если job и machine не равны. У некоторых работ может отсутствовать занятость на машине

## Телекомания

### Задача

```{r}
tele <- hdf5r::H5File$new('tele.h5', mode = 'r')
```

```{r}
pop_mat <- tele[['Population']]$read()
alt_mat <- tele[['Altitude']]$read()
```

```{r}
#| include: false
source('tele.R')
pop <- interp(pop_mat)
alt <- interp(alt_mat)
```

Телекомпания хочет разместить свои вышки в городе с населением 301 тыс. человек. Схема районов города вместе с пригородом представлена на рисунке @fig-lab-evolutionary-tele-city. Плотность населения в городе задаётся функцией $P(x,y)$ и представлена на рисунке @fig-lab-evolutionary-tele-info-1. Топографическая карта города задаётся функцией $A(x,y)$ и представлена на рисунке @fig-lab-evolutionary-tele-info-1. Мощность сигнала от вышки в точке $r(x,y)$ обозначается функцией $S(t,r)$ и падает обратно пропорционально квадрату расстояния $D(t,r)$ от передатчика ($t$) до абонента ($r$) и зависит от экранирования сигнала. Экранирование обознается функцией $Scr(t,r)$ экспоненциально зависит от суммарного расстояния, которое сигнал проходит "под землей". Абонент может смотреть телевизор, если мощность его сигнала $S(t,r) \geq 5\cdot10^{-4}$.

![Схема районов](city.png){#fig-lab-evolutionary-tele-city fig-align="left"}

```{r}
#| label: fig-lab-evolutionary-tele-info
#| layout-ncol: 2
#| echo: false
#| fig-align: center
#| fig-cap: 
#|   - "Плотность населения"
#|   - "Карта высот"

plotly::plot_ly(z = log(pop_mat), type = 'surface') |> pshow()
plotly::plot_ly(z = alt_mat, type = 'surface') |> pshow()
```

#### Одна вышка

Установив одну вышку

#### Две вышки

Установив две вышки. Абонент может подключаться только к одной вышке (при перекрытии число абонентов не суммируется). Необходимо разместить вышки таким образом, чтобы максимизировать количество подключенных абонентов $M$.

#### Ограничения

Вышки нельзя размещать территории на школ, больниц и других учреждений (красные области на @fig-lab-evolutionary-tele-city-ban).

![Схема с ограничениями](city-ban.png){#fig-lab-evolutionary-tele-city-ban fig-align="left"}

Запрещённые области заданы координатами углов прямоугольника

```{r}
#| echo: false

readr::read_csv('ban.csv',col_types = 'i') |> 
  head() |> 
  knitr::kable()
```

:::: {.content-visible when-format="html"}
::: {.callout appearance="minimal"}
⤓ [tele.h5](tele.h5)

⤓ [ban.csv](ban.csv)
:::
::::

:::: {.content-visible unless-format="html"}
::: {.callout appearance="minimal"}
`\faFile*[regular].`{=latex} [tele.hdf5](lab/extra/evolutionary/model/tele.hdf5)

`\faFile*[regular].`{=latex} [ban.csv](lab/extra/evolutionary/model/ban.csv)
:::
::::

Для математики длину кривой можно переписать через интеграл и boole. Тоже самое для непрерывного решения на R. Получится функция, которая равна единице, где вторая больше и нулю, где первая. Просто через условие, и переписать условие. В брезенхемк тогда длина это отношение заказанных к чистым умножить на эвклидово. Интеграл именно вдоль прямой. Совет про параметрическое задние прямой

### Формализация

Евклидово расстояние $D$ между точками $p_1(x,y)$ и $p_2(x,y)$

$$
D(p_1,p_2)=D(\{x_1,y_1\},\{x_2,y_2\})=\sqrt{(p_{1,x}-p_{2,x})^2+(p_{1,y}-p_{2,y})^2}
$$

```{r}
#| include: false

tr <- c(80,90)
re <- c(5,5)
```

Пусть передатчик (трансмиттер) установлен в точке $t(`{r} tr[[1]]`,`{r} tr[[2]]`)$, а абонент (ресивер) находится в точке $r(`{r} re[[1]]`,`{r} re[[2]]`)$. Рассмотрим путь, который должен преодолеть сигнал. Передатчик установлен на высоте $`{r} alt(tr)`$ (справа), а абонент $`{r} alt(re)`$ (слева), если провести прямую между ними, то вся земля, которая находится выше этой прямой будет экранировать (ослаблять) сигнал:

```{r}
#| echo: false

t <- seq(0, 1, length.out = 100)
a <- sapply(t, \(t)  alt((tr - re) * t + re))
p <- sapply(t, \(t)  (alt(tr) - alt(re)) * t + alt(re))

plotly::plot_ly(
  x = t,
  y = a,
  type = 'scatter',
  mode = 'lines',
  name = 'высота'
) |>
  plotly::add_trace(x = t, y = p, name = 'передача') |>
  add_segments(t, a, p) |> 
  pshow()
```

#### Коэффициент экранирования

Коэффициента экранирования вычисляется следующим образом

::: panel-tabset
##### Непрерывный

$$
Scr(t,r) = \exp{\biggl(- \frac{ \sum{d_i}}{40} \biggr)}
$$

где $d_i$ длины участков, где сигнал проходит "под землёй". Тогда итоговая формула для сигнала:

##### Дискретный
:::

#### Сигнал

::: panel-tabset
##### Непрерывный

$$
S(t,r) = \frac{1}{D(t,r)^2} Scr(t,r) = \frac{1}{D(t,r)^2} \exp{\biggl(- \frac{ \sum{d_i}}{40} \biggr)}
$$

##### Дискретный

Функция $M(t,r)$ -- плотность населения в точке $r$ принимающих сигнал от передатчика из точки $t$:
:::

#### Подключенные абоненты

$$
M(t,r) = 
\begin{cases}
P(r), &если \, S(t,r) \geq 5\cdot10^{-4}\\
0, & инчае
\end{cases}
$$

Значит итоговое число абонентов, подключенных к передатчику, установленному в точке $t$ определяется суммированием по всем положениям абонентов $r(x,y)$ из области определения:

::: panel-tabset
##### Непрерывный

$$
M(t) = \iint M(t,r) S(t,r) dxdy
$$

В случае двух вышек функция $M(t_1,t_2,r)$ запишется следующим образом

$$
M(t,r) = 
\begin{cases}
P(r), &если \, S(t_1,r) \geq 5\cdot10^{-4}\\
P(r), &если \, S(t_2,r) \geq 5\cdot10^{-4}\\
0, & инчае
\end{cases}
$$

```{r}
#| include: false
#| eval: false

r <- 100
pracma::integral2(f,-r,r,-r,r)
```

##### Дискретный
:::

#### Задача оптимизации

Целевая функция это число подключенных абонентов

::: panel-tabset
##### Непрерывный

##### Дискретный
:::

#### Реализация

Основываясь на опыте, полученном при выполнении работ по темам нелинейное и эволюционное программирование выбрать подходящий метод решения.

Задачу можно рассматривать как непрерывную, в этом случае вам понадобятся функции интерполяции и интегрирования (пакет `pracma`). И как дискретную, в этом случае может пригодится алгорим Брезенхема, Вместо фрейма на операторах which и match

::: {.callout-note appearance="minimal"}
Уровень 4
:::

:::: content-hidden
Задача TSP Оптимизировать маршрут до простора, факультета и общаги, Задача поиска оптимального маршрута для собрать закрытый листок для выпуска с факультета. Посетить общежитие и другие организации при всей сложности пути в Минске. Рассмотреть как можно вытянуть формат карт из OSM.

Производительность в майнкрафте Theorycraft, оптимизация игры в hearstone

Задача об оптимальной прокачке в Elden Ring

Оптимальная подстройка например преобразования Фурье под имеющуюся архитектуру генетическим алгоритмом SPiRAL Идея в том, что одна и та же высокоуровневая операция может быть выполнена разным набором инструкций ассемблера

```{r}
loadNamespace('ecr') |> invisible()
loadNamespace('emoa') |> invisible()
```

Задачу с подстановкой битовой строки, которая масимизирует функцию One.Max, тоже что-нибудь информационное поверх пакетов ECR, EMOA

### DOOM

Генетическое программирование. Приблизить функцию по типу sqrt() используя дешёвые процессорные операции и константы. Применить критерий минимума среднего отклонения на области определения.

```{r}
e1 <- quote(a+b*x)
e2 <- quote(c+d*x)
b <- as.call(list(`*`, e1, e2))
eval(b, list(a =1, b=1, c=1, d=1, x=2))
```

```{r}
f <- quote(f)

a <- list(f,1,2)
```

```{r}
a[[2]] <- list(f,2,3)
```

```{r}
purrr::modify_tree(a, post = as.call, is_node = vctrs::obj_is_list)
```

```{r}
loadNamespace('data.tree') |> invisible()
```

Задать сложную функцию, слишком сложную, чтобы реализовывать её перебором или другим методом. Функцию вывести по задаче или дать готовую.

::: {.callout-note appearance="minimal"}
Уровень 4
:::
::::
