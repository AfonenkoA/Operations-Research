
# I. Введение

Хранилище данных (data warehousing) — это подход к интеграции данных из множества, возможно, очень больших, распределённых и неоднородных баз данных и других источников информации. Хранилище данных (DW) представляет собой репозиторий (хранилище) интегрированной информации, доступной для запросов и анализа. Чтобы избежать обращения к исходным источникам данных и повысить эффективность выполнения запросов к DW, некоторые промежуточные результаты обработки запросов сохраняются в самом хранилище. Эти промежуточные результаты называются материализованными представлениями (materialized views). На достаточно абстрактном уровне хранилище данных можно рассматривать как набор материализованных представлений над данными, извлечёнными из распределённых неоднородных баз данных. Существует множество исследовательских задач, связанных с DW \[1\], среди которых одной из самых сложных является задача выбора материализованных представлений. С одной стороны, материализованные представления ускоряют обработку запросов. С другой — они требуют обновления при изменениях в источниках данных. Следовательно, при выборе материализованных представлений необходимо учитывать две категории затрат: затраты на обработку запросов и затраты на обслуживание (обновление) материализованных представлений. Нас интересует следующий вопрос: какие представления следует материализовать, чтобы сумма затрат на выполнение запросов и обслуживание представлений была минимальной?

Выбор материализованных представлений представляет собой сложный компромисс между производительностью выполнения запросов и затратами на обслуживание.

-   Материализация всех представлений в хранилище данных (DW) обеспечивает наилучшую производительность, но сопровождается наивысшими затратами на обслуживание представлений.

-   Оставление всех представлений виртуальными приведёт к минимальным затратам на их обслуживание, но к худшей производительности запросов. Под «виртуальными» в данном контексте подразумевается, что никакие промежуточные результаты не сохраняются в хранилище данных.

-   Возможен также смешанный подход, при котором часть представлений материализуется (например, те, которые используются совместно), а остальные остаются виртуальными. Таким образом можно достичь оптимального (или близкого к оптимальному) баланса между приростом производительности и затратами на обслуживание. К сожалению, доказано, что задача проектирования выбора материализованных представлений является NP-трудных \[2\]. Поэтому на практике приходится использовать эвристику для нахождения приближённого к оптимальному решения.

Проблема, рассматриваемая в данной статье, формулируется следующим образом: на основе множества часто задаваемых запросов к хранилищу данных (DW) необходимо выбрать набор представлений для материализации таким образом, чтобы суммарные затраты на выполнение запросов и обслуживание были минимальны. Рассматриваемая задача связана с тремя различными аспектами:

1.  оптимизация запросов;

2.  оптимизация нескольких запросов одновременно;

3.  выбор материализованных представлений.

Существующие алгоритмы, предназначенные для решения одной или нескольких из вышеперечисленных задач оптимизации, согласно \[3\], можно классифицировать на четыре категории.

*Детерминированные алгоритмы* обычно строят или ищут решение предсказуемым (детерминированным) образом, либо с применением эвристик, либо путём полного перебора.

*Рандомизированные алгоритмы* используют совершенно иной подход. Сначала определяется набор возможных переходов (движений). Эти переходы образуют рёбра между различными решениями в пространстве решений. Две конфигурации (решения) соединены ребром тогда и только тогда, когда одна может быть преобразована в другую с помощью ровно одного перехода. Каждый из таких алгоритмов выполняет случайный обход вдоль рёбер в соответствии с определёнными правилами и завершается либо при отсутствии дальнейших допустимых переходов, либо по истечении установленного времени. В качестве результата возвращается лучшее из найденных на данный момент решений.

*Эволюционные алгоритмы* используют стратегию случайного поиска, аналогичную биологической эволюции, для нахождения хороших решений. Хотя в этом аспекте они схожи с рандомизированными алгоритмами, подход имеет достаточное количество отличий, чтобы рассматриваться отдельно. Основная идея заключается в том, чтобы начать с случайной начальной популяции и затем генерировать потомков путём случайных изменений (например, скрещивание и мутация). Наиболее «приспособленные» члены популяции выживают в процессе последующего отбора; следующее поколение формируется на их основе. Алгоритм завершает работу либо при отсутствии улучшений в течение некоторого времени, либо после заданного количества поколений. В результате решение соответствует самому приспособленному индивиду, найденному за всё время работы алгоритма.

*Гибридные алгоритмы* комбинируют детерминированные и рандомизированные подходы различными способами. Например, решения, полученные с помощью детерминированных алгоритмов, могут использоваться в качестве начальных точек для рандомизированных алгоритмов или в качестве членов начальной популяции для эволюционных алгоритмов. Также детерминированный алгоритм может применяться к наилучшему решению, найденному эволюционным алгоритмом, и т.д.

В работе \[4\] использовалась техника сокращения пространства решений путём рассмотрения только релевантных элементов многомерной решётки. К сожалению, при таком сокращении возможна потеря потенциально хороших решений. В работах \[2\] и \[5\] цель заключалась в выборе подходящего набора представлений, минимизирующего общее время отклика на запросы и/или стоимость обслуживания материализованных представлений при ограниченных ресурсах, таких как время материализации, объём памяти или общее время обслуживания представлений. Для этого применялся жадный эвристический алгоритм. Однако его производительность сильно зависит от конкретной задачи, поскольку жадная природа алгоритма делает его уязвимым к застреванию в плохих локальных минимумах.

В работе \[6\] была представлена общая структура и алгоритмы для анализа вопросов, связанных с выбором материализованных представлений, с целью достижения наилучшего сочетания высокой производительности запросов и низкой стоимости обслуживания представлений. Для получения оптимального глобального плана обработки использовалась техника целочисленного программирования 0–1, после чего на его основе применялся эвристический алгоритм для выбора материализованных представлений. Стоит отметить, что найденный таким образом оптимальный глобальный план обработки не обязательно приведёт к наилучшему набору материализованных представлений. Возможно, что другой, близкий к оптимальному глобальный план обработки может привести к лучшему выбору представлений. Эти две задачи оптимизации не следует рассматривать отдельно.

В данной работе применяется комплексный подход к выбору материализованных представлений, в котором локальные планы обработки, глобальные планы обработки и сам выбор представлений рассматриваются в рамках единой интегрированной структуры и алгоритма \[7\]. Предлагаемые алгоритмы позволяют исследовать и использовать взаимосвязи между этими тремя компонентами. Благодаря этому они с большей вероятностью находят более качественные решения по сравнению с другими методами, описанными в работах \[2\], \[4\], \[5\], \[6\], \[8\]–\[10\].

Хотя в последние годы эволюционные алгоритмы применялись для оптимизации запросов \[3\], \[11\], \[12\] благодаря их устойчивости и мощным возможностям глобального поиска, попыток использовать их потенциал для решения более сложных задач, таких как выбор материализованных представлений, было немного. В данной статье мы предлагаем несколько гибридных эволюционных и эвристических алгоритмов для оптимизации глобальных планов обработки и выбора материализованных представлений. Гибридные алгоритмы сочетают в себе силу эволюционных алгоритмов в глобальном поиске и способность эвристик к тонкой локальной оптимизации, что позволяет находить хороший набор материализованных представлений. Результаты наших экспериментов показывают, что гибридные алгоритмы работают лучше, чем существующие алгоритмы. Также они превосходят как чисто эволюционные, так и чисто эвристические алгоритмы.

В этой статье модель данных основана на модели выборки-проекции-соединения (SPJ), а не на многомерной модели. Остальная часть статьи организована следующим образом. В разделе II объясняется и формулируется задача выбора материализованных представлений на основе глобальных планов обработки. Также описывается модель затрат, используемая в работе. В разделе III представлены наши алгоритмы. Вводится двухуровневая структура, подробно объясняются эволюционный алгоритм и применяемые эвристики, включая операции скрещивания, мутации и отбора. В этом разделе также предлагаются методы обработки недопустимых решений во время поиска. Раздел IV содержит экспериментальные результаты, полученные с помощью нашего эволюционного подхода. Несколько гибридных алгоритмов были протестированы и оценены на различных случайно сгенерированных задачах разного размера. Наконец, в разделе V подводятся итоги работы и предлагаются направления для будущих исследований.

# II. Выбор материализованного вида

Выбор материализованных представлений включает три задачи оптимизации: оптимизацию запросов, оптимизацию множества запросов и собственно выбор материализованных представлений. Следует отметить, что набор локально оптимизированных запросов может перестать быть оптимальным при совместном рассмотрении нескольких запросов. Аналогично, оптимальный набор множества запросов не гарантирует оптимальный выбор материализованных представлений, так как другой набор может привести к более эффективным материализованным представлениям. Поэтому важно рассматривать все три задачи вместе при выборе материализованных представлений.

#### *A. Оптимизация запросов*

По данной теме проведено много исследований. Ценный обзор можно найти в работах \[13\] и \[14\]. В оптимизации запросов одной из самых затратных операций является операция соединения (join). Для упрощения в данной статье рассматривается только операция соединения. Таким образом, оптимизация запросов здесь будет пониматься как оптимизация порядка соединений.

Пусть задана база данных $D$ с набором отношений $$R_1, R_2, ..., R_m$$Локальный план обработки определяется как граф запроса, в котором все отношения — это листовые узлы, а все операции (например, соединение, проекция и выборка) — внутренние узлы. Поскольку рассматривается только операция соединения, локальный план обработки для запроса можно представить в виде бинарного дерева соединений, листьями которого являются все отношения, а внутренними узлами — операции соединения. Рёбра в таком дереве маркируются предикатами соединения и селективностью соединения. Предикат соединения сопоставляет кортежи из декартова произведения смежных узлов в значение false или true в зависимости от того, должен ли кортеж включаться в результат. Селективность соединения — это отношение количества включённых кортежей к общему количеству кортежей.

Пространство поиска для оптимизации запросов — это множество всех возможных локальных планов обработки. Каждая точка в пространстве поиска представляет собой конкретный план. Каждая точка пространства поиска имеет связанную с ней стоимость. Поскольку существует множество методов выполнения операции соединения, таких как вложенный цикл (nested loop), сортировочное слияние (sort-merge) и хеш-цикл (hash loop), для дерева обработки существуют различные функции стоимости. Например, левые деревья на рис. 1 обозначают метод соединения с вложенным циклом. Для соединения с вложенным циклом без доступных индексов, каждый кортеж внешнего отношения должен проверяться против каждого кортежа внутреннего отношения, поэтому стоимость операции \$$(R_1 \bowtie R_2)$равна $\|R_1\| * \|R_2\|$.

![Рис. 1. Примеры деревьев соединений с использованием соединения вложенными циклами (деревья слева) и сортировочно-слиянием (деревья справа).](images/2025-05-19 (2).png)

![Рис. 2. Глобальный план обработки должен представлять собой ориентированный ациклический граф (DAG).](images/2025-05-19 (3).png)

### Таблица I

### Возможные порядки вложенности для операций соединения \[3\]

| Число отношений (n) | Деревья обработки | Количество решений (Деревья \* n!) |
|--------------------|-------------------|----------------------------------|
| 1                   | 1                 | 1                                  |
| 2                   | 1                 | 2                                  |
| 3                   | 2                 | 12                                 |
| 4                   | 5                 | 120                                |
| 5                   | 14                | 1,680                              |
| 6                   | 42                | 30,240                             |
| 7                   | 132               | 665,280                            |
| 8                   | 429               | 17,297,280                         |
| 9                   | 1,430             | 518,918,400                        |
| 10                  | 4,862             | 17,643,225,600                     |
| 11                  | 16,796            | 670,442,572,800                    |
| 12                  | 58,786            | 28,158,588,057,600                 |

В пространстве решений особый интерес у исследователей вызывают лево-глубокие деревья обработки. Лево-глубоким деревом называется такое дерево, в котором внутренняя таблица каждого соединения является базовой таблицей. В данной работе мы сосредотачиваем внимание на лево-глубоких деревьях. Для множества отношений Таблица I \[3\] демонстрирует, насколько велико пространство решений. На самом деле было доказано, что оптимизация запросов является задачей класса NP-полных \[15\].

В Рис. 1 стоимости двух деревьев соединения в (1) могут отличаться из-за различных методов соединения. Стоимости двух деревьев соединения в (2) также различаются, хотя структура одинаковая, потому что порядок соединения отношений разный. Левое дерево в (2) имеет вид $((R_1 \bowtie R_2) \bowtie R_3)$, когда правое дерево в (2) – $((R_1 \bowtie R_3) \bowtie R_2)$. Предположим, что размеры отношений $R_1, R_2$ и $R_3$ равны 20, 30 и 40 соответственно. Стоимость левого дерева (2) рассчитывается следующим образом. Сначала вычисляется стоимость $(R_1 \bowtie R_2)$ как $\|R_1\| * \|R_2\|=20*30=600$. Если результаты $(R_1 \bowtie R_2)$ содержим 20 кортежей, то стоимость $((R_1 \bowtie R_2) \bowtie R_3)$ будет $20*40=800$. Итак, общая стоимость: $600+800=1400$. Однако, стоимость правого дерева в (2) будет отличасться. Стоимость $(R_1 \bowtie R_3)$ равна $\|R_1\| * \|R_3\|=20*40=800$. Если результат $(R_1 \bowtie R_3)$ содержит 10 кортежей, то стоимость $((R_1 \bowtie R_3) \bowtie R_2)$ будет равна $10*30=300$, и, следовательно обая стоимость равна $800+300=1100$.

Дано множество планов обработки для запроса. Цель оптимизации запроса — найти такой план обработки, который обеспечивает наименьшую стоимость выполнения запроса. Существуют работы, посвящённые применению эволюционных алгоритмов для оптимизации запросов \[3\], \[11\], \[12\], \[16\], \[17\]. В данной работе оптимизация запросов рассматривается лишь как часть более широкой задачи — выбора материализованных представлений.

#### *B. Оптимизация нескольких запросов*

Хранилище данных (DW) — это репозиторий интегрированной информации, доступной для аналитических запросов. Одна из проблем, с которой необходимо справляться, — это обработка нескольких запросов. В работах \[18\]–\[20\] была представлена систематическая постановка этой задачи.

Предположим, что задано множество запросов$Q=\{Q_1,Q_2,\ldots, Q_n\}$ для каждого запроса $Q_i$ существует как минимум один план переработки, называемсый локальным планом обработки. Глобальный/множественный план обработки для $Q$ – это общий план, позволяющий вычислить результаты всех $n$ запросов. Глобальный/множественный план обработки можно создать, выбрав один план для каждого запроса и затем объединив их вместе. Локально оптимальным планом называется план затрат на обработку запроса $Q_i$ по отдельности. Это соответствует оптимизации запросов. Глобально оптимальный план называется глобальным планом обработки путем объединения общих частей отдельных локальных планов.

Проблема оптимизации множественных запросов (MQO) может быть сформулирована слеющам образом. Дано $n$ наборов локальных планов обработки $P_1,P_2,\ldots,P_n$, где $P_i=\{p_{i1},p_{i2},\ldots,p_{ik_i}\}$ – множество возможных планов для запроса $Q_i,1\leq i \leq n,k_i$ – количество локальных планов обработки для $Q_i$. Требуется найти глобальный/множественный план обработки, выбрав по одному плану из каждого $P_i$ так, чтобы стоимость (стоимость выполнения запросов) глобального/множественного плана обработки была минимальной.

В общем случае объединение локально оптимальных планов не обязательно приводит к глобально оптимальному плану. Следовательно, мы не можем найти глобально оптимальный план, просто объединив локально оптимальные планы. Для поиска глобально оптимального плана часто требуется эвристический алгоритм. В работах \[19\] и \[20\] предлагается эвристический алгоритм поиска, который рассматривает лишь часть всех возможных глобальных планов обработки. При этом некоторые потенциально хорошие планы могут быть упущены. Используя эволюционный подход, наши алгоритмы способны выполнять глобальный поиск и рассматривать все возможные комбинации отдельных планов.

При объединении нескольких планов обработки запросов, то есть нескольких деревьев соединений, формируемый глобальный план обработки должен представлять собой ориентированный ациклический граф (DAG), а не дерево. Это показано на Рис. 2.

#### *C. Выбор материализованных представлений*

В хранилище данных (DW) выбранная информация извлекается заранее и сохраняется в репозитории. Таким образом, DW можно рассматривать как набор материализованных представлений, определённых на основе исходных данных. Задача, с которой мы сейчас сталкиваемся, — это выбор представлений для материализации таким образом, чтобы минимизировать стоимость обработки запросов и поддержки представлений для всех узлов в глобальном плане обработки.

Простой подход — использовать полный перебор, чтобы найти оптимальный набор материализованных представлений для заданного множества запросов. Однако этот подход становится непрактичным при большом пространстве поиска. Было показано, что задача выбора материализованных представлений является NP-трудной \[2\].Для ускорения получения результата необходимо использовать эвристические алгоритмы, чтобы сократить пространство поиска \[2\], \[4\], \[5\]. Однако эффективность эвристического алгоритма сильно зависит от качества самих эвристик, которые на практике могут быть трудными или затратными для получения. Кроме того, эвристические алгоритмы легко застревают в локальном оптимуме.В отличие от них, эволюционные алгоритмы обладают рядом преимуществ, например, они выполняют поиск сразу от множества точек, используя вероятностные правила перехода. Чтобы избежать полного перебора во всём пространстве решений и получить лучшее решение по сравнению с эвристическими методами, мы предлагаем новый эволюционный подход к выбору материализованных представлений.

#### *D. Модель стоимости выбора материализованных представлений*

1.  *Мотивирующий пример:* Наш пример взят из приложения хранилища данных (DW), которое анализирует тенденции в продажах и поставках \[6\]. Отношения и атрибуты схемы для данного приложения представлены ниже.

```         
Item(I_id, I_name, I_price)
Part(P_id, P_name, I-id)
Supplier(S_id, S_name,P_id, City, Cost,
  Preference)
Sales(I_id, Month, Year, Amount)
```

Существует пять следующих запросов.

```         
Q1: Select P_id, min(cost), max(cost)
From Part, Supplier
Where Part.P_id=Supplier.P_id
  And P_name in {“spark_plug,” “gas_kit”}
  Group by P_id
Q2: Select I_id,
  sum(amount*number*min_cost)
From Item, Sales, Part
Where I_name in {“MAZDA,” “NISSAN,”
  “TOYOTA”}
  And year=1996
  And Item.I_id=Sales.I_id
  And Item.I_id=Part.I_id
  And Part.P_id=
    (Select P_id, min(cost) as min_cost
    From Supplier
    Group by P_id)
  Group by I_id
Q3: Select P_id, month sum(amount)
From Item, Sales, Part
Where I_name in {“MAZDA,” “NISSAN,”
  “TOYOTA”}
    And year=1996
    And Item.I_id=Sales.I_id
    And Part.I_id=Item.I_id
    Group by P_id, month
Q4: Select I_id, Sum(amount*I_price)
From Item, Sales
Where I_name in {“MAZDA,” “NISSAN,”
  “TOYOTA”}
  And year=1996
  And Item.I_id=Sales.I_id
  Group by I_id
Q5: Select I_id, avg(amount*I_price)
From Item, Sales
Where I_name in {“MAZDA,” “NISSAN,”
  “TOYOTA”}
  and year=1996
  and Item.I_id=Sales.I_id
  Group by I_id.
```

На Рис. 3 представлен возможный глобальный план обработки запросов для пяти вышеупомянутых запросов, в котором локальные планы доступа для отдельных запросов объединены на основе общих операций с общими наборами данных. Мы называем это планом обработки множественных представлений (MVPP).

Частоты доступа к запросам указаны над каждым узлом запроса. Для упрощения предполагается, что все базовые отношения — `Item`, `Sales`, `Part` и `Supplier` — обновляются только один раз за определённый период времени. В Рис. 3 мы используем сокращения: тысяча — «k», миллион — «m», миллиард — «b». Например, стоимость получения `tmp3` с использованием `tmp1` составляет 36 миллионов.

Теперь необходимо решить, какие узлы следует материализовать, чтобы минимизировать общую стоимость обработки запросов и поддержки представлений. Из графа видно, что существует несколько вариантов выбора набора материализованных представлений, например:

1.  материализовать все прикладные запросы;

2.  материализовать некоторые промежуточные узлы (например, `tmp1`, `tmp3`, `tmp7` и т.д.);

3.  оставить все нелистовые узлы виртуальными.

Стоимость каждого из этих вариантов может быть рассчитана с учётом затрат на обработку запросов и поддержку представлений.

Для расчёта стоимости мы делаем следующие предположения:

-   В отношении `Item`содержится 1 тысяча кортежей.

-   В среднем каждый товар включает десять деталей, следовательно, в таблице `Part` содержится 10 тысяч кортежей.

-   В таблице `Supplier` содержится 50 тысяч (50k) кортежей.

-   В таблице `Sales` хранятся данные за 10 лет — с 1987 по 1996 год. В среднем каждый товар продаётся 100 раз в месяц, что даёт 12 миллионов записей в таблице `Sales`.

-   Стоимость выполнения запроса $Q$ пропорциональна числу строк в таблице, использованной для построения $Q$.

-   Операции выборки(select) и соединения (join) реализуются с использованием линейного поиска и вложенных циклов (nested loop).

![Рис. 3. Мотивирующий пример.](images/2025-05-19%20(6).png)

### Таблица II

### Затраты для различных стратегий материализации представлений

| Материализованные представления | Стоимость обработки запросов | Стоимость обслуживания | Общая стоимость |
|----------------------|-----------------|-----------------|-----------------|
| Item,Sales,Part,Supplier | 8b980m860k | 0 | 8b980m860k |
| tmp3, tmp4, tmp8 | 7b201m547k | 1b350m125k | 8b551m672k |
| tmp3, tmp5 | 416m747k | 16b32m204k | 16b448m951k |
| tmp3, tmp4, tmp7 | 7b276m497k | 1b220m55k | 8b496m552k |
| tmp3, tmp7 | 8b281m547k | 126m122k | 8b407m669k |
| result1,result2,result3,result4 | 1m447k | 17b384m934k | 17b386m381k |

На основе приведённых выше предположений, стоимость каждой операции в узле на Рис. 3 указана справа от соответствующего узла.

Теперь мы можем рассчитать затраты для различных стратегий материализации представлений. Предположим, что некоторые промежуточные узлы материализованы. Для каждого запроса стоимость обработки равна произведению частоты выполнения запроса на стоимость доступа к запросу от материализованного узла (или узлов). Стоимость поддержки материализованного представления — это стоимость его построения (в данном случае предполагается, что при каждом обновлении задействованных базовых отношений представление полностью пересчитывается). Общая стоимость MVPP — это сумма всех затрат на выполнение запросов и затрат на поддержку представлений. Наша цель — найти такой набор узлов для материализации, при котором общая стоимость минимальна. В таблице II представлены некоторые стратегии проектирования материализованных представлений и их соответствующие стоимости. Конечно, в рамках этого примера возможны и многие другие стратегии материализации представлений.

2.  *Модель стоимости:* Глобальный план обработки представляет собой направленный ациклический граф (DAG) может быть описан как $(V,A,C_a^q(v),C_m^r(v),f_q,f_u)$, где $V$ – множество вершин и $A$ – множество дуг(ребёр) над $V$. DAG строится следующим образом.
    1.  Создать вершину каждой операции реляционной алгебры в дереве запросов, каждой базовой табблицы и каждого отдельного запроса.
    2.  Для $v \in V, T(v)$ – отношение, генерируемое соответствующей вершиной $v$. $T(v)$ может быть базовый отношением, промежуточным результатом при обработки запроса или конечным результатом запроса.
    3.  Для любой конечной вершины $v$ (то есть, у нее нет ребер, входящих в вершину), $T(v)$ соответствует базовому запросу. Пусть $L$ – набор конечных узлов.
    4.  Для любой корневой вершины $v$ (то есть, у нее нет ребер, выходящих из вершины), $T(v)$ соответствует глобальному запросу. Пусть $R$ – набор корневых узлов.
    5.  Если базовое отношение или промежуточный результат $T(u)$, соответствующий вершине $u$, требуется для обработки в другом узле $v$, добавляется дуга $u \longrightarrow v$.
    6.  Для каждой вершины $v$ пусть $S(v)$ обозначает исходные узлы, ребра которых направлены на $v$. Для любого $v \in L,S(v) = \emptyset$. Пусть $S^*\{v\}$ – множество потомков $v$.
    7.  Для каждой вершины $v$ пусть $D(v)$ обозначает конечные узлы, на которые указывает $v$. Для любого $v \in R,D(v) = \emptyset$.
    8.  Для $v \in V C_a^q(v)$ – это стоимость запроса $q$, обращающегомя к $T(v)$, $C_m^r(v)$ – это стоимость поддержания $T(v)$ на основе изменений базового отношения $S^*(v) \cap R$, если $T(v)$ реализовано.
    9.  $f_q,f_u$ – это частотта запросов и обслуживания соответственно.

Для расчета стоимости запроса $Q$ используется линейная модель затрат \[21\]. Стоимость выполнения $Q$ определяется количеством строк в таблице, которую запрос $Q_А$ используется для построения $Q$.

Пусть $М$ – набор материализованных представлений, $C_{q_i}(M)$ – стоимость вычислений $q_i$ из набора материализованных представлений $M$, а $C_m(V)$ – стоимость обслуживания при материализации $v$. Тогда общая стоимость обработки запроса $\sum_{q_i\in Q} f_{q_i} C_{q_i}(M)$. Тогда общая стоимость обслуживания $\sum_{v \in M} C_m(v)$. Общая стоисмость материализованных представлений $M$ определяется формулой:

$$
\sum_{q_i \in Q} f_{q_i}(M) + \sum_{v \in M} f_u C_m(v)
$$

Для заданного глобального плана обработки минимизировать указанную общую стоимость.

#### *E. Постановка задачи*

Проблема выбора материализованных представлений может быть сформулирована следующим образом. Дано $n$ наборов локальных планов обработки $P_1,P_2,\ldots,P_n$, где $P_i=\{p_{i1},p_{i2},\ldots,p_{ik_i}\}$ – множество возможных планов для запроса $Q_i,1\leq i \leq n,k_i$ – количество локальных планов обработки для $Q_i$. Требуется выбрать набор представлений для материализации в рамках глобального плана обработки путём объединения $n$ локальных планов (по одному из каждого набора $P_i$ так, чтобы суммарные затраты на выполнение запросов и обслуживание были минимальными. Важно подчеркнуть, что эта проблема отличается от MQO \[6\].

1.  MQO (многозапросовая оптимизация) направлена на поиск оптимального плана обработки для нескольких запросов, выполняемых одновременно, за счёт совместного использования временных результатов, представляющих собой общие подвыражения. В то время как наша задача заключается в том, чтобы найти набор отношений (которые могут быть любыми промежуточными результатами обработки запросов) для материализации таким образом, чтобы общая стоимость (включающая обработку запросов и поддержку представлений) была минимальной.

2.  В MQO глобальный план обработки строится на основе идеи, что совместное использование временных результатов должно быть менее затратным, чем последовательное выполнение запросов. Однако это утверждение может быть неверным для любого произвольного состояния базы данных. Например, совместное использование временного результата может оказаться неудачным решением, если в базе определены индексы на базовые отношения. Стоимость обработки выборки через индекс или через уже существующий временный результат напрямую зависит от размера этих двух структур. В нашей задаче, если промежуточный результат материализуется, мы можем при необходимости создать соответствующий индекс на нём. Таким образом, гарантируется прирост производительности, если промежуточный результат материализован. Если при этом промежуточный результат является общим подвыражением, которое может использоваться более чем одним запросом, то достигается также выгода при обслуживании представлений.

3.  В MQO (многозапросовой оптимизации) конечная цель — достижение наилучшей производительности, тогда как в нашей задаче необходимо учитывать как стоимость выполнения запросов, так и стоимость поддержки представлений.

4.  В MQO входными данными является набор запросов, а выходом — глобально оптимальный план выполнения.В нашем случае вход включает: набор глобальных запросов и частоты их выполнения, набор базовых отношений и частоты их обновления.Выходом является один или несколько глобальных планов обработки с материализованными представлениями, которые минимизируют суммарные затраты на выполнение запросов и поддержку представлений.

Точно так же, как невозможно гарантировать получение глобально оптимального плана обработки путём объединения локально оптимальных планов, мы не можем гарантировать и оптимальный выбор материализованных представлений, даже если у нас уже есть глобально оптимальный план обработки. Это связано с тем, что оптимизация глобального плана обработки не учитывает стоимость поддержки представлений. Например, оптимальный глобальный план может иметь стоимость выполнения запросов 333 млн (м), а общая стоимость (выполнение + поддержка) при этом составит 370 м. Однако если использовать неоптимальный глобальный план с стоимостью запросов 350 м, то можно получить такой набор материализованных представлений, при котором общая стоимость составит всего 360 м, что меньше, чем в первом случае. Таким образом, не всегда выгодно полагаться на глобально оптимальный план обработки, если цель — минимизация общей стоимости.

![Рис. 4. Структура наших алгоритмов.](images/2025-05-19 (13).png)

![Рис. 5. Абстрактная структура эволюционных алгоритмов.](images/2025-05-19 (14).png)
