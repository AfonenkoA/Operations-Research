---
engine: knitr
---

```{r}
1
```

# Задача генетического алгоритма {#sec-lab-extra-genetic}

<!--https://wwwiti.cs.uni-magdeburg.de/~eike/selftuning/sources/an-evolutionary-approach-to.pdf-->

## Materialized views {#sec-lab-extra-genetic-materialized-view}

Рассмотрим только некоторые подзадачи. Глобальный план обработки запросов получается из локального путём объединения вершин.

Выбор материализованных представлений включает три задачи оптимизации: оптимизацию запросов, оптимизацию множества запросов и собственно выбор материализованных представлений. Следует отметить, что набор локально оптимизированных запросов может перестать быть оптимальным при совместном рассмотрении нескольких запросов. Аналогично, оптимальный набор множества запросов не гарантирует оптимальный выбор материализованных представлений, так как другой набор может привести к более эффективным материализованным представлениям. Поэтому важно рассматривать все три задачи вместе при выборе материализованных представлений.

Для оптимального выбора матриализованных представлений для набора запросов должны быть решены 3 NP полные задачи.

### Локальная оптимизация запроса {#sec-lab-extra-genetic-materialized-view-local-query}

Пусть есть три таблицы со следующей схемой

```{mermaid}
erDiagram
    direction LR
    catergories ||--|{ product : has
    manufacturers ||--|{ product : has
    catergories {
        int id
        text name
    }

    manufacturers {
        int id
        text name
        text country
    }
    product {
        int id
        int category_id
        int manufacturer_id
        text name
    }
```

и запрос на выборку из всех трёх таблиц

``` sql
SELECT * 
FROM product
JOIN catergories ON product.category_id = catergories.id
JOIN manufacturers ON product.manufacturer_id = manufacturers.id
```

В оптимизации запросов одной из самых затратных операций является операция соединения (JOIN). Оптимизация оптимизация запроса здесь будет пониматься как оптимизация порядка соединений

```{r}
#| include: false
g <- igraph::make_empty_graph() |>
  igraph::add_vertices(nv = 3, name = c('prod','man','cat'))

g1 <- igraph::add_vertices(g, nv = 2, name = c('J(prod,cat)','J(J(prod,cat),man)'))|>
  igraph::add_edges(c('prod','J(prod,cat)',
                      'cat','J(prod,cat)',
                      'J(prod,cat)','J(J(prod,cat),man)',
                      'man', 'J(J(prod,cat),man)'))

g2 <- igraph::add_vertices(g, nv = 2, name = c('J(prod,man)','J(J(prod,man),cat)'))|>
  igraph::add_edges(c('prod','J(prod,man)',
                      'man','J(prod,man)',
                      'J(prod,man)','J(J(prod,man),cat)',
                      'cat', 'J(J(prod,man),cat)')) 

```

::: {.layout-ncol="2"}
```{r}
#| echo: false

set.seed(42)
plot(g1, layout = igraph::layout_as_tree(g1, flip.y = FALSE))
```

```{r}
#| echo: false

set.seed(42)
plot(g2, layout = igraph::layout_as_tree(g1, flip.y = FALSE))
```
:::

Локальный план обработки определяется как граф запроса, в котором все отношения — это листовые узлы, а все операции (например, соединение, проекция и выборка) — внутренние узлы. Поскольку рассматривается только операция соединения, локальный план обработки для запроса можно представить в виде бинарного дерева соединений, листьями которого являются все отношения, а внутренними узлами — операции соединения. Рёбра в таком дереве маркируются предикатами соединения и селективностью соединения. Предикат соединения сопоставляет кортежи из декартова произведения смежных узлов в значение *false* или *true* в зависимости от того, должен ли кортеж включаться в результат. Селективность соединения — это отношение количества включенных кортежей к общему количеству кортежей.

Стоимости двух деревьев соединения также различаются, хотя структура одинаковая, потому что порядок соединения отношений разный. Левое дерево в имеет вид $((cat \bowtie prod) \bowtie man)$, когда правое дерево – $((cat \bowtie man) \bowtie prod)$. Предположим, что размеры таблиц $cat$, $man$ и $prod$ равны 20, 30 и 100 соответственно. Стоимость левого дерева рассчитывается следующим образом. Сначала вычисляется стоимость $(cat \bowtie prod)$ как $\|cat\| \cdot \|prod\|=20 \cdot 100=2000$. Если результаты $(cat \bowtie prod)$ содержим 50 кортежей, то стоимость $((cat \bowtie prod) \bowtie man)$ будет $50 \cdot 30=1500$. Итак, общая стоимость: $2000+1500=3500$. Однако, стоимость правого дерева в будет отличаться. Стоимость $(cat \bowtie man)$ равна $\|cat\| \cdot \|man\|=20 \cdot 30=600$. Если результат $(cat \bowtie man)$ содержит 30 кортежей, то стоимость $((cat \bowtie man) \bowtie prod)$ будет равна $30 \cdot 100=3000$, и, следовательно общая стоимость равна $600 + 3000 = 3500$.

Таким образом для определения оптимального локального плана выполнения запроса требуется решить. NP полную задачу. Данная задача далее рассматриваться **не будет** в связи с подходом к построению глобального плана указанного в пункте @sec-lab-extra-genetic-materialized-view-global-plan.

### Глобальная оптимизация нескольких запросов {#sec-lab-extra-genetic-materialized-view-global-query}

Дано множество планов обработки для запроса. Цель оптимизации запроса — найти такой план обработки, который обеспечивает наименьшую стоимость выполнения запроса.

Глобальный план выполнения получается путём объединения локальных планов. Таким образом два запроса могут быть объединиы по общим узлам.

Рассмотрим следующие 3 запроса которые попарно используют 4 таблицы (T1, T2, T3, T4)

``` sql
SELECT * FROM T1 JOIN T2, T3
SELECT * FROM T1 JOIN T2, T4
SELECT * FROM T2 JOIN T3, T4
```

```{r}
#| include: false

g1 <- igraph::make_empty_graph() |>
  igraph::add_vertices(nv = 4, name = c('T1','T2','T3','J(T1,T2,T3)')) |>
  igraph::add_edges(c('T1','J(T1,T2,T3)','T2','J(T1,T2,T3)','T3','J(T1,T2,T3)'))
  
g2 <- igraph::make_empty_graph() |>
  igraph::add_vertices(nv = 4, name = c('T1','T2','T4','J(T1,T2,T4)')) |>
  igraph::add_edges(c('T1','J(T1,T2,T4)','T2','J(T1,T2,T4)','T4','J(T1,T2,T4)'))

g3 <- igraph::make_empty_graph() |>
  igraph::add_vertices(nv = 4, name = c('T2','T3','T4','J(T2,T3,T4)')) |>
  igraph::add_edges(c('T2','J(T2,T3,T4)','T3','J(T2,T3,T4)','T4','J(T2,T3,T4)'))
```

Их локальные планы выполнения

::: {.layot-ncol="3"}
```{r}
#| echo: false
plot(g1, layout = igraph::layout_as_tree)
```

```{r}
#| echo: false
plot(g2, layout = igraph::layout_as_tree)
```

```{r}
#| echo: false
plot(g3, layout = igraph::layout_as_tree)
```
:::

При объединении нескольких планов обработки запросов, то есть нескольких деревьев соединений, формируемый глобальный план обработки должен представлять собой ориентированный ациклический граф (DAG), а не дерево.

```{r}
#| echo: false
#| fig-height: 6

set.seed(42)
igraph::make_empty_graph() |>
  igraph::add_vertices(nv = 11, name = c('Q1','Q2','Q3','T1','T2','T3','T4','J(T1,T2)','J(J(T1,T2),T3)','J(J(T1,T2),T4)', 'J(T1,T3,T4)')) |>
  igraph::add_edges(c('T1', 'J(T1,T2)',
                      'T2', 'J(T1,T2)',
                      'T1', 'J(T1,T3,T4)',
                      'T3', 'J(T1,T3,T4)',
                      'T4', 'J(T1,T3,T4)',
                      'J(T1,T2)', 'J(J(T1,T2),T3)',
                      'T3','J(J(T1,T2),T3)',
                      'J(T1,T2)','J(J(T1,T2),T4)',
                      'T4','J(J(T1,T2),T4)',
                      'J(J(T1,T2),T3)','Q1',
                      'J(J(T1,T2),T4)','Q2',
                      'J(T1,T3,T4)','Q3')) |> 
plot()
```

При объединении в один глобальный план возникает несколько вариантов промежуточных объединений, например JOIN(T1,T2) или JOIN(T2,T3). В общем случае объединение локально оптимальных планов не обязательно приводит к глобально оптимальному плану. Следовательно, мы не можем найти глобально оптимальный план, просто объединив локально оптимальные планы. Выбор оптимального глобального плана так-же является NP полной задачей и рассматриваться **не будет** в связи с подходом к построению глобального плана указанного в пункте @sec-lab-extra-genetic-materialized-view-global-plan.

### Выбор материализованных представления {#sec-lab-extra-genetic-materialized-view-selection}

Для сокращения вычислительных затрат можно материализовать некоторые совместно используемые промежуточные узлы. Таким образом они вычисляются один раз, Есть смысл материализовывать только представления используемые совместно. Матрериализованный промежуточный узел вычисляется только один раз. Другие запросы используют его.

В хранилище данных (DW) выбранная информация извлекается заранее и сохраняется в репозитории. Таким образом, DW можно рассматривать как набор материализованных представлений, определённых на основе исходных данных. Задача, с которой мы сейчас сталкиваемся, — это выбор представлений для материализации таким образом, чтобы минимизировать стоимость обработки запросов и поддержки представлений для всех узлов в глобальном плане обработки.

Простой подход — использовать полный перебор, чтобы найти оптимальный набор материализованных представлений для заданного множества запросов. Однако этот подход становится непрактичным при большом пространстве поиска. Было показано, что задача выбора материализованных представлений является NP-трудной \[2\].Для ускорения получения результата необходимо использовать эвристические алгоритмы, чтобы сократить пространство поиска \[2\], \[4\], \[5\]. Однако эффективность эвристического алгоритма сильно зависит от качества самих эвристик, которые на практике могут быть трудными или затратными для получения. Кроме того, эвристические алгоритмы легко застревают в локальном оптимуме.В отличие от них, эволюционные алгоритмы обладают рядом преимуществ, например, они выполняют поиск сразу от множества точек, используя вероятностные правила перехода. Чтобы избежать полного перебора во всём пространстве решений и получить лучшее решение по сравнению с эвристическими методами, мы предлагаем новый эволюционный подход к выбору материализованных представлений.

### Модель запроса {#sec-lab-extra-genetic-materialized-view-query-model-plan}

Рассмотрим запрос выборки на языке SQL: "Товары дороже средней цены"

``` sql
SELECT products.product_name, price_change.new_price
FROM products
JOIN price_change ON products.id = price_change.product_id
WHERE price_change.new_price > (SELECT AVG(price_change.price_change) FROM price_change)
```

Разделим его на подзапрос, вычисляющий среднюю цену `average_price`

``` sql
SELECT AVG(price_change.price_change)
FROM price_change
```

и главный запрос

``` sql
SELECT products.product_name, price_change.new_price
FROM products
JOIN price_change ON products.id = price_change.product_id
WHERE price_change.new_price > average_price
```

В задаче будет рассматриваться максимально упрощенное подмножество операторов языка SQL. Рассмотрим, как предстваить этот запрос в виде графа вычислений.

```{r}
source('sql.R')
```

С каждым вычислительным узлом связана таблица, эта таблица передаётся в главном аргументе (связь val)

#### JOIN {#sec-lab-extra-genetic-materialized-view-query-model-plan-join}

Рассмотрим часть запроса

``` sql
FROM products
JOIN price_change ON products.id = price_change.product_id
```

Представленную в yaml

``` yaml
body:
  join:
    - products
    - price_change
```

В отличии от других у функции JOIN аргументы (таблицы) равнозначны, что отличает её от других функций, которые имеют один главный аргумент (`val`), к которому они применяют другие свои аргументы `arg`. Для однотипной обработки введём фиктивный главный аргумент `JOIN EMPTY` --- `JE`.

```{r}
#| echo: false
q_join <- list(fun = 'JOIN', val = 'JE', 'products','price_change')
g <- g_join <- init_graph() |>
  add_table('products') |>
  add_table('price_change')

add_query(q_join,'QJ') |> invisible()
gf_join <- g
set.seed(42)
plot(gf_join, layout = igraph::layout_as_tree)
```

На текущий момент граф выглядит следующим образом. Он состоит из вершин, с именами. И операциями в вершинах

```{r}
#| include: false

v_join <- igraph::as_data_frame(gf_join, 'vertices')
e_join <- igraph::as_data_frame(gf_join, 'edges')
```

`query` -- корневые вершины графа, представляющие собой запросы

```{r}
#| echo: false

knitr::kable(e_join)
knitr::kable(v_join)
```

```{r}
#| include: false
table <- tibble::tibble(col = c('products.id',
         'products.name',
         'products.category_id',
         'products.manufacturer_id',
         'products.price',
         'price_change.id',
         'price_change.product_id',
         'price_change.price',
         'price_change.change_date'), 
         type = c('INTEGER','TEXT','INTEGER','INTEGER', 'REAL', 'INTEGER','INTEGER','REAL','DATE'))
lines <- 100 * 150
```

Соответственно на данный момент результатом операции будет таблица, состоящая из $100 * 150 = 15000$ строк и следующих столбцов

```{r}
#| echo: false
kintr::kable(table)
```

::: callout-note
Считается, что у таблицы JoinEmpty (JE) нет столбцов и одна строка.
:::

#### WHERE {#sec-lab-extra-genetic-materialized-view-query-model-plan-where}

Добавим к запросу условие отбора, предварительно определив подзапрос

``` sql
FROM products
JOIN price_change ON products.id = price_change.product_id
WHERE price_change.new_price > average_price
```

Представленную в yaml

``` yaml
body:
  join:
    - products
    - price_change
  where:
    - name: products.id = price_change.product_id
      sample: 0.3
    - name: price_change.new_price > average_price
      sample: 0.3
      depends: average_price
```

```{r}
#| include: false

g <- g_where <- add_condition(g_join, 'products.id = price_change.product_id') |>
add_condition('average_price')

q_where <-  list(fun = 'WHERE', 
           val = q_join, 
           'products.id = price_change.product_id', 
           'average_price')

add_query(q_where,'QW') |> invisible()
gf_where <- g
v_where <- igraph::as_data_frame(gf_where, 'vertices')
e_where <- igraph::as_data_frame(gf_where, 'edges')
```

```{r}
#| echo: false
#| fig-height: 6

set.seed(42)
plot(g)
```

Заметим, что условие `price_change.new_price > average_price` зависит от подзапроса `average_price`, поэтому и назовём его так-же для удобства.

В граф были добавлены...

```{r}
#| echo: false

knitr::kable(dplyr::setdiff(v_where,v_join))
```

И рёбрами

```{r}
#| echo: false

knitr::kable(dplyr::setdiff(e_where,e_join))
```

```{r}
#| include: false

lines <- lines * 0.3^2
```

Так как оба условия имеют селективность $0.3$, то общее число строк станет $15000 \cdot {0.3}^2=1350$, а столбцы останутся всё те же.

#### SELECT {#sec-lab-extra-genetic-materialized-view-query-model-plan-select}

Аргументом запроса с

```{r}
#| include: false

g <- g_select <- add_column(g_where, 'products.product_name') |> 
  add_column('price_change.new_price')

q_select <- list(fun='SELECT', val = q_where, 'products.product_name', 'price_change.new_price')
add_query(q_select,'QS') |> invisible()
gf_select <- g
v_select <- igraph::as_data_frame(gf_select, 'vertices')
v_select <- igraph::as_data_frame(gf_select, 'edges')
```

```{r}
#| echo: false
#| fig-height: 6

set.seed(42)
plot(g)
```

В граф были добавлены...

```{r}
#| echo: false
knitr::kable(dplyr::setdiff(v_where,v_join))
```

И рёбрами

```{r}
#| echo: false
knitr::kable(dplyr::setdiff(e_where,e_join))
```

В этом случае в таблице останутся только два столбца

```{r}
#| echo: false
table <- dplyr::filter(table, col %in% c('products.product_name', 'price_change.new_price'))
knitr::kable(table)
```

#### AGGREGATE {#sec-lab-extra-genetic-materialized-view-query-model-plan-aggregate}

IDENTITY не изменяет текущий столбец

Продемонстрируем работу *AGGREGATE* на подзапросе

#### Добавление подзапроса {#sec-lab-extra-genetic-materialized-view-query-model-plan-subquery}

Объединив главный запрос и подзапрос получаем следующий граф вычислений.

```{r}
sq <- list(fun = 'AGGREGATE', val = list(fun = 'SELECT', val = 'price_change', 'price_change.new_price'), 'AVG')

add_subquery(sq,'average_price') |> invisible()
```

#### Представление в yaml {#sec-lab-extra-genetic-materialized-view-query-model-plan-yaml}

Структура таблиц определена в файле

``` yaml
- name: products
  lines: 100
  columns:
    - name: id
      type: INTEGER
    - name: name
      type: TEXT
    - name: category_id
      type: INTEGER
    - name: manufacturer_id
      type: INTEGER
    - name: price
      type: REAL
- name: price_change
  lines: 150
  columns:
    - name: id
      type: INTEGER
    - name: product_id
      type: INTEGER
    - name: price
      type: REAL
    - name: change_date
      type: DATE
```

Таким образом представленный тут запрос сохраняется в yaml структуре

``` yaml
queries:
  - desc: Товары дороже средней цены
    name: products_above_avg_price
    body:
      join:
        - products
        - price_change
      where:
        - name: products.id = price_change.product_id
          sample: 0.3
        - name: price_change.new_price > average_price
          sample: 0.3
          depends: average_price
      select:
        - products.product_name
        - price_change.new_price

subqueries:
  - desc: Вычисление средней цены
    name: average_price
    body:
      from: price_change
      select:
        - price_change.new_price
      aggregate:
        - AVG
```

### Стоимость хранения

Размеры типов данных в байтах приведены ниже

```{r}
#| echo: false

datatypes <- tibble::tibble(name = 'INTEGER', size = 4)
knitr::kable(datatypes)
```

Таким образом размер сохраняемой таблицы основного запроса на каждом этапе

```{r}
tibble::tibble(fun = c('JOIN','WHERE','SELECT'), 
num_col = purrr::map_int(list(),nrow),
size = 1L:3L)
```

И подзапроса. SELECT и AGGREGATE

### Стоимость вычисления запроса {#sec-lab-extra-genetic-materialized-view-query-cost}

Все узлы имеют свою стоимость вычисления. Если узел является листом (Таблица, независимое условие, столбец), то стоимость его вычисления равна нулю. Стоимость вычисления функции складывается со стоимостью вычисления её аргументов рекурсивно до получения ...

Каждый функциональный узел JOIN, WHERE, SELECT, AGGREGATE определяет две характеристики: стоимость его вычисления, и объём полученной таблицы (столбцы + количество строк)

#### JOIN {#sec-lab-extra-genetic-materialized-view-query-cost-join}

Для JOIN применяется алгоритм соединения, поэтому стоимость операции оценивается как $n \log{n}$, где n число строк таблицы результата. N получается перемножением строк аргументов.

#### WHERE {#sec-lab-extra-genetic-materialized-view-query-cost-where}

Условие применяется последовательно к каждой строке для отбора, поэтому стоимость вычисления пропорциональна количеству условий и числу строк. $N \cdot k$

#### SELECT {#sec-lab-extra-genetic-materialized-view-query-cost-select}

Операция Select имеет стоимость log от числа строк.

#### AGGREGATE {#sec-lab-extra-genetic-materialized-view-query-cost-aggregate}

| Функция  | Стоимость |
|----------|-----------|
| IDENTITY | 0         |
| COUNT    |           |
| SUM      |           |
| MAX      |           |
| AVG      |           |
| MIN      |           |
| DISTINCT |  n log n  |

В примере рассматриваются следующие функции агрегации

Для всех аргументов надо задавать compute и storage, даже для элементов join из-за подзапросов join может быть в subquety может быть в join, поэтому надо обрабатывать и его стоимотсь. А может быть и в Where. Если узел сохранён в память, то его стоимость compute = 0, а стоимость хранения зависит от размера. Если нет, то он обязательно расчитывается (compute), а потом принимается решение о его сохранении. Обратите внимание на функции E(g)\[.to,.from\] и V(g). В графе с помощью аттрибуа показано. Внутри AGG кроме Identity линейно зависит от колличества строк

### Целевая функция {#sec-lab-extra-genetic-materialized-view-objective}

Целевая функция состоит из стоимости выполения всех запросов и стоимости обсуживания всех представлений. Стоимость выполнения запроса умножить на частоту этих запросов. Стоимость обсуживания прямо пропорциональна размеру материализуемого представления. Частоты заданны в файле. Для запросов и представлений частоты заданны в файле.

Теперь мы можем рассчитать затраты для различных стратегий материализации представлений. Предположим, что некоторые промежуточные узлы материализованы. Для каждого запроса стоимость обработки равна произведению частоты выполнения запроса на стоимость доступа к запросу от материализованного узла (или узлов). Стоимость поддержки материализованного представления — это стоимость его построения (в данном случае предполагается, что при каждом обновлении задействованных базовых отношений представление полностью пересчитывается). Общая стоимость MVPP — это сумма всех затрат на выполнение запросов и затрат на поддержку представлений. Наша цель — найти такой набор узлов для материализации, при котором общая стоимость минимальна. В таблице II представлены некоторые стратегии проектирования материализованных представлений и их соответствующие стоимости. Конечно, в рамках этого примера возможны и многие другие стратегии материализации представлений.

Модель стоимости: Глобальный план обработки представляет собой направленный ациклический граф (DAG) может быть описан как $(V,A,C_a^q(v),C_m^r(v),f_q,f_u)$, где $V$ – множество вершин и $A$ – множество дуг(ребёр) над $V$. DAG строится следующим образом.

Создать вершину каждой операции реляционной алгебры в дереве запросов, каждой базовой таблицы и каждого отдельного запроса.

Для $v \in V, T(v)$ – отношение, генерируемое соответствующей вершиной $v$. $T(v)$ может быть базовый отношением, промежуточным результатом при обработки запроса или конечным результатом запроса.

Для любой конечной вершины $v$ (то есть, у нее нет ребер, входящих в вершину), $T(v)$ соответствует базовому запросу. Пусть $L$ – набор конечных узлов.

Для любой корневой вершины $v$ (то есть, у нее нет ребер, выходящих из вершины), $T(v)$ соответствует глобальному запросу. Пусть $R$ – набор корневых узлов.

Если базовое отношение или промежуточный результат $T(u)$, соответствующий вершине $u$, требуется для обработки в другом узле $v$, добавляется дуга $u \longrightarrow v$.

Для каждой вершины $v$ пусть $S(v)$ обозначает исходные узлы, ребра которых направлены на $v$. Для любого $v \in L,S(v) = \emptyset$. Пусть $S^*\{v\}$ – множество потомков $v$.

Для каждой вершины $v$ пусть $D(v)$ обозначает конечные узлы, на которые указывает $v$. Для любого $v \in R,D(v) = \emptyset$.

Для $v \in V C_a^q(v)$ – это стоимость запроса $q$, обращающегомя к $T(v)$, $C_m^r(v)$ – это стоимость поддержания $T(v)$ на основе изменений базового отношения $S^*(v) \cap R$, если $T(v)$ реализовано.

$f_q,f_u$ – это частота запросов и обслуживания соответственно.

Для расчета стоимости запроса $Q$ используется линейная модель затрат \[21\]. Стоимость выполнения $Q$ определяется количеством строк в таблице, которую запрос $Q_А$ используется для построения $Q$.

Пусть $М$ – набор материализованных представлений, $C_{q_i}(M)$ – стоимость вычислений $q_i$ из набора материализованных представлений $M$, а $C_m(V)$ – стоимость обслуживания при материализации $v$. Тогда общая стоимость обработки запроса $\sum_{q_i\in Q} f_{q_i} C_{q_i}(M)$. Тогда общая стоимость обслуживания $\sum_{v \in M} C_m(v)$. Общая стоисмость материализованных представлений $M$ определяется формулой:

$$
\sum_{q_i \in Q} C_{q_i} f_{q_i}(M)  + \sum_{v \in M} f_u C_m(v)
$$

Для заданного глобального плана обработки минимизировать указанную общую стоимость.

Точно так же, как невозможно гарантировать получение глобально оптимального плана обработки путём объединения локально оптимальных планов, мы не можем гарантировать и оптимальный выбор материализованных представлений, даже если у нас уже есть глобально оптимальный план обработки. Это связано с тем, что оптимизация глобального плана обработки не учитывает стоимость поддержки представлений. Например, оптимальный глобальный план может иметь стоимость выполнения запросов 333 млн (м), а общая стоимость (выполнение + поддержка) при этом составит 370 м. Однако если использовать неоптимальный глобальный план с стоимостью запросов 350 м, то можно получить такой набор материализованных представлений, при котором общая стоимость составит всего 360 м, что меньше, чем в первом случае. Таким образом, не всегда выгодно полагаться на глобально оптимальный план обработки, если цель — минимизация общей стоимости.

### Построение глобального плана запросов {#sec-lab-extra-genetic-materialized-view-global-plan}

```{r}
g <- igraph::read_graph('plan.graphml', format = 'graphml')
igraph::V(g)$name
```

И csv файлы

Здесь характеристики того общего графа. Граф построен на использовании предположения, что в первую очередь объединяются узлы, имеющие наибольшее число общих аргументов. Про свойство узлов, возможно таблицу функции


Теперь необходимо решить, какие узлы следует материализовать, чтобы минимизировать общую стоимость обработки запросов и поддержки представлений. Из графа видно, что существует несколько вариантов выбора набора материализованных представлений, например:

материализовать все прикладные запросы;

материализовать некоторые промежуточные узлы (например, tmp1, tmp3, tmp7 и т.д.);

оставить все нелистовые узлы виртуальными.

Стоимость каждого из этих вариантов может быть рассчитана с учётом затрат на обработку запросов и поддержку представлений.

Для расчёта стоимости мы делаем следующие предположения:

В отношении Itemсодержится 1 тысяча кортежей.

В среднем каждый товар включает десять деталей, следовательно, в таблице Part содержится 10 тысяч кортежей.

В таблице Supplier содержится 50 тысяч (50k) кортежей.

В таблице Sales хранятся данные за 10 лет — с 1987 по 1996 год. В среднем каждый товар продаётся 100 раз в месяц, что даёт 12 миллионов записей в таблице Sales.

Стоимость выполнения запроса $Q$ пропорциональна числу строк в таблице, использованной для построения $Q$.

Операции выборки(select) и соединения (join) реализуются с использованием линейного поиска и вложенных циклов (nested loop).

### Решение генетическим алгоритмом {#sec-lab-extra-genetic-materialized-view-genetic-alghorithm}

Таким образом получается, что целевая функция зависит от набора материализуемых представлений. Выбор представления для материализации это 0,1. Следовательно структуру задачи можно представить битовой строкой, где позици (индекс) это номер представления, а занчение да - нет.

::: callout-tip
В связи с типичностью задачи, рекомендуется использовать пакет решателя. Например в R это GA
:::

#### Операция скрещивания {#sec-lab-extra-genetic-materialized-view-genetic-alghorithm-crossover}

#### Операция мутации {#sec-lab-extra-genetic-materialized-view-genetic-alghorithm-mutatuin}

#### Отбор особей {#sec-lab-extra-genetic-materialized-view-genetic-alghorithm-selection}

JOIN можно в том числе на промежуточный запрос

разные способы join.

У таблицы это колличество строк, ширина стобца И тогда на каждом этапе тоже вычисляется количество строк и набор столбцов

Для начала все условия и запросы должны быть отсортированы.

Join перемножает аргументы У condition это процент подходящих записей У select это относительный размер столбца в таблице У

сразу через датафрейм. JOIN(1,2), TABLE1, TABLE2, FILTER(FILTER(FILTER(JOIN(TABLE1,TABLE2),COND1))),
