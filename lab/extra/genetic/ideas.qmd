<!--https://wwwiti.cs.uni-magdeburg.de/~eike/selftuning/sources/an-evolutionary-approach-to.pdf-->


Модель стоимости: Глобальный план обработки представляет собой направленный ациклический граф (DAG) может быть описан как $(V,A,C_a^q(v),C_m^r(v),f_q,f_u)$, где $V$ – множество вершин и $A$ – множество дуг(ребёр) над $V$. DAG строится следующим образом.

Создать вершину каждой операции реляционной алгебры в дереве запросов, каждой базовой таблицы и каждого отдельного запроса.

Для $v \in V, T(v)$ – отношение, генерируемое соответствующей вершиной $v$. $T(v)$ может быть базовый отношением, промежуточным результатом при обработки запроса или конечным результатом запроса.

Для любой конечной вершины $v$ (то есть, у нее нет ребер, входящих в вершину), $T(v)$ соответствует базовому запросу. Пусть $L$ – набор конечных узлов.

Для любой корневой вершины $v$ (то есть, у нее нет ребер, выходящих из вершины), $T(v)$ соответствует глобальному запросу. Пусть $R$ – набор корневых узлов.

Если базовое отношение или промежуточный результат $T(u)$, соответствующий вершине $u$, требуется для обработки в другом узле $v$, добавляется дуга $u \longrightarrow v$.

Для каждой вершины $v$ пусть $S(v)$ обозначает исходные узлы, ребра которых направлены на $v$. Для любого $v \in L,S(v) = \emptyset$. Пусть $S^*\{v\}$ – множество потомков $v$.

Для каждой вершины $v$ пусть $D(v)$ обозначает конечные узлы, на которые указывает $v$. Для любого $v \in R,D(v) = \emptyset$.

Для $v \in V C_a^q(v)$ – это стоимость запроса $q$, обращающегомя к $T(v)$, $C_m^r(v)$ – это стоимость поддержания $T(v)$ на основе изменений базового отношения $S^*(v) \cap R$, если $T(v)$ реализовано.

$f_q,f_u$ – это частота запросов и обслуживания соответственно.

Для расчета стоимости запроса $Q$ используется линейная модель затрат \[21\]. Стоимость выполнения $Q$ определяется количеством строк в таблице, которую запрос $Q_А$ используется для построения $Q$.


```{r}
#| fig-width: 20

plot(g)
```

```{r}
plot(igraph::make_tree(10) %du% igraph::make_tree(10))
```


```{r}
#| fig-width: 20

tg <- igraph::unfold_tree(g, mode = 'in', roots = 'Q1')$tree 
tg <- igraph::subgraph(g, which(igraph::degree(tg) != 0))
```

out.callback = function(graph, data, extra) {
  print(data)
}


```{r}
#| fig-width: 20
plot(tg, layout=igraph::layout_as_tree)
```

```{r}
create_tree(40, children = 3, directed = TRUE)
```


```{r}
igraph::V(g)[name=='Q1'] |> as.integer()
```


```{r}
igraph::subgraph(g, c(2,3,5,21,31,20)) |> plot()
```


```{r}
as_tbl_graph(g) |>
to_dfs_tree(16, mode = 'in')
```

```{r}
g
```

```{r}
igraph::V(g)[[1]]$compute <- TRUE
```


```{r}
length(igraph::E(g)[.to('JE')])
```

```{r}
process <- function(node)
{
  in_nodes <- igraph::E(g)[.to(node)] # & label == args, & label == arg
  
  if(length(in_nodes) == 0L)
    return(1)
  else
  igraph::E(g)[.to(node)] |> 
igraph::tail_of(g, es = _) |> 
purrr::reduce(\(cost,node) cost + process(node), .init = 0)
}

process()

```

```{r}
i <- igraph::make_empty_graph() |> igraph::add_vertices(1, name = list(list(1,2)))
```


```{r}
igraph::V(i)$name
```
