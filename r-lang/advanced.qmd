# Продвинутый R

@advanced-r @deep-r

При объединении объектов разных типов в вектор, они приводятся к более широкому (implicit coercion)

```{r}
class(c(TRUE, FALSE))
class(c(1L, TRUE))
class(c(1L, 2L))
class(c(1L, 2.5))
class(c(1L, 2.5, 2.5+1i))
class(c(1L, 2L, 2.5+1i, "12"))
```

## Встроенные константы

В R зарезервирован набор специальных констант:

-   **Inf** -- *бесконечность*
-   **NA** -- *Not Available*. Отсутствующее значение. Используется для обозначения пропущенных значений в данных.
-   **NaN** -- *Not A Number*. Определяет неопределенное число или «не число».
-   **NULL** -- представляет нулевой объект. Часто используется когда возвращаема величина выражения или функции не определена.
-   **pi** -- *3.141593*

```{r}
pi/Inf
```

## Пропущенные значения

**NA**, **NaN** -- используются для работы с пропущенными значениями. **is.na** -- функция для проверки наличия в векторе элементов с пропущенными значениями типа **NA**. **NA** может иметь тип *integer*, *numeric*, *character*. **is.nan** -- функция для проверки наличия в векторе элементов с пропущенными значениями типа **NaN**.

```{r}
x <- c(1, NaN, NA, 10, 3)
is.na(x)
is.nan(x)
```

## Имена

Имена (Names) – используются для лучшего понимания объектов и написания программного кода. Элементы объектов могут иметь имена. **names** -- функция для присвоения имен элементам объектов.

```{r}
x <- 1:3
names(x)
names(x) <- c("foo", "bar", "norf")
names(x)
```

Списки и матрицы также могут иметь имена.

```{r}
list(a = 1, b = 2, c = 3)
m <- matrix(1:4, nrow = 2, ncol = 2)
dimnames(m) <- list(c("a", "b"), c("c", "d"))
m
```

## Атрибуты объектов

Объекты характеризуются атрибутами которые могут быть рассмотрены, как метаданные для объектов. Не все объекты имеют атрибуты. Атрибуты используются для упрощения понимания и описания объектов. Примеры атрибутов объектов:

-   names, dimnames
-   dimensions
-   class
-   length
-   прочие, определенные пользователем, атрибуты (metadata) Для доступа к атрибутам объекта используется функция **attributes**

```{r}
x <- cbind(a = 1:3, pi = pi)
x
attributes(x)
```

## Векторизированные вычисления

Использование операторов циклов **for**, **while** не удобно при работе в командной строке интерпретатора. В R реализованы функции, оптимизирующее циклически вычисления:\
- **lapply** -- производит циклическое вычисление некоторой функции над элементами списка. - **sapply** -- выполняет то же что **lapply**, только выводит результаты в упрощенном виде. - **apply** -- производит циклическое вычисление некоторой функции над элементами массива. - **tapply** -- производит циклическое вычисление некоторой функции над заданным набором элементов вектора. - **mapply** -- мультивариативная версия функции **lapply** (работает сразу с несколькими объектами).

**lapply** производит циклическое вычисление некоторой функции над элементами списка. **lapply** всегда возвращает объект класса список, несмотря на тип объекта на входе. Если объект на входе не список, то он будет преобразован с помощью функции **as.list**.

**sapply** вариант функции **lapply**, предназначенный для максимального упрощения результатов. Например: 1. Если результат список (list), каждый элемент которого имеет длину 1, то возвращается вектор. 2. Если результат список (list), каждый элемент которого вектор одинаковой длины, то возвращается матрица.\
3. Если результат непонятно как может быть преобразован, то возвращается список.

**apply** используется для вычисления некоторой функции в пределах заданного набора индексов массива. Особенности: 1. В основном применяется для вычисления некоторой функции по строкам или столбцам массива. Работает даже для трехмерных матриц. 2. Используется для массивов любой размерности.

**mapply** -- мультивариативный вариант **lapply** и **sapply**, предназначенный для параллельного применения в цикле некоторой функции к набору R-объектов.

Пример векторизации функции.

```{r}
rnorm (5, 1, 2)
mapply(rnorm, 1:5, 1:5, 2)
```

**tapply** -- используется для расчета некоторой функции в цикле по группам элементов вектора. Это удобно когда один вектор формирует несколько выборок.

## Правила видимости свободных переменных (Scoping rules)

```{r eval=FALSE, include=FALSE}
lm <- function(x) { x * x }
lm
```

Для присвоения **lm** некоторого значения будет осуществляться поиск данной функции в различных областях или пространствах памяти среды – environments. Environment – список или набор R-объектов (по типу символ-значение), которые представляют собой видимое по некоторым правилам пространство памяти. Если работа производится в строке интерпретатора команд, то загружается global environment. В global environment входят все элементы, созданные или загруженные в R. При поиске **lm** порядок просмотра environments 1. global environment 2. пространства, загруженных пакетов (namespaces).

global environment эквивалентно пространству памяти «пользователя». После просмотра global environment поиск осуществляется от пространства памяти пакета stats к пространству пакета base. Порядок следования пакетов важен! **library** -- функция для загрузки пакетов. Загруженный пакет становится на вторую позицию, остальные пакеты смещаются на одну позицию вниз. Scoping rules определяют правила присвоения значений свободным переменным функций. В R используется lexical или static scoping. Наиболее распространенная альтернатива - dynamic scoping. Фактически задача сводится к вопросу: как R просматривает environments, для того чтобы связать свободную переменную с конкретным значением.

```{r}
z <- 1
f <- function(x, y) {
	x^2 + y / z
}
```

Где *z* -- свободная переменная (a free variable). Свободная переменная не является ни формальным аргументом функции, ни локальной переменной функции.

Функции используются для систематизации повторяющегося программного кода. Функция создается с помощью оператора **function** и сохраняется как R-объект класса *function*.

Особенности: 1. Объекты класса function можно передавать в качестве аргумента другой функции. 2. Функции могут быть вложенными, т.е. одна функция может быть определена внутри другой. 3. Возвращаемое значение функции – это результат последнего выражения в коде функции.

Аргументы сопоставляются по позициям в списке или по совпадению имен.

```{r}
mydata <- rnorm(100)
sd(mydata)
sd(x = mydata)
sd(x = mydata, na.rm = FALSE)
sd(na.rm = FALSE, x = mydata)
sd(na.rm = FALSE, mydata)
```

### Сопоставление аргументов

Если передаются именованные аргументы, то их не обязательно располагать в требуемом порядке. Можно смешивать «порядок» и «имена». Именованный аргумент извлекается из списка, остальные будут ассоциированы по позициям оставшихся аргументов в списке.

```{r}
args(lm)
```

Имена аргументов могут совпадать не полностью, а частично. Система сама определяет наиболее подходящий аргумент и присваивает ему значение. Порядок следования операций определения аргументов в функциях: 1) Проверка на точное совпадение именованных аргументов. 2) Проверка на частичное совпадение именованных аргументов. 3) Проверка на точное совпадение позиций неименованных аргументов.

```{r}
f <- function(a, b = 1, c = 2, d = NULL) {
	return(1);
}
```

Аргумент функции в виде "..." используется для передачи стандартных аргументов сторонних функций.

```{r}
myplot <- function(x, y, type = "l", ...) {
	plot(x, y, type = type, ...)
}
```

Аргумент "..." применяется когда число аргументов функции заранее не известно

```{r}
args(paste)
args(cat)
```

Аргументы, идущие после "...", должны быть именованы полностью.

```{r}
args(paste)
paste("a", "b", sep = ":")
paste("a", "b", se = ":")
```

## Scoping rules

**Правило (lexical rules) 1:** Значение для свободной переменной функции определяются в том пространстве памяти (environment), где была создана данная функция. Каждое environment имеет родительское environment. Родитель может иметь несколько потомков. Пространство без родителя называется пустым (empty environment). Функция + ее пространство памяти = closure или function closure. **Правило (lexical rules) 2:** Если значение для свободной переменной функций не найдено в пространстве, где была создана данная функция, то продолжается поиск по линии родительских пространств вплоть до пространства наивысшего уровня top-level environment (global environment или namespace of package). **Правило (lexical rules) 3:** После просмотра пространства наивысшего уровня (top-level environment) поиск осуществляется вниз по списку пространств загруженных пакетов (namespaces).

При достижении пространства последнего пакета (empty environment) в списке и не нахождения значения для свободной переменной выводится сообщение об ошибке.

```{r}
make_power <- function(n) {
	pow <- function(x) {
		x^n
	}
	return(pow)
}
cube <- make_power(3)
square <- make_power(2)
cube(3)
square(3)
```

Для просмотра пространства памяти функции можно воспользоваться функциями **ls**, **environment** и **get**.

```{r}
ls(environment(cube))
get('n', environment(cube))
```

```{r}
y <- 10
f <- function(x) {
	y <- 2
	y^2 + g(x)
}

g <- function(x) {
	x*y
}
```

Достоинства lexical scoping: 1) Не требуется передача длинных списков аргументов в функции. Это значительно упрощает работу пользователя в интерактивном режиме и в ходе исследовательской (exploratory) работы. 2) Сокращает, а значит и упрощает, программный код. 3) Удобно для решения задач оптимизации (**nlm**, **optim** , **optimise**) для управления целевыми функциями, параметры которых обеспечивают корректное решение задачи.

цикл с помощью walk по датасетам или по сгенерированным последовательностям

Recycling rule Some of the preceding statements can be written more concisely. When the operands are of different lengths, the shorter one is recycled as many times as necessary, as in rep(y, length.out=length(x)). For exampl

Упростите выражение c(sqrt(1), sqrt(2), sqrt(3))?

The expression: 4i=1∑n2i−1(−1)i+1=4(11−31+51−71+⋯) slowly converges to π as n approaches ∞. Calculate it for n=1 000 000 and n=1 000 000 000 using the vectorised functions and operators discussed in this chapter, making use of the recycling rule as much as possible

## Ленивые вычисления
