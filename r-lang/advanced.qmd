# Продвинутый R

## Встроенные константы

В R зарезервирован набор специальных констант:

-   **Inf** -- *бесконечность*
-   **NA** -- *Not Available*. Отсутствующее значение. Используется для обозначения пропущенных значений в данных.
-   **NaN** -- *Not A Number*. Определяет неопределенное число или «не число».
-   **NULL** -- представляет нулевой объект. Часто используется когда возвращаема величина выражения или функции не определена.
-   **pi** -- *3.141593*

```{r}
pi/Inf
```

## Атрибуты объектов

Объекты характеризуются атрибутами которые могут быть рассмотрены, как метаданные для объектов. Не все объекты имеют атрибуты. Атрибуты используются для упрощения понимания и описания объектов. Примеры атрибутов объектов:

-   names, dimnames
-   dimensions
-   class
-   length
-   прочие, определенные пользователем, атрибуты (metadata) Для доступа к атрибутам объекта используется функция **attributes**

```{r}
x <- cbind(a = 1:3, pi = pi)
x
attributes(x)
```


## Векторизированные вычисления

Использование операторов циклов **for**, **while** не удобно при работе в командной строке интерпретатора. В R реализованы функции, оптимизирующее циклически вычисления:\
- **lapply** -- производит циклическое вычисление некоторой функции над элементами списка. - **sapply** -- выполняет то же что **lapply**, только выводит результаты в упрощенном виде. - **apply** -- производит циклическое вычисление некоторой функции над элементами массива. - **tapply** -- производит циклическое вычисление некоторой функции над заданным набором элементов вектора. - **mapply** -- мультивариативная версия функции **lapply** (работает сразу с несколькими объектами).

**lapply** производит циклическое вычисление некоторой функции над элементами списка. **lapply** всегда возвращает объект класса список, несмотря на тип объекта на входе. Если объект на входе не список, то он будет преобразован с помощью функции **as.list**.

**sapply** вариант функции **lapply**, предназначенный для максимального упрощения результатов. Например: 1. Если результат список (list), каждый элемент которого имеет длину 1, то возвращается вектор. 2. Если результат список (list), каждый элемент которого вектор одинаковой длины, то возвращается матрица.\
3. Если результат непонятно как может быть преобразован, то возвращается список.

**apply** используется для вычисления некоторой функции в пределах заданного набора индексов массива. Особенности: 1. В основном применяется для вычисления некоторой функции по строкам или столбцам массива. Работает даже для трехмерных матриц. 2. Используется для массивов любой размерности.

**mapply** -- мультивариативный вариант **lapply** и **sapply**, предназначенный для параллельного применения в цикле некоторой функции к набору R-объектов.

Пример векторизации функции.

```{r}
rnorm (5, 1, 2)
mapply(rnorm, 1:5, 1:5, 2)
```

**tapply** -- используется для расчета некоторой функции в цикле по группам элементов вектора. Это удобно когда один вектор формирует несколько выборок.


## Правила видимости свободных переменных (Scoping rules)

```{r eval=FALSE, include=FALSE}
lm <- function(x) { x * x }
lm
```

Для присвоения **lm** некоторого значения будет осуществляться поиск данной функции в различных областях или пространствах памяти среды – environments. Environment – список или набор R-объектов (по типу символ-значение), которые представляют собой видимое по некоторым правилам пространство памяти. Если работа производится в строке интерпретатора команд, то загружается global environment. В global environment входят все элементы, созданные или загруженные в R. При поиске **lm** порядок просмотра environments 1. global environment 2. пространства, загруженных пакетов (namespaces).

global environment эквивалентно пространству памяти «пользователя». После просмотра global environment поиск осуществляется от пространства памяти пакета stats к пространству пакета base. Порядок следования пакетов важен! **library** -- функция для загрузки пакетов. Загруженный пакет становится на вторую позицию, остальные пакеты смещаются на одну позицию вниз. Scoping rules определяют правила присвоения значений свободным переменным функций. В R используется lexical или static scoping. Наиболее распространенная альтернатива - dynamic scoping. Фактически задача сводится к вопросу: как R просматривает environments, для того чтобы связать свободную переменную с конкретным значением.

```{r}
z <- 1
f <- function(x, y) {
	x^2 + y / z
}
```

Где *z* -- свободная переменная (a free variable). Свободная переменная не является ни формальным аргументом функции, ни локальной переменной функции.



## Scoping rules

**Правило (lexical rules) 1:** Значение для свободной переменной функции определяются в том пространстве памяти (environment), где была создана данная функция. Каждое environment имеет родительское environment. Родитель может иметь несколько потомков. Пространство без родителя называется пустым (empty environment). Функция + ее пространство памяти = closure или function closure. **Правило (lexical rules) 2:** Если значение для свободной переменной функций не найдено в пространстве, где была создана данная функция, то продолжается поиск по линии родительских пространств вплоть до пространства наивысшего уровня top-level environment (global environment или namespace of package). **Правило (lexical rules) 3:** После просмотра пространства наивысшего уровня (top-level environment) поиск осуществляется вниз по списку пространств загруженных пакетов (namespaces).

При достижении пространства последнего пакета (empty environment) в списке и не нахождения значения для свободной переменной выводится сообщение об ошибке.

```{r}
make_power <- function(n) {
	pow <- function(x) {
		x^n
	}
	return(pow)
}
cube <- make_power(3)
square <- make_power(2)
cube(3)
square(3)
```

Для просмотра пространства памяти функции можно воспользоваться функциями **ls**, **environment** и **get**.

```{r}
ls(environment(cube))
get("n", environment(cube))
```

```{r}
y <- 10
f <- function(x) {
	y <- 2
	y^2 + g(x)
}

g <- function(x) {
	x*y
}
```

Достоинства lexical scoping: 1) Не требуется передача длинных списков аргументов в функции. Это значительно упрощает работу пользователя в интерактивном режиме и в ходе исследовательской (exploratory) работы. 2) Сокращает, а значит и упрощает, программный код. 3) Удобно для решения задач оптимизации (**nlm**, **optim** , **optimise**) для управления целевыми функциями, параметры которых обеспечивают корректное решение задачи.

цикл с помощью walk по датасетам или по сгенерированным последовательностям

Recycling rule Some of the preceding statements can be written more concisely. When the operands are of different lengths, the shorter one is recycled as many times as necessary, as in rep(y, length.out=length(x)). For exampl

Упростите выражение c(sqrt(1), sqrt(2), sqrt(3))?

The expression: 4i=1∑n2i−1(−1)i+1=4(11−31+51−71+⋯) slowly converges to π as n approaches ∞. Calculate it for n=1 000 000 and n=1 000 000 000 using the vectorised functions and operators discussed in this chapter, making use of the recycling rule as much as possible
