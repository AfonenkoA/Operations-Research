# Приложение R.Б. Решатель LPSolve

Существует два интерфейса для работы с этой библиотекой. Более высокоуровненый **lpSolve** и низкоуровневый **lpSolveAPI**. Рассмотрим оба

## lpSolve

Требуется задать коэффициенты целевой функции. $c(a_1,a_2,a_3,...,a_n)\implies F(\vec{x})=a_1x_1+a_2x_2+a_3x_3+...a_nx_n$.

```{r}
library(lpSolve)
Fun <- c(2, 6)
```

Ограничения задаются в виде матрицы коэффициентов

```{r}
A <- rbind(c(1, 4), c(2, 1), c(0, 1))
```

Правые части и знаки ограничений задаются отдельно

```{r}
B <- c(2048, 2048, 480)
CD <- c('<=', '<=', '<=')
```

Для решения вызываетя процедура **lp**

```{r}
optimum <- lp(
  direction = 'max',
  objective.in = Fun,
  const.mat = A,
  const.dir = CD,
  const.rhs = B,
  compute.sens = TRUE)
optimum
```

Макисмальное значение целевой функции достигается при следующих значениях переменных

```{r}
optimum$solution
```

## lpSolveAPI

Создать объект модели задачи линейного программирования с 2 переменными и 0 ограничений (будут добавлены позднее).

```{r}
library(lpSolveAPI)
lprob <- make.lp(0, 2)
```

Далее выбирается тип оптимизации, в данном случае максимизация. Вывод функции перенаправляется в переменную заглушку, чтобы отменить печать информации на экран.

```{r}
stub <- lp.control(lprob, sense = 'max')
rm(stub)
```

Далее задаются ограничения. Коэффициенты в функция ограничения задаются с помощью $c(a_1,a_2,a_3,...,a_n)\implies a_1x_1+a_2x_2+a_3x_3+...a_nx_n$. По умолчанию на переменные накладывается условие $\forall{i}: x_i\geq0$

```{r}
add.constraint(lprob, c(1, 4), '<=', 2048)
add.constraint(lprob, c(2, 1), '<=', 2048)
add.constraint(lprob, c(0, 1), '<=', 480)
```

Задание целевой функции. Объект модели можно конструировать в произвольном порядке

```{r}
set.objfn(lprob, c(2, 6))
lprob
```

Далее необходимо решить систему

```{r}
status_code <- solve(lprob)
```

Наилучшее значение целевой функции

```{r}
get.objective(lprob)
```

Значение переменных, при которых дистигнуто максимальное значение целевой функции

```{r}
get.variables(lprob)
```

## Анализ чувствительности

Анализ чувствительности применим только к задаче в действительных числах. Исходная целевая функция $F=2x_1+6x_2$. Для анализа чувствительности целевой функции используется функция **get.sensitivity.obj**.

```{r}
get.sensitivity.obj(lprob)
```

Полученные значения означают, что при измениении значения $x_1\in(1.5,12)$ или $x_2\in(1,8)$ точка соовтетствующая лучшему значению целевой функции не изменится.

Для анализа чувствительности ограничений применяется функция **get.sensitivity.rhs**.

```{r}
get.sensitivity.rhs(lprob)
```

Рассмотрим первое ограничение $x_1+4x_2\leq2048$. Значение $\xi_1=1.4285$ показывает насколько изменится целевая функция, если значение ограничения увеличится на одну единицу. Значение $xi$ ненулевое, только если ограничение активно. $\xi$ можно интерпретировать как частную произовдную целевой фунцкии по правой части неравенстра ограничения. $\xi_1=\frac{\partial F}{\partial B_1}$. Следовательно при изменении ограничения $\xi_i$ в пределах от $\xi_{from}$ до $\xi_{till}$ значение целевой функции изменится как $F=F_0+\Delta B_i \xi_i$

Значение $\xi_i$ дает очень хорошее представление о том, сколько стоит это ограничение. Если значение $\xi_i$ большое, то это ограничение сильно влияет на целевую функцию. Небольшие изменения ограничения (ослабление) позволит значительно улучшить значение целевой функции. Также имеет значение знак $\xi_i$. Положительное значение означает, что по мере увеличения ограничения значение целевой функции будет больше, а по мере того, как оно становится более отрицательным, значение целевой функции будет меньше.

Аналогично для **lpSolve** используются следующие функции для анализа коэффициентов целевой функции

```{r}
optimum$sens.coef.from
optimum$sens.coef.to
```

и для анализа ограничений

```{r}
optimum$duals
optimum$duals.from
optimum$duals.to
```
