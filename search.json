[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Исследование операций",
    "section": "",
    "text": "Интерактивный курс по исследованию операций\n\n\n\n\n\n\nСостояние разработки\n\n\n\nВ разработке\n\n\n\n\n\n\n\nОбзор методов и разделов.\nNeos alghorytm guide\nОсновная литература [1]\n\n\n\n\n1. А. Т.Х. Исследование операций. 10-е изд. / под ред. Слепцова А.В. Санкт-Петербург: ООО \"Диалектика\", 2019. С. 1056.",
    "crumbs": [
      "Интерактивный курс по исследованию операций"
    ]
  },
  {
    "objectID": "TODO.html",
    "href": "TODO.html",
    "title": "Замечания",
    "section": "",
    "text": "Приняты",
    "crumbs": [
      "Замечания"
    ]
  },
  {
    "objectID": "TODO.html#приняты",
    "href": "TODO.html#приняты",
    "title": "Замечания",
    "section": "",
    "text": "В первой лабораторной не существует функции inverse, использовать solve\nRScript не добавляется в $PATH по умолчанию на Windows\nНизкое качество .png картинок в лабораторных и проверочных, заменить на соответствующие векторные форматы.\nРисунок с подсказкой в задаче Авиа-билеты и Пилорама\nДобавить больше примеров в раздел векторизации языка R, не только встроенные операторы\nВ первой работе больше примеров оформления отчётов, принципы хорошего стиля интерактивных блокнотов.\nОптимизация размера html страницы. Функция add_region вызывает TeX только при необходимости.",
    "crumbs": [
      "Замечания"
    ]
  },
  {
    "objectID": "TODO.html#в-процессе-решения",
    "href": "TODO.html#в-процессе-решения",
    "title": "Замечания",
    "section": "В процессе решения",
    "text": "В процессе решения",
    "crumbs": [
      "Замечания"
    ]
  },
  {
    "objectID": "TODO.html#решено",
    "href": "TODO.html#решено",
    "title": "Замечания",
    "section": "Решено",
    "text": "Решено",
    "crumbs": [
      "Замечания"
    ]
  },
  {
    "objectID": "TODO.html#технические",
    "href": "TODO.html#технические",
    "title": "Замечания",
    "section": "Технические",
    "text": "Технические\n\nДобавить скрипты активации julia enviroment\nДобавить отладочную версию скриптов подстановки ссылок (печать промежуточных действий на экран)\nenviroment/_example.qmd Форматировать с ограничением строк в 80 символов.\nИспользование векторной графики tikz и asy\nИнтерфейсы к python, julia, octave и haskell\nОграничения и minizinc\nПолностью обобщить подстановку значений в r-tools/lpsolve\nВ r-tools использовать code-link в отдельных блоках кода, а не на весь файл.\nАвтоматическая подстановка соответствующего формата для графики asymptote",
    "crumbs": [
      "Замечания"
    ]
  },
  {
    "objectID": "enviroment/overview.html",
    "href": "enviroment/overview.html",
    "title": "Среда разработки",
    "section": "",
    "text": "Состояние разработки\n\n\n\nВ разработке\n\n\nНабор инструментов позволяет создавать современные отчёты и не только. Здесь пару примеров.",
    "crumbs": [
      "Среда разработки"
    ]
  },
  {
    "objectID": "enviroment/setup.html",
    "href": "enviroment/setup.html",
    "title": "1  Установка и настройка",
    "section": "",
    "text": "1.1 R\nДля установки на другие платформы смотрите https://cloud.r-project.org/",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Установка и настройка</span>"
    ]
  },
  {
    "objectID": "enviroment/setup.html#sec-enviroment-setup-r",
    "href": "enviroment/setup.html#sec-enviroment-setup-r",
    "title": "1  Установка и настройка",
    "section": "",
    "text": "1.1.1 Установка\n\nWindowsArch linux\n\n\nСкачать и установить\nhttps://cran.r-project.org/bin/windows/base/release.html\n\n\n\n\n\n\nСовет\n\n\n\nРекомендуется установить в расположение по умолчанию. Иначе придется настраивать пути в ручную для RStudio или через переменные среды.\n\n\n\n\nhttps://archlinux.org/packages/extra/x86_64/r/\nsudo pacman -S r\n\n\n\n\n\n1.1.2 Дальнейшие действия\nПроверит установку можно вызвав интерпретатор R:\nRscript --version\nполучается следующий вывод\nRscript (R) version 4.4.2 (2024-10-31)",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Установка и настройка</span>"
    ]
  },
  {
    "objectID": "enviroment/setup.html#sec-enviroment-setup-rtools",
    "href": "enviroment/setup.html#sec-enviroment-setup-rtools",
    "title": "1  Установка и настройка",
    "section": "1.2 RTools",
    "text": "1.2 RTools\nВ состав RTools входят компиляторы C, C++, Fortran, библиотеки линейной алгебры LAPAK и BLAS, и другие утилиты необходимые для сборки некоторых пакетов в R. Название RTools специфично для Windows, для других платформ требуется установить отдельные пакеты.\n\n1.2.1 Установка\n\nWindowsArch linux\n\n\nСкачать и установить\nhttps://cran.r-project.org/bin/windows/Rtools/rtools44/rtools.html\n\n\n\n\n\n\nСовет\n\n\n\nРекомендуется установить в расположение по умолчанию. Иначе придется настраивать пути в ручную для RStudio или через переменные среды.\n\n\n\n\nsudo pacman -S blas-openblas gcc-fortran gcc\n\n\n\n\n\n1.2.2 Дальнейшие действия\nДля проверки установки рекмендуется выполнить в командной строке\nRscript -e \"install.packages('lpSolve'); library(lpSolve)\"\nЕсли установка прошла успешно, то команда завершится с кодом 0 (ничего не выведет).",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Установка и настройка</span>"
    ]
  },
  {
    "objectID": "enviroment/setup.html#sec-enviroment-setup-rstudio",
    "href": "enviroment/setup.html#sec-enviroment-setup-rstudio",
    "title": "1  Установка и настройка",
    "section": "1.3 RStudio",
    "text": "1.3 RStudio\n\n1.3.1 Установка\n\nWindowsArch linux\n\n\nСкачать и установить\nhttps://rstudio.org/download/latest/stable/desktop/windows/RStudio-latest.exe\n\n\nyay -S rstudio-desktop-daily-bin\n\n\n\n\n\n1.3.2 Дальнейшие действия\nПосле установки проверить создание проекта Глава 2 .",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Установка и настройка</span>"
    ]
  },
  {
    "objectID": "enviroment/setup.html#sec-enviroment-setup-vscode",
    "href": "enviroment/setup.html#sec-enviroment-setup-vscode",
    "title": "1  Установка и настройка",
    "section": "1.4 VSCode",
    "text": "1.4 VSCode\nДля работы с VSCode требуется установить расширение Quarto.",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Установка и настройка</span>"
    ]
  },
  {
    "objectID": "enviroment/setup.html#sec-enviroment-setup-quarto",
    "href": "enviroment/setup.html#sec-enviroment-setup-quarto",
    "title": "1  Установка и настройка",
    "section": "1.5 Quarto",
    "text": "1.5 Quarto\nДалее приводится отдельная установка, которая подходит если не используется RStudio, например VSCode или Vim. Quarto входит в состав RStudio Глава 1.3 поэтому этот шаг можно пропустить.\n\n1.5.1 Установка\n\nWindowsArch linux\n\n\nСкачать и установить\nhttps://github.com/quarto-dev/quarto-cli/releases/download/v1.6.41/quarto-1.6.41-win.msi\n\n\nyay -S quarto-cli-bin-pre-release\n\n\n\n\n\n1.5.2 Дальнейшие действия\nПосле установки изучите Глава 3 для создания проекта.",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Установка и настройка</span>"
    ]
  },
  {
    "objectID": "enviroment/rstudio.html",
    "href": "enviroment/rstudio.html",
    "title": "2  RStudio IDE",
    "section": "",
    "text": "2.1 Quarto",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>RStudio IDE</span>"
    ]
  },
  {
    "objectID": "enviroment/rstudio.html#sec-enviroment-rstudio-quarto",
    "href": "enviroment/rstudio.html#sec-enviroment-rstudio-quarto",
    "title": "2  RStudio IDE",
    "section": "",
    "text": "2.1.1 Создать новый документ\n\n\n\nМеню создания документа\n\n\n\n\n\nОпции при создании документа\n\n\n\n\n2.1.2 Визуальный редактор\n\n\n\nПример в визуальном редакторе\n\n\n\nФорматирование\n\n\n\nМеню форматирование\n\n\n\n\nЗаголовки\n\n\n\nМеню стиля заголовка\n\n\n\n\nВставка ресурсов\n\n\n\nВставка ресурсов\n\n\n\n\nВставка изображения\n\n\n\nМеню вставки изображения\n\n\n\n\nВставка ссылки\n\n\n\nМеню вставки ссылки\n\n\n\n\nРедактирование таблиц\n\n\n\nМеню редактора таблиц\n\n\n\n\n\n2.1.3 Редактор исходного кода\n\n\n\nРедактор исходного кода",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>RStudio IDE</span>"
    ]
  },
  {
    "objectID": "enviroment/rstudio.html#sec-enviroment-rstudio-shortcuts",
    "href": "enviroment/rstudio.html#sec-enviroment-rstudio-shortcuts",
    "title": "2  RStudio IDE",
    "section": "2.2 Сочетание клавиш",
    "text": "2.2 Сочетание клавиш\nБольшинство сочетаний клавиш работают в visual режиме. Вызов меню интерактивного выбора для вставки конвента Crtl-/Crtl-/\n\n\n2.2.1 Форматирование и написание текста\nВыделив текст к нему можно применить стили\n\n\n\n\n\n\n\nДействие\nСочетание клавиш\n\n\n\n\nЖирный\nCtrl-BCtrl-B\n\n\nКурсив\nCtrl-ICtrl-I\n\n\nКод\nCtrl-DCtrl-D\n\n\nВставить ссылку\nCtrl-KCtrl-K\n\n\nВставить изображение\nCtrl-Shift-ICtrl-Shift-I\n\n\nОтменить действие\nCtrl-ZCtrl-Z\n\n\nПовторить отмененное действие\nCtrl-Shift-ZCtrl-Shift-Z\n\n\nСвернуть все блоки (текст и код)\nAlt-OAlt-O\n\n\nРазвернуть все блоки (текст и код)\nAlt-Shift-OAlt-Shift-O\n\n\n\n\n\n2.2.2 Код\n\n\n\n\n\n\n\nДействие\nСочетание клавиш\n\n\n\n\nВставить блок кода на языке R\nCtrl-Alt-ICtrl-Alt-I\n\n\nПрисваивание на языке R &lt;-\nAlt--Alt--\n\n\nВыполнить блок кода\nCrtl-Shift-EnterCrtl-Shift-Enter, Ctrl-Alt-CCtrl-Alt-C\n\n\nВыполнить предыдущий блок кода\nCrtl-Shift-Alt-PCrtl-Shift-Alt-P\n\n\nВыполнить все предидущие блоки кода\nCtrl-Alt-PCtrl-Alt-P\n\n\nВыполнить следующий блок кода\nCtrl-Alt-NCtrl-Alt-N\n\n\nВыполнить все блоки кода\nCtrl-Alt-RCtrl-Alt-R\n\n\nАвтодополнение кода\nTabTab, Ctrl-SpaceCtrl-Space\n\n\n\n\n\n2.2.3 Рендеринг\nВызов предпросмотра в файлах и проектах Quarto .qmd или конвертации в .Rmd Ctrl-Shift-KCtrl-Shift-K",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>RStudio IDE</span>"
    ]
  },
  {
    "objectID": "enviroment/quarto.html",
    "href": "enviroment/quarto.html",
    "title": "3  Quarto",
    "section": "",
    "text": "3.1 Установка примера\nПри использовании из командной строки без IDE.\nЕсли пакет tidyverse устанавливается с ошибками см. Глава 16.1 пункт renv",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "enviroment/quarto.html#sec-enviroment-quarto-example-install",
    "href": "enviroment/quarto.html#sec-enviroment-quarto-example-install",
    "title": "3  Quarto",
    "section": "",
    "text": "---\ntitle: \"Пример блокнота Quarto\"\nformat: html\neditor: visual\n---\n\n```{r}\n#| label: load-packages\n#| include: false\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\n```\n\n## Quarto\n\nQuarto позволяет объединить содержимое и исполняемый код в готовый документ. Узнать больше о Quarto можно на сайте &lt;https://quarto.org&gt;.\n\n## Пингвины\n\n![](https://raw.githubusercontent.com/quarto-dev/quarto-web/main/docs/get-started/hello/rstudio/lter_penguins.png){style=\"float:right;\" fig-alt=\"Иллюстрация трех видов пингвинов архипелага Палмера: Chinstrap, Gentoo и Adelie. Автор иллюстрации - @allison_horst.\" width=\"401\"}\n\nДатасет `penguins` из пакета [**palmerpenguins**](https://allisonhorst.github.io/palmerpenguins%20«palmerpenguins%20R%20package») содержат измерения размеров `{r} nrow(penguins)` пингвинов трех видов, наблюдавшихся на трех островах архипелага Палмера, Антарктида.\n\nНа графике ниже показана зависимость между длиной ласт и клюва у этих пингвинов.\n\n```{r}\n#| label: plot-penguins\n#| warning: false\n#| echo: false\n\nggplot(penguins, \n       aes(x = flipper_length_mm, y = bill_length_mm)) +\n  geom_point(aes(color = species, shape = species)) +\n  scale_color_manual(values = c(\"darkorange\",\"purple\",\"cyan4\")) +\n  labs(\n    title = \"Длина ласт и клюва\",\n    subtitle = \"Размеры для пингвинов на станции Палмер LTER\",\n    x = \"Длина ласт (мм)\", y = \"Длина клюва (mm)\",\n    color = \"Вид пингвина\", shape = \"Вид пигвина\"\n  ) +\n  theme_minimal()\n```\n\n```{.markdown}\n  \n```\n\nСохранить код приведённый выше код в файл (например example.qmd)\nВызвав интерактивный сеанс R установить пакеты\n\ninstall.packages(\"ggplot2\")\ninstall.packages(\"palmerpenguins\")",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "enviroment/quarto.html#sec-enviroment-quarto-render",
    "href": "enviroment/quarto.html#sec-enviroment-quarto-render",
    "title": "3  Quarto",
    "section": "\n3.2 Render",
    "text": "3.2 Render\nПри рендеринге Quarto генерирует новый файл, содержащий выделенный текст, код и результаты из файла .qmd. Новый файл может представлять собой документ HTML, PDF, MS Word и другие форматы. По умолчанию Quarto рендерит в HTML . Например:\nquarto render example.qmd\nРезультат выполнения команды\nprocessing file: example.qmd\n1/5                \n2/5 [load-packages]\n3/5                \n4/5 [plot-penguins]\n5/5                \noutput file: example.knit.md\n\npandoc \n  to: html\n  output-file: example.html\n  standalone: true\n  section-divs: true\n  html-math-method: mathjax\n  wrap: none\n  default-image-extension: png\n  \nmetadata\n  document-css: false\n  link-citations: true\n  date-format: long\n  lang: en\n  title: Пример блокнота Quarto\n  editor: visual\n  \nOutput created: example.html\nexample.html представляет собой Рисунок 3.1",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "enviroment/quarto.html#sec-enviroment-quarto-preview",
    "href": "enviroment/quarto.html#sec-enviroment-quarto-preview",
    "title": "3  Quarto",
    "section": "\n3.3 Preview",
    "text": "3.3 Preview\nРендеринг и предварительный просмотр документа или проекта веб-сайта. Автоматически перезагружает браузер при изменении входных файлов или ресурсов документа. При предварительном просмотре для рендеринга используются самые последние результаты выполнения вычислительных документов.\nquarto preview example.qmd\nРезультат выполнения команды примерно такой:\nprocessing file: example.qmd\n1/5                \n2/5 [load-packages]\n3/5                \n4/5 [plot-penguins]\n5/5                \noutput file: example.knit.md\n\npandoc \n  to: html\n  output-file: example.html\n  standalone: true\n  section-divs: true\n  html-math-method: mathjax\n  wrap: none\n  default-image-extension: png\n  \nmetadata\n  document-css: false\n  link-citations: true\n  date-format: long\n  lang: en\n  title: Пример блокнота Quarto\n  editor: visual\n  \nOutput created: example.html\n\nWatching files for changes\nBrowse at http://localhost:7980/\nВ браузере отобразится следующая страничка\n\n\n\n\n\nРисунок 3.1: Пример preview в html",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "enviroment/markdown.html",
    "href": "enviroment/markdown.html",
    "title": "4  Язык разметки Markdown",
    "section": "",
    "text": "4.1 Блоки кода\nдиаграмма обработки markdown\nРабочие блокноты Quarto основаны на проекте Pandoc и используют язык разметки Мarkdown.\nMarkdown — это простой текстовый формат, который легко писать и, что еще более важно, легко читать:\nРассмотрим наиболее часто встречаемые примитивы разметки\nQuarto позволяет объединить исполняемый код и сопутствующее описание в готовый документ. Чтобы узнать больше о Quarto, посетите https://quarto.org. Блоки кода, которые используют фигурные скобки вокруг имени языка (например, ```{r}), являются исполняемыми и будут запущены Quarto во время рендеринга\nВ результате получим следующее. Рисунок 4.1 более подробно изучает влияние температуры на уровень озона.\nlibrary(ggplot2)\n\nggplot(airquality, aes(Temp, Ozone)) + \n  geom_point() + \n  geom_smooth(method = \"loess\")\n\n\n\n\n\n\nРисунок 4.1: Температура и уровень озона.\nИз исполняемых блоков кода можно создавать самые разные типы выходных данных, включая графики, таблицы и простой текст.",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Язык разметки Markdown</span>"
    ]
  },
  {
    "objectID": "enviroment/markdown.html#sec-markdown-codeblocks",
    "href": "enviroment/markdown.html#sec-markdown-codeblocks",
    "title": "4  Язык разметки Markdown",
    "section": "",
    "text": "## Качество воздуха\n\n@fig-airquality более подробно изучает влияние температуры на уровень озона.\n\n```{r}\n#| label: fig-airquality\n#| fig-cap: \"Температура и уровень озона.\"\n#| warning: false\n\nlibrary(ggplot2)\n\nggplot(airquality, aes(Temp, Ozone)) + \n  geom_point() + \n  geom_smooth(method = \"loess\")\n```\n\n\n\n\n4.1.1 Встраиваемый код\nВстраиваемый (Inline) код позволяет вам выполнять код в markdown, например, для автоматического использования самых последних вычислений в повествовании. Синтаксис встроенного кода похож на блоки кода, за исключением того, что используеся один тик (`) вместо тройных тиков (```). Встраиваемый код может использоваться в середине markdown. Например, следующий код сохраняет переменную radius в блоке кода, а затем обращается к ней в предложении с помощью встроенного кода:\n```{r}\nradius &lt;- 5\n```\n\nThe radius of the circle is `{r} radius`\nВ результате получаем:\nThe radius of the circle is 5.\n\n\n\n\n\n\nОсторожность\n\n\n\nВстроенные выражения должны быть ограничены простыми значениями, которые предварительно вычисляются в обычных ячейках кода (а не вызовами функций, которые выполняют нетривиальную работу). Это связано с тем, что протокол, используемый для встроенных выражений, несовместим с библиотеками, использующими многопоточность.\n\n\n\n4.1.2 Разные языки в одном документе\nДвижки рендеринга Knitr и Jupyter позволяют совмещать вычисления на разных языках в одном документе. Например:\n\n```{r}\n#| cache: true\nplot(pressure, pch=21, col='blue', bg='lightblue')\n```\n\n\n\n\n\n\n\n\n```{python}\n#| warning: false\n#| message: false\n#| error: false\n#| cache: true\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Data for plotting\nt = np.arange(0.0, 2.0, 0.01)\ns = 1 + np.sin(2 * np.pi * t)\n\nfig, ax = plt.subplots()\nax.plot(t, s)\n\nax.set(xlabel='time (s)', ylabel='voltage (mV)',\n       title='About as simple as it gets, folks')\nax.grid()\n\nfig.savefig(\"test.png\")\nplt.show()\n```\n\n\n\n\n\n\n\n\n```{julia}\n#| warning: false\n#| message: false\n#| error: false\n#| cache: true\n\nusing Plots\nx = range(0, 10, length=100);\ny1 = sin.(x);\ny2 = cos.(x);\nplot(x, [y1 y2])\n```\n\n\n\n\n\n\n\n\n4.1.3 Рендеринг и сохранение\nПри рендеринге документа Quarto блоки кода выполняются автоматически. Прямо над документом находится панель инструментов, содержащая различные параметры, включая Render (сегментированная синяя стрелка). По умолчанию документ qmd конвертируется в html.\n\n4.1.4 Опции блоков кода\nЗадать название блока можно с помощь параметра label:\n```{r}\n#| label: convert\nairquality$TempC &lt;- (5 / 9) * (airquality$Temp - 32)\n```\nПараметр echo: false отключает печать кода (отображается только вывод).\n``` r\nlibrary(tidyverse)\nlibrary(palmerpenguins)\npenguins |&gt;\n  mutate(\n    bill_ratio = bill_depth_mm / bill_length_mm,\n    bill_area  = bill_depth_mm * bill_length_mm\n  )\n```\n\nLine 3  \nTake `penguins`, and then,\n\nLines 4-7  \nadd new columns for the bill ratio and bill area.\n\n4.1.5 Параметры вывода\nСуществует широкий спектр опций для настройки вывода из выполненного кода. Все эти опции могут быть указаны либо глобально, либо для каждого блока кода. Например, вот модификация примера R, указывающая, что мы не хотим “отражать” код в выходном документе:\n---\ntitle: \"My Document\"\nexecute:\n  echo: false\n---\nПараметр echo может быть переопределен для конкретно блока кода. Например:\n```{r}\n#| echo: true\n\nplot(cars)\n```\nПараметры блока кода включены в специальный комментарий в верхней части блока (строки в верхней части, начинающиеся с #|, считаются параметрами).\nНаиболее распространенные параметры приведены далее:\n\n\n\n\n\n\nOption\nDescription\n\n\n\neval\nВычислить блок (если false, то блок кода просто дублируется в вывод).\n\n\necho\nВключить исходный код в вывод\n\n\noutput\n\nВключить результаты выполнения кода в выходные данные (true, false)\nasis, чтобы указать, что выходные данные представляют собой markdown и не должны содержать расширений Quarto).\n\n\n\nwarning\nВключать предупреждения в вывод\n\n\nerror\nВключать ошибки в вывод (это подразумевает, что ошибки выполнения кода не остановят обработку документа).\n\n\n\nПример Knitr с некоторыми из этих дополнительных параметров:\n---\ntitle: \"Knitr Document\"\nexecute:\n  echo: false\n---\n\n```{r}\n#| warning: false\n\nlibrary(ggplot2)\nggplot(airquality, aes(Temp, Ozone)) + \n  geom_point() + \n  geom_smooth(method = \"loess\", se = FALSE)\n```\n\n```{r}\nsummary(airquality)\n```\n\n4.1.6 Названия рисунков\nМожно указать подпись и замещающий текст для рисунков, сгенерированных из кода, используя параметры fig-cap и fig-alt. Например, здесь эти параметры добавляются в ячейку кода которая создает график:\n\n```{python}\n#| fig-cap: \"График в полярных координатах\"\n#| fig-alt: \"График линии в полярных координатах\"\n#| cache: true\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\nfig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\nax.plot(theta, r)\nax.set_rticks([0.5, 1, 1.5, 2])\nax.grid(True)\nplt.show()\n```\n\n\n\nГрафик в полярных координатах",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Язык разметки Markdown</span>"
    ]
  },
  {
    "objectID": "enviroment/markdown.html#sec-markdown-text-editing",
    "href": "enviroment/markdown.html#sec-markdown-text-editing",
    "title": "4  Язык разметки Markdown",
    "section": "\n4.2 Форматирование текста",
    "text": "4.2 Форматирование текста\n\n\n\n\n\n\nЯзык разметки Markdown\nРезультат\n\n\n\n*курсив*, **жирный**, ***жирный курсив***\n\nкурсив, жирный, жирный курсив\n\n\n\nверхний индекс^2^ / subscript~2~\nверхний индекс2 / нижний индекс2\n\n\n\n~~зачёркнутый~~\nзачёркутый",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Язык разметки Markdown</span>"
    ]
  },
  {
    "objectID": "enviroment/markdown.html#sec-markdown-headers",
    "href": "enviroment/markdown.html#sec-markdown-headers",
    "title": "4  Язык разметки Markdown",
    "section": "\n4.3 Заголовки",
    "text": "4.3 Заголовки\n\nЗаголовки\n\n\n\n\n\nЯзык разметки Markdown\nРезультат\n\n\n\n## Заголовок 2\n\n4.4 Заголовок 2\n\n\n### Заголовок 3\n\n4.4.1 Заголовок 3\n\n\n#### Заголовок 4\nЗаголовок 4\n\n\n##### Заголовок 5\nЗаголовок 5\n\n\n###### Заголовок 6\nЗаголовок 6",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Язык разметки Markdown</span>"
    ]
  },
  {
    "objectID": "enviroment/markdown.html#sec-markdown-link-and-image",
    "href": "enviroment/markdown.html#sec-markdown-link-and-image",
    "title": "4  Язык разметки Markdown",
    "section": "\n4.5 Ссылки и Изображения",
    "text": "4.5 Ссылки и Изображения\n\n\nЯзык разметки Markdown\nРезультат\n\n\n\n&lt;https://rct.bsu.by&gt;\nhttps://rct.bsu.by\n\n\n[Название](https://rct.bsu.by)\nНаш факультет\n\n\n![Название](rctbsu.png)\n\n\nНаш факультет\n\n\n\n\n[![Название](rctbsu.png)](https://rct.bsu.by)\nКартинка становится кликабельной при рендеринге",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Язык разметки Markdown</span>"
    ]
  },
  {
    "objectID": "enviroment/markdown.html#sec-markdown-crossref",
    "href": "enviroment/markdown.html#sec-markdown-crossref",
    "title": "4  Язык разметки Markdown",
    "section": "\n4.6 Перекрестные ссылки",
    "text": "4.6 Перекрестные ссылки\nПерекрестные ссылки на рисунки создаются, добавлением к ним идентификатора с префиксом fig-, а затем ссылаясь на рисунок с помощью префикса @. Например:\n![Грач](rctbsu.png){#fig-grach}\n\nКак показано на рисунке @fig-grach.\nДля рисунков, созданных блоками исполняемого кода, используется label с префиксом fig-, чтобы сделать их перекрестно-ссылочными. Например:\nДля демонстрации графика линии используется @fig-cars-plot.\n\n```{r}\n#| label: fig-cars-plot\n#| fig-cap: \"Cars plot \"\n\nplot(cars)\n```\nДля демонстрации графика линии используется Рисунок 4.2.\n\n```{r}\n#| label: fig-cars-plot\n#| fig-cap: \"Cars plot \"\n#| cache: true\n\nplot(cars)\n```\n\n\n\n\n\n\nРисунок 4.2: Cars plot\n\n\n\n\n\n4.6.1 Размещение и подзаголовки рисунков\nПодзаголовки для вычисляемых рисунков задаются с использованием опций fig-cap и fig-subcap. Если использовать параметр label с префиксом fig- то рисунок будет пронумерован и [перекрестно-ссылаемым].\n```{r}\n#| label: fig-charts\n#| fig-cap: \"Charts\"\n#| fig-subcap: \n#|   - \"Cars\"\n#|   - \"Pressure\"\n#| layout-ncol: 2\n#| cache: true\n\nplot(cars)\nplot(pressure)\n```\n\n\n\n\n\n\n\n\n\n(a) Cars\n\n\n\n\n\n\n\n\n\n(b) Pressure\n\n\n\n\n\n\nРисунок 4.3: Charts\n\n\n\n\n\n\n\n\nУведомление\n\n\n\nРисунки будут размещены в две колонки только при конвертации в html",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Язык разметки Markdown</span>"
    ]
  },
  {
    "objectID": "enviroment/markdown.html#sec-markdonw-list",
    "href": "enviroment/markdown.html#sec-markdonw-list",
    "title": "4  Язык разметки Markdown",
    "section": "\n4.7 Списки",
    "text": "4.7 Списки\n\n\n\n\n\n\nЯзык разметки Markdown\nOutput\n\n\n\n* маркированный список\n    + пункт 1\n    + пункт 2\n        - подпункт 1\n\nмаркированный список\n\nпункт 1\nпункт 2\n\nподпункт 1\n\n\n\n\n\n\n\n1. нумерованный список\n2. пункт 2\n    i) подпункт 1\n         A.  вложение 1\n\nordered list\nitem 2\n\nsub-item 1\n\nsub-sub-item 1\n\n\n\n\n\n\n\n- [ ] Задача 1\n- [x] Задача 2\n\nЗадача 1\nЗадача 2\n\n\n\n(@)  Сквозная нумерация списка\n\nпродолжается после\n\n(@)  прерывания\n\n\nСквозная нумерация списка\n\nпродолжается после\n\nпрерывания\n\n\n\n\nтермин\n: его определение\n\nтермин\n\nего определение\n\n\n\n\n\n\n4.7.1 Блочное размещение\nНапример, например мы можем разместить 2 списка рядом:\n::: {layout-ncol=2}\n### List One\n\n- Item A\n- Item B\n- Item C\n\n### List Two\n\n- Item X\n- Item Y\n- Item Z\n:::\n\n\nПервый список\n\nЭлемент A\nЭлемент B\nЭлемент C\nВторой список\n\nЭлемент X\nЭлемент Y\nЭлемент Z\n\n\n\n\n\n\n\n\n\nУведомление\n\n\n\nСписки будут размещены в две колонки только при конвертации в html",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Язык разметки Markdown</span>"
    ]
  },
  {
    "objectID": "enviroment/markdown.html#sec-markdown-tables",
    "href": "enviroment/markdown.html#sec-markdown-tables",
    "title": "4  Язык разметки Markdown",
    "section": "\n4.8 Таблицы",
    "text": "4.8 Таблицы\n\n4.8.1 Простые таблицы\nВ обычных таблицах могут содержаться только элементы представленные простым текстом.\nРазметка Markdown\nВыравнивание по\n| Правому краю | Левому краю | Умолчанию | Центру |\n|-------------:|:------------|-----------|:------:|\n|           12 | 12          | 12        |   12   |\n|          123 | 123         | 123       |  123   |\n|            1 | 1           | 1         |   1    |\nРезультат\nВыравнивание по\n\n\nПравому краю\nЛевому краю\nУмолчанию\nЦентру\n\n\n\n12\n12\n12\n12\n\n\n123\n123\n123\n123\n\n\n1\n1\n1\n1\n\n\n\n4.8.2 Расширенные таблицы\nРасширенные таблицы (grid tables) — это более продвинутый тип таблиц разметки, которые допускают произвольные блочные элементы (несколько абзацев, блоков кода, списков и т. д.). Например: строка =s отделяет заголовок от тела таблицы и может быть опущена для таблицы без заголовка. Ячейки таблиц сетки могут содержать произвольные блочные элементы (несколько абзацев, блоков кода, списков и т. д.)\nВыравнивания можно указывать так же, как и в случае с таблицами конвейера, помещая двоеточия на границах разделительной линии после заголовка.\nРазметка Markdown\n+-----------+-----------+--------------------+\n| Fruit     | Price     | Advantages         |\n+===========+===========+====================+\n| Bananas   | $1.34     | - built-in wrapper |\n|           |           | - bright color     |\n+-----------+-----------+--------------------+\n| Oranges   | $2.10     | - cures scurvy     |\n|           |           | - tasty            |\n+-----------+-----------+--------------------+\n\n: Пример расширенной таблицы\nРезультат\n\nПример расширенной таблицы\n\n\n\n\n\n\nFruit\nPrice\nAdvantages\n\n\n\nBananas\n$1.34\n\nbuilt-in wrapper\nbright color\n\n\n\nOranges\n$2.10\n\ncures scurvy\ntasty",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Язык разметки Markdown</span>"
    ]
  },
  {
    "objectID": "enviroment/markdown.html#sec-markdown-equations",
    "href": "enviroment/markdown.html#sec-markdown-equations",
    "title": "4  Язык разметки Markdown",
    "section": "\n4.9 Формулы",
    "text": "4.9 Формулы\nДля вставки формулы в текст используется $. Для выделения отдельным блоком используется $$. Например:\n\nФормулы\n\n\n\n\n\nЯзык разметки Markdown\nРезультат\n\n\n\nформула в тексте: $E = mc^{2}$\nформула в тексте: \\(E=mc^{2}\\)\n\n\n\nотдельный блок формул:\n\n$$E = mc^{2}$$\n\nотдельный блок формул:\n\\[E = mc^{2}\\]\n\n\n\n\nВыражения записываются на языке LaTeX, подробнее Глава 5",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Язык разметки Markdown</span>"
    ]
  },
  {
    "objectID": "enviroment/markdown.html#sec-markdown-diagram",
    "href": "enviroment/markdown.html#sec-markdown-diagram",
    "title": "4  Язык разметки Markdown",
    "section": "\n4.10 Диаграммы",
    "text": "4.10 Диаграммы\nQuarto имеет встроенную поддержку для диаграмм Mermaid и Graphviz. Mermaid – это инструмент для создания диаграмм и графиков на основе Javascript, который использует определения текста, вдохновленные Markdown, и рендерер для создания и изменения сложных диаграмм.\n\n```{mermaid}\nflowchart LR\n  A[Hard edge] --&gt; B(Round edge)\n  B --&gt; C{Decision}\n  C --&gt; D[Result one]\n  C --&gt; E[Result two]\n```\n\n\n\n\nflowchart LR\n  A[Hard edge] --&gt; B(Round edge)\n  B --&gt; C{Decision}\n  C --&gt; D[Result one]\n  C --&gt; E[Result two]",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Язык разметки Markdown</span>"
    ]
  },
  {
    "objectID": "enviroment/markdown.html#sec-markdown-quote",
    "href": "enviroment/markdown.html#sec-markdown-quote",
    "title": "4  Язык разметки Markdown",
    "section": "\n4.11 Цитаты",
    "text": "4.11 Цитаты\n &gt; Blockquote\n\nЭто короткая цитата",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Язык разметки Markdown</span>"
    ]
  },
  {
    "objectID": "enviroment/markdown.html#sec-markdown-special-symbols",
    "href": "enviroment/markdown.html#sec-markdown-special-symbols",
    "title": "4  Язык разметки Markdown",
    "section": "\n4.12 Специальные символы",
    "text": "4.12 Специальные символы\n\n\n\n\n\n\nMarkdown Syntax\nOutput\n\n\n\nendash: --\nendash: –\n\n\nemdash: ---\nemdash: —\n\n\n\n\n\n\n\n\n\nУведомление\n\n\n\nСимволы подставляются только при конвертации в html",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Язык разметки Markdown</span>"
    ]
  },
  {
    "objectID": "enviroment/latex.html",
    "href": "enviroment/latex.html",
    "title": "5  Язык разметки LaTeX",
    "section": "",
    "text": "5.1 Греческие буквы\nДля оформления уравнений и формул в рабочих блокнотах Quarto используется общепринятый стандарт разметки математических выражений LaTeX.\n[1] [2]",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Язык разметки LaTeX</span>"
    ]
  },
  {
    "objectID": "enviroment/latex.html#sec-latex-greek-letters",
    "href": "enviroment/latex.html#sec-latex-greek-letters",
    "title": "5  Язык разметки LaTeX",
    "section": "",
    "text": "Таблица 5.1: Греческие символы\n\n\n\n\n\n\n\n\n\n\n\n\n\nСтрочная\n\nПрописная\n\nАльтернативная\n\n\n\n\n\n$\\alpha$\n\\(\\alpha\\)\n$A$\n\\(A\\)\n\n\n\n\n$\\beta$\n\\(\\beta\\)\n$B$\n\\(B\\)\n\n\n\n\n$\\gamma$\n\\(\\gamma\\)\n$\\Gamma$\n\\(\\Gamma\\)\n\n\n\n\n$\\delta$\n\\(\\delta\\)\n$\\Delta$\n\\(\\Delta\\)\n\n\n\n\n$\\epsilon$\n\\(\\epsilon\\)\n$E$\n\\(E\\)\n$\\varepsilon$\n\\(\\varepsilon\\)\n\n\n$\\zeta$\n\\(\\zeta\\)\n$Z$\n\\(Z\\)\n\n\n\n\n$\\eta$\n\\(\\eta\\)\n$H$\n\\(H\\)\n\n\n\n\n$\\theta$\n\\(\\theta\\)\n$\\Theta$\n\\(\\Theta\\)\n$\\vartheta$\n\\(\\vartheta\\)\n\n\n$\\zeta$\n\\(\\zeta\\)\n$Z$\n\\(Z\\)\n\n\n\n\n$\\kappa$\n\\(\\kappa\\)\n$K$\n\\(K\\)\n$\\varkappa$\n\\(\\varkappa\\)\n\n\n$\\lambda$\n\\(\\lambda\\)\n$Lambda$\n\\(\\Lambda\\)\n\n\n\n\n$\\mu$\n\\(\\mu\\)\n$M$\n\\(M\\)\n\n\n\n\n$\\nu$\n\\(\\nu\\)\n$N$\n\\(N\\)\n\n\n\n\n$\\xi$\n\\(\\xi\\)\n$\\Xi$\n\\(\\Xi\\)\n\n\n\n\n$\\omicron$\n\\(\\omicron\\)\n$O$\n\\(O\\)\n\n\n\n\n$\\pi$\n\\(\\pi\\)\n$\\Pi$\n\\(\\Pi\\)\n$\\varpi$\n\\(\\varpi\\)\n\n\n$\\rho$\n\\(\\rho\\)\n$P$\n\\(P\\)\n$\\varrho$\n\\(\\varrho\\)\n\n\n$\\sigma$\n\\(\\sigma\\)\n$\\Sigma$\n\\(\\Sigma\\)\n$\\varsigma$\n\\(\\varsigma\\)\n\n\n$\\tau$\n\\(\\tau\\)\n$T$\n\\(T\\)\n\n\n\n\n$\\upsilon$\n\\(\\upsilon\\)\n$\\Upsilon$\n\\(\\Upsilon\\)\n\n\n\n\n$\\phi$\n\\(\\phi\\)\n$\\Phi$\n\\(\\Phi\\)\n$\\varphi$\n\\(\\varphi\\)\n\n\n$\\chi$\n\\(\\chi\\)\n$X$\n\\(X\\)\n\n\n\n\n$\\psi$\n\\(\\psi\\)\n$\\Psi$\n\\(\\Psi\\)\n\n\n\n\n$\\omega$\n\\(\\omega\\)\n$\\Omega$\n\\(\\Omega\\)",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Язык разметки LaTeX</span>"
    ]
  },
  {
    "objectID": "enviroment/latex.html#sec-latex-other-symbols",
    "href": "enviroment/latex.html#sec-latex-other-symbols",
    "title": "5  Язык разметки LaTeX",
    "section": "5.2 Прочие символы",
    "text": "5.2 Прочие символы\n\n\n\nТаблица 5.2: Прочие символы\n\n\n\n\n\n\n\n\n\n\n\n$\\infty$\n\\(\\infty\\)\n$\\forall$\n\\(\\forall\\)\n\n\n$\\Re$\n\\(\\Re\\)\n$\\Im$\n\\(\\Im\\)\n\n\n$\\nabla$\n\\(\\nabla\\)\n$\\exists$\n\\(\\exists\\)\n\n\n$\\partial$\n\\(\\partial\\)\n$\\nexists$\n\\(\\nexists\\)\n\n\n$\\emptyset$\n\\(\\emptyset\\)\n$\\varnothing$\n\\(\\varnothing\\)\n\n\n$\\wp$\n\\(\\wp\\)\n$\\complement$\n\\(\\complement\\)\n\n\n$\\neg$\n\\(\\neg\\)\n$\\cdots$\n\\(\\cdots\\)\n\n\n$\\square$\n\\(\\square\\)\n$\\surd$\n\\(\\surd\\)\n\n\n$\\blacksquare$\n\\(\\blacksquare\\)\n$\\triangle$\n\\(\\triangle\\)",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Язык разметки LaTeX</span>"
    ]
  },
  {
    "objectID": "enviroment/latex.html#sec-latex-arrows",
    "href": "enviroment/latex.html#sec-latex-arrows",
    "title": "5  Язык разметки LaTeX",
    "section": "5.3 Стрелки",
    "text": "5.3 Стрелки\n\n\n\nТаблица 5.3: Стрелки\n\n\n\n\n\n\n\n\n\n\n\n$\\leftarrow$\n\\(\\leftarrow\\)\n$\\Leftarrow$\n\\(\\Leftarrow\\)\n\n\n$\\rightarrow$\n\\(\\rightarrow\\)\n$\\rightarrow$\n\\(\\Rightarrow\\)\n\n\n$\\leftrightarrow$\n\\(\\leftrightarrow\\)\n$\\rightleftharpoons$\n\\(\\rightleftharpoons\\)\n\n\n$\\uparrow$\n\\(\\uparrow\\)\n$\\downarrow$\n\\(\\downarrow\\)\n\n\n$\\Uparrow$\n\\(\\Uparrow\\)\n$\\Downarrow$\n\\(\\Downarrow\\)\n\n\n$\\Leftrightarrow$\n\\(\\Leftrightarrow\\)\n$\\Updownarrow$\n\\(\\Updownarrow\\)\n\n\n$\\mapsto$\n\\(\\mapsto\\)\n$\\longmapsto$\n\\(\\longmapsto\\)\n\n\n$\\nearrow$\n\\(\\nearrow\\)\n$\\searrow$\n\\(\\searrow\\)\n\n\n$\\swarrow$\n\\(\\swarrow\\)\n$\\nwarrow$\n\\(\\nwarrow\\)\n\n\n$\\leftharpoonup$\n\\(\\leftharpoonup\\)\n$\\rightharpoonup$\n\\(\\rightharpoonup\\)\n\n\n$\\leftharpoondown$\n\\(\\leftharpoondown\\)\n$\\rightharpoondown$\n\\(\\rightharpoondown\\)",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Язык разметки LaTeX</span>"
    ]
  },
  {
    "objectID": "enviroment/latex.html#sec-latex-operators",
    "href": "enviroment/latex.html#sec-latex-operators",
    "title": "5  Язык разметки LaTeX",
    "section": "5.4 Бинарные операторы и символы отношения",
    "text": "5.4 Бинарные операторы и символы отношения\n\n\n\nТаблица 5.4: Операторы\n\n\n\n\n\n\n\n\n\n\n\n$\\times$\n\\(\\times\\)\n$\\cdot$\n\\(\\cdot\\)\n\n\n$\\div$\n\\(\\div\\)\n$\\cap$\n\\(\\cap\\)\n\n\n$\\cup$\n\\(\\cup\\)\n$\\neq$\n\\(\\neq\\)\n\n\n$\\leq$\n\\(\\leq\\)\n$\\geq$\n\\(\\geq\\)\n\n\n$\\in$\n\\(\\in\\)\n$\\perp$\n\\(\\perp\\)\n\n\n$\\notin$\n\\(\\notin\\)\n$\\subset$\n\\(\\subset\\)\n\n\n$\\simeq$\n\\(\\simeq\\)\n$\\approx$\n\\(\\approx\\)\n\n\n$\\wedge$\n\\(\\wedge\\)\n$\\vee$\n\\(\\vee\\)\n\n\n$\\oplus$\n\\(\\oplus\\)\n$\\otimes$\n\\(\\otimes\\)\n\n\n$\\Box$\n\\(\\Box\\)\n$\\boxtimes$\n\\(\\boxtimes\\)\n\n\n$\\equiv$\n\\(\\equiv\\)\n$\\cong$\n\\(\\cong\\)",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Язык разметки LaTeX</span>"
    ]
  },
  {
    "objectID": "enviroment/latex.html#sec-latex-functions",
    "href": "enviroment/latex.html#sec-latex-functions",
    "title": "5  Язык разметки LaTeX",
    "section": "5.5 Выделяемые функции",
    "text": "5.5 Выделяемые функции\n\n\n\nТаблица 5.5: Функции\n\n\n\n\n\n\n\n\n\nLaTeX\nРезультат\n\n\n\n\n$\\cos{x}$\n\\[\n\\cos{x}\n\\]\n\n\n$\\sin{x}$\n\\[\n\\sin{x}\n\\]\n\n\n$\\csc{x}$\n\\[\n\\csc{x}\n\\]\n\n\n$\\exp{x}$\n\\[\n\\exp\n\\biggl(\\,\n\\sum_{n=1}^{10}\n\\frac{1}{n}\n\\biggr)\n\\]\n\n\n$\\min_{sub} expr$\n\\[\n\\min_{\\forall s \\in S_j} q_k(s)\n\\]\n\n\n$\\gcd$\n\\[\n\\gcd{144,12}\n\\]\n\n\n$\\log_b n$\n\\[\nA(n) \\in\n\\Theta(n^{\\log_b a}) =\n\\Theta(n^{\\log_2 2} ) =\n\\Theta(n)\n\\]\n\n\n$\\sup_i f$\n\\[\n\\sup_{x&gt;0}f(x)\n\\]",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Язык разметки LaTeX</span>"
    ]
  },
  {
    "objectID": "enviroment/latex.html#скобки",
    "href": "enviroment/latex.html#скобки",
    "title": "5  Язык разметки LaTeX",
    "section": "5.6 Скобки",
    "text": "5.6 Скобки\n\n\n\nТаблица 5.6: Скобки\n\n\n\n\n\n\n\n\n\n\nТип\nLaTeX\nРезультат\n\n\n\n\nКруглые скобки\n$(x+y)$\n\\((x+y)\\)\n\n\nКвадратные скобки\n$[x+y]$\n\\([x+y]\\)\n\n\nФигурные скобки\n$\\{x+y\\}$\n\\(\\{x+y\\}\\)\n\n\nУгловые скобки\n$\\langle x+y \\rangle$\n\\(\\langle x+y \\rangle\\)\n\n\nВертикальные черты\n$|x+y|$\n\\(|x+y|\\)\n\n\nДвойные вертикальные черты\n$\\|x+y\\|$\n\\(\\|x+y\\|\\)\n\n\nБольшие круглые левые скобки\n$\\big( \\Big( \\bigg( \\Bigg($\n\\(\\big( \\Big( \\bigg( \\Bigg(\\)\n\n\nБольшие круглые правые скобки\n$\\big) \\Big) \\bigg) \\Bigg)$\n\\(\\big) \\Big) \\bigg) \\Bigg)\\)\n\n\nБольшие квадратные левые скобки\n$\\big[ \\Big[ \\bigg[ \\Bigg[$\n\\(\\big[ \\Big[ \\bigg[ \\Bigg[\\)\n\n\nБольшие квадратные правые скобки\n$\\big] \\Big] \\bigg] \\Bigg]$\n\\(\\big] \\Big] \\bigg] \\Bigg]\\)\n\n\nБольшие фигурные левые скобки\n$\\big\\{ \\Big\\{ \\bigg\\{ \\Bigg\\{$\n\\(\\big\\{ \\Big\\{ \\bigg\\{ \\Bigg\\{\\)\n\n\nБольшие фигурные правые скобки\n$\\big\\} \\Big\\} \\bigg\\} \\Bigg\\}$\n\\(\\bigl\\} \\Big\\} \\bigg\\} \\Bigg\\}\\)",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Язык разметки LaTeX</span>"
    ]
  },
  {
    "objectID": "enviroment/latex.html#sec-latex-matrix",
    "href": "enviroment/latex.html#sec-latex-matrix",
    "title": "5  Язык разметки LaTeX",
    "section": "5.7 Матрицы",
    "text": "5.7 Матрицы\n\n\n\nТаблица 5.7: Матрицы\n\n\n\n\n\n\n\n\n\n\nТип\nLaTeX\nРезультат\n\n\n\n\nОбычная\n$$\n\\begin{matrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n7 & 8 & 9\n\\end{matrix}\n$$\n\\[\n\\begin{matrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n7 & 8 & 9\n\\end{matrix}\n\\]\n\n\nКвадратные скобки\n$$ M =\n\\begin{bmatrix}\n\\frac{5}{6} & \\frac{1}{6} & 0 \\\\\n\\frac{5}{6} & 0 & \\frac{1}{6} \\\\\n0 & \\frac{5}{6} & \\frac{1}{6}\n\\end{bmatrix}\n$$\n\\[ M =\n\\begin{bmatrix}\n\\frac{5}{6} & \\frac{1}{6} & 0 \\\\\n\\frac{5}{6} & 0 & \\frac{1}{6} \\\\\n0 & \\frac{5}{6} & \\frac{1}{6}\n\\end{bmatrix}\n\\]\n\n\nВыражение\n$$\nM =\n\\begin{bmatrix}\n1 & 0 \\\\\n0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 0 \\\\\n0 & 1\n\\end{bmatrix}\n$$\n\\[\nM =\n\\begin{bmatrix}\n1 & 0 \\\\\n0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 0 \\\\\n0 & 1\n\\end{bmatrix}\n\\]\n\n\nКруглые скобки\n$$\nM =\n\\begin{pmatrix}\n1 & 0 \\\\\n0 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\n1 & 0 \\\\\n0 & 1\n\\end{pmatrix}\n$$\n\\[\nM =\n\\begin{pmatrix}\n1 & 0 \\\\\n0 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\n1 & 0 \\\\\n0 & 1\n\\end{pmatrix}\n\\]\n\n\nОбщий вид\n$$\nA_{m,n} =\n\\begin{pmatrix}\na_{1,1} & a_{1,2} & \\cdots & a_{1,n} \\\\\na_{2,1} & a_{2,2} & \\cdots & a_{2,n} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{m,1} & a_{m,2} & \\cdots & a_{m,n}\n\\end{pmatrix}\n$$\n\\[\nA_{m,n} =\n\\begin{pmatrix}\na_{1,1} & a_{1,2} & \\cdots & a_{1,n} \\\\\na_{2,1} & a_{2,2} & \\cdots & a_{2,n} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{m,1} & a_{m,2} & \\cdots & a_{m,n}\n\\end{pmatrix}\n\\]",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Язык разметки LaTeX</span>"
    ]
  },
  {
    "objectID": "enviroment/latex.html#sec-latex-big-operators",
    "href": "enviroment/latex.html#sec-latex-big-operators",
    "title": "5  Язык разметки LaTeX",
    "section": "5.8 Большие операторы",
    "text": "5.8 Большие операторы\n\n\n\nТаблица 5.8: Большие операторы\n\n\n\n\n\n\n\n\n\n$a_{n_i}$\n\\(a_{n_i}\\)\n\n\n$\\int_{i=1}^n$\n\\(\\int_{i=1}^n\\)\n\n\n$\\sum{i=1}^{\\infty}$\n\\(\\sum{i=1}^{\\infty}\\)\n\n\n$\\prod_{i=1}^n$\n\\(\\prod_{i=1}^n\\)\n\n\n$\\cup_{i=1}^n$\n\\(\\cup_{i=1}^n\\)\n\n\n$\\cap_{i=1}^n$\n\\(\\cap_{i=1}^n\\)\n\n\n$\\oint_{i=1}^n$\n\\(\\oint_{i=1}^n\\)\n\n\n$\\coprod_{i=1}^n$\n\\(\\coprod_{i=1}^n\\)",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Язык разметки LaTeX</span>"
    ]
  },
  {
    "objectID": "enviroment/latex.html#sec-latex-examples",
    "href": "enviroment/latex.html#sec-latex-examples",
    "title": "5  Язык разметки LaTeX",
    "section": "5.9 Примеры",
    "text": "5.9 Примеры\n\n\n\nТаблица 5.9: Примеры\n\n\n\n\n\n\n\n\n\nLaTeX\nРезультат\n\n\n\n\n$$\nx^{2 \\alpha} - 1 = y_{ij} + y_{ij}\n$$\n\\[\nx^{2 \\alpha} - 1 = y_{ij} + y_{ij}\n\\]\n\n\n$$\n(a^n)^{r+s} = a^{nr+ns}\n$$\n\\[\n(a^n)^{r+s} = a^{nr+ns}\n\\]\n\n\n$$\n\\sum_{i=1}^{\\infty}\n\\frac{1}{n^s} =\n\\prod_p \\frac{1}{1 - p^{-s}}\n$$\n\\[\n\\sum_{i=1}^{\\infty}\n\\frac{1}{n^s} =\n\\prod_p \\frac{1}{1 - p^{-s}}\n\\]\n\n\n$$\nx^2  +\nx\\left( {a + b} \\right) +\nab =\n\\left( {x + a} \\right)\n\\left( {x + b} \\right)\n$$\n\\[\nx^2  +\nx\\left( {a + b} \\right) +\nab =\n\\left( {x + a} \\right)\n\\left( {x + b} \\right)\n\\]\n\n\n$$\n\\log _b \\left( x \\right) =\n\\log _b \\left( c \\right)\\log _c \\left( x \\right) =\n\\frac{{\\log _c \\left( x \\right)}}\n{{\\log _c \\left( b \\right)}}\n$$\n\\[\n\\log _b \\left( x \\right) =\n\\log _b \\left( c \\right)\\log _c \\left( x \\right) =\n\\frac{{\\log _c \\left( x \\right)}}\n{{\\log _c \\left( b \\right)}}\n\\]\n\n\n$$\n\\frac{d}{{dx}}b^x  =\nb^x \\ln \\left( b \\right)\n$$\n\\[\n\\frac{d}{{dx}}b^x  =\nb^x \\ln \\left( b \\right)\n\\]\n\n\n$$\n\\int {\\sec (ax)} dx =\n\\frac{1}{a}\\ln \\left|\n{\\tan \\left( {\\frac{{ax}}{2} +\n\\frac{\\pi }{4}} \\right)} \\right| + c\n$$\n\\[\n\\int {\\sec (ax)} dx =\n\\frac{1}{a}\\ln \\left|\n{\\tan \\left( {\\frac{{ax}}{2} +\n\\frac{\\pi }{4}} \\right)} \\right| + c\n\\]\n\n\n$$\n\\oint_S {E_n dA =\n\\frac{1}{{\\varepsilon _0 }}} Q_{inside}\n$$\n\\[\n\\oint_S {E_n dA =\n\\frac{1}{{\\varepsilon _0 }}} Q_{inside}\n\\]\n\n\n$$\ny(x,t) = \\sum\\limits_n\n{A_n \\cos (\\omega _n t + \\delta _n )\n\\sin (k_n x)}\n$$\n\\[\ny(x,t) = \\sum\\limits_n\n{A_n \\cos (\\omega _n t + \\delta _n )\n\\sin (k_n x)}\n\\]\n\n\n\n\n\n\n\n\n\n\n1. Learn LaTeX in 30 minutes [Электронный ресурс]. URL: https://www.overleaf.com/learn/latex/Learn_LaTeX_in_30_minutes (дата обращения: 20.02.2025).\n\n\n2. Equation Sheet [Электронный ресурс]. URL: http://www.equationsheet.com/ (дата обращения: 20.02.2025).",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Язык разметки LaTeX</span>"
    ]
  },
  {
    "objectID": "r-lang/overview.html",
    "href": "r-lang/overview.html",
    "title": "Язык программирования R",
    "section": "",
    "text": "Состояние разработки\n\n\n\nТребуется доработка\n\n\nR - это язык программирования и программная среда для статистического анализа, графического представления и создания отчетов. R был создан Россом Ихакой и Робертом Джентльменом в Оклендском университете (Новая Зеландия) и в настоящее время разрабатывается командой R Development Core Team.\nВ основе R лежит интерпретируемый компьютерный язык, позволяющий выполнять ветвления и циклы, а также модульное программирование с использованием функций. Для повышения эффективности R позволяет интегрировать его с процедурами, написанными на языках C, C++, .Net, Python или FORTRAN.\nR находится в свободном доступе под лицензией GNU General Public License, а предварительно скомпилированные бинарные версии предоставляются для различных операционных систем, таких как Linux, Windows и Mac.\nR - свободное программное обеспечение, распространяемое под лицензией GNU copyleft.\nОбщая характеристика языка",
    "crumbs": [
      "Язык программирования R"
    ]
  },
  {
    "objectID": "r-lang/basic.html",
    "href": "r-lang/basic.html",
    "title": "6  Основы R",
    "section": "",
    "text": "6.1 Переменные\n[1]\n[2]\nПравильное имя переменной состоит из букв, цифр и символов точки или подчеркивания. Имя переменной начинается с буквы или точки, за которыми не следует число.\nvar_1 = 'Изучаем R'           \nvar_2 &lt;- c('learn','R')   \n'Изучаем R' -&gt; var_3\nТак как R интерпретируемый язык переменные можно удалять с помощью функции rm(). После удаления обращение по имени var_1 генерирует предупреждение.\nrm(var_1)\nvar_1\n\nError: object 'var_1' not found",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "r-lang/basic.html#sec-r-lang-basic-variables-naming",
    "href": "r-lang/basic.html#sec-r-lang-basic-variables-naming",
    "title": "6  Основы R",
    "section": "",
    "text": "Правила именования переменных\n\n\n\n\n\n\nИмя переменной\nДопустимость\nОбъяснение\n\n\n\nvar_name2.\nда\nСостоит из букв, цифр, точки и знака подчеркивания\n\n\nvar_name%\nнет\nЕсть символ ‘%’. Допускаются только точка(.) и знак подчеркивания.\n\n\n2var_name\nнет\nНачинается с цифры\n\n\n\n.var_name, var.name\n\nда\nМожет начинаться с точки(.), но за точкой(.) не должна следовать цифра.\n\n\n.2var_name\nнет\nЗа начальной точкой следует цифра\n\n\n_var_name\nнет\nНачинается с _, что недопустимо\n\n\n\n\n\n\n\n\n\nВажное уведомление\n\n\n\nРекомендуется не использовать точку в имени переменной\n\n\n\n\n\n\n\n\n\nВажное уведомление\n\n\n\nРекомендуется использовать оператор &lt;-.",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "r-lang/basic.html#sec-r-lang-basic-data-types",
    "href": "r-lang/basic.html#sec-r-lang-basic-data-types",
    "title": "6  Основы R",
    "section": "\n6.2 Типы данных",
    "text": "6.2 Типы данных\nВ отличие от других языков программирования, таких как C и java, в R переменные не объявляются как некоторый тип данных. Переменным присваиваются R-объекты, и тип данных R-объекта становится типом данных переменной. Существует множество типов R-объектов. Наиболее часто используемые из них:\n\nВектор 6.3\nСписок 6.4\nМатрица 6.5\nМассивы 6.6\nТаблицы 6.7\n\nВсе объекты в R строятся на основе интерфейса вектор. Два основных типа которые реализуют этот интерфейс: list() и vector() остальные R-объекты строятся на основе этих типов. Существует шесть типов typeof() данных атомарных векторов.\n\n\nТаблица 6.1: Базовые типы данных\n\n\n\n\n\n\n\n\nТип данных\nПример\nПроверка\n\n\n\nЛогический\n\nTRUE, FALSE\n\n\ntypeof(TRUE)\nlogical\n\n\n\nДействительный\n\n12.3, 5, 999\n\n\ntypeof(7.5)\ndouble\n\n\n\nЦелочисленный\n\n2L, 34L, 0L\n\n\ntypeof(2L)\ninteger\n\n\n\nКомплексный\n3+2i\n\ntypeof(2+5i)\ncomplex\n\n\n\nСимвольный\n\n'a', 'good','TRUE'\n\n\ntypeof('TRUE')\ncharacter\n\n\n\nRaw\n\n'Hello' is stored as 48 65 6c 6c 6f\n\n\ntypeof(charToRaw('Hello'))\nraw",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "r-lang/basic.html#sec-r-lang-basic-vector",
    "href": "r-lang/basic.html#sec-r-lang-basic-vector",
    "title": "6  Основы R",
    "section": "\n6.3 Вектор",
    "text": "6.3 Вектор\nВсе данные в языке R векторные. Даже если определить численный литерал его внутреннее представление будет вектором.\n\nis.vector(1)\n\n[1] TRUE\n\n\n\n6.3.1 Последовательности\nДля объединения элементов в вектор используется функция c() – combine. При комбинации элементов различных типов общий тип выводится по правилам (ссылка).\n\na &lt;- c(1,2,3)\na\n\n[1] 1 2 3\n\n\nДля задания целочисленных последовательностей могут использоваться например оператор двоеточия 1:5,\n\nnumbers &lt;- 1:10\nnumbers\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nили функции seq()\n\nseq(5, 9, by = 0.4)\n\n [1] 5.0 5.4 5.8 6.2 6.6 7.0 7.4 7.8 8.2 8.6 9.0\n\n\nПовторить элементы вектора можно с помощью функции rep()\n\nrep(c(1,2,3), each = 3)\n\n[1] 1 1 1 2 2 2 3 3 3\n\nrep(c(1,2,3), times = 3)\n\n[1] 1 2 3 1 2 3 1 2 3\n\n\nДлина вектора получается функцией length()\n\nv &lt;- 1:5\nlength(v)\n\n[1] 5\n\n\n\n6.3.2 Доступ к элементам\nОператор [\n\nОператор объект того же класса что и объект-оригинал. Может быть выделено более 1 элемента!\n\nx &lt;- 1:5\nx[1]\n\n[1] 1\n\nx[2:5]\n\n[1] 2 3 4 5\n\n\nЛогическая индексация\n\nx[x &gt; 2]\n\n[1] 3 4 5\n\n\nТакже можно изменять элементы вектора таким же образом\n\nx[1:2] &lt;- c(6,7)\nx\n\n[1] 6 7 3 4 5\n\n\nОператор [[\n\nМожет быть выделен только 1 элемент!\n\nx &lt;- 1:5\nx[[2]]\n\n[1] 2\n\nx[[3:5]]\n\nError in x[[3:5]]: attempt to select more than one element in vectorIndex",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "r-lang/basic.html#sec-r-lang-basic-list",
    "href": "r-lang/basic.html#sec-r-lang-basic-list",
    "title": "6  Основы R",
    "section": "\n6.4 Список",
    "text": "6.4 Список\nСписки - это объекты R, которые содержат элементы различных типов, такие как числа, строки, векторы и другие списки внутри них. Список также может содержать матрицу или функцию в качестве своих элементов. Список создается с помощью функции list(). Ниже приведен пример создания списка, содержащего строки, числа, векторы и логические значения.\n\nlist_data &lt;- list('Red', 'Green', c(21,32,11), TRUE, 51.23, 119.1)\nlist_data\n\n[[1]]\n[1] \"Red\"\n\n[[2]]\n[1] \"Green\"\n\n[[3]]\n[1] 21 32 11\n\n[[4]]\n[1] TRUE\n\n[[5]]\n[1] 51.23\n\n[[6]]\n[1] 119.1\n\n\nСписок совмещает в себе свойства списка и словаря из других языков программирования. Поэтому элементам мы можем задавать имена.\n\n6.4.1 Доступ к элементам\nОператор [\n\nПозволяет выбрать один или несколько элементов по индексу. Всегда возвращает тип списка\n\nx &lt;- list(foo = 1:4, bar = 0.6)\nx[1]\n\n$foo\n[1] 1 2 3 4\n\n\nОператор [[\n\nПозволяет выбрать один элемент по индексу. Возвращает тип содержащегося элемента.\n\nx &lt;- list(foo = 1:4, bar = 0.6)\nx[[1]]\n\n[1] 1 2 3 4\n\n\nили по имени\n\nx &lt;- list(foo = 1:4, bar = 0.6)\nx[['bar']]\n\n[1] 0.6\n\n\nОператор [[ может принимать последовательность целых чисел и рекурсивно извлекать элементы из вложенного списка\n\nx &lt;- list(a = list(10, 12, 14), b = c(3.14, 2.81))\nx[[c(1, 3)]]\n\n[1] 14\n\nx[[1]][[3]]\n\n[1] 14\n\nx[[c(2, 1)]]\n\n[1] 3.14\n\n\nОператор $\n\n$ работает только с именами объектов.\n\nx &lt;- list(foo = 1:4, bar = 0.6)\nx$foo\n\n[1] 1 2 3 4",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "r-lang/basic.html#sec-r-lang-basic-matrix",
    "href": "r-lang/basic.html#sec-r-lang-basic-matrix",
    "title": "6  Основы R",
    "section": "\n6.5 Матрицы",
    "text": "6.5 Матрицы\nМатрица – это специальный тип вектора в R, который имеет атрибут dim. dim – это вектор типа integer, состоящий из 2 элементов ( nrow - число строк и ncol - число столбцов). Матрицы заполняются по правилу: сверху вниз слева направо.\n\nm &lt;- matrix(c(1, 2, 3, 4), ncol = 2, nrow = 2)\nm\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\ndim(m)\n\n[1] 2 2\n\nattributes(m)\n\n$dim\n[1] 2 2\n\n\nМатрицы можно создавать с помощью функций cbind и rbind.\n\nx &lt;- 1:3\ny &lt;- 10:12\ncbind(x, y)\n\n     x  y\n[1,] 1 10\n[2,] 2 11\n[3,] 3 12\n\n\narray(data,dim) – функция для создания матрицы заданного размера.\n\narray(1:8,c(2,2,2))\n\n, , 1\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n, , 2\n\n     [,1] [,2]\n[1,]    5    7\n[2,]    6    8\n\n\n\n6.5.1 Доступ к элементам\nДоступ к элементам матриц осуществляется с использованием индексов в квадратных скобках – ‘[’. Первый индекс – номер строки, второй индекс – номер столбца.\n\nx &lt;- matrix(1:6, 2, 3)\nx[1, 2]\n\n[1] 3\n\nx[2, 1]\n\n[1] 2\n\n\nПервый или второй индекс может отсутствовать. Тогда будет возвращена строка или столбец матрицы.\n\nx[1, ]\n\n[1] 1 3 5\n\nx[, 2]\n\n[1] 3 4\n\n\nПо умолчанию возвращается вектор единичной длины того же класса что и исходный объект. Для получения объекта в виде матрицы необходимо установить параметр drop. Учет размерности данных – drop = FALSE.\n\nx &lt;- matrix(1:6, 2, 3)\nx[1, 2, drop = FALSE]\n\n     [,1]\n[1,]    3\n\nx &lt;- matrix(1:6, 2, 3)\nx[1, ]\n\n[1] 1 3 5\n\nx[1, , drop = FALSE]\n\n     [,1] [,2] [,3]\n[1,]    1    3    5",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "r-lang/basic.html#sec-r-lang-basic-array",
    "href": "r-lang/basic.html#sec-r-lang-basic-array",
    "title": "6  Основы R",
    "section": "\n6.6 Массивы",
    "text": "6.6 Массивы\n\n6.6.1 Доступ к элементам",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "r-lang/basic.html#sec-r-lang-basic-table",
    "href": "r-lang/basic.html#sec-r-lang-basic-table",
    "title": "6  Основы R",
    "section": "\n6.7 Таблицы",
    "text": "6.7 Таблицы\nТаблица (Data Frame)– специальный тип списка, в котором каждый элемент имеет фиксированную длину. Используется для хранения табулированных данных. Каждая колонка может представлять различные типы данных, включая факторы. Data Frame имеют специализированный атрибут row.names, указывающий имена строк. Это помогает упростить аннотацию данных. Для создания Data Frame из табулированных данных используются функции read.table и read.csv. Для создания матрицы из Data Frame используется функция data.matrix. data.frame – функция для создания Data Frame.\n\nx &lt;- data.frame(foo = 1:4, bar = c(T, T, F, F))\nnrow(x)\n\n[1] 4\n\nncol(x)\n\n[1] 2",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "r-lang/basic.html#sec-r-lang-basic-cast",
    "href": "r-lang/basic.html#sec-r-lang-basic-cast",
    "title": "6  Основы R",
    "section": "\n6.8 Преобразование объектов",
    "text": "6.8 Преобразование объектов\nДля преобразования объекта к другому типу используются функции семейства as.*\n\nas.logical(c(-1, 0, 1))\n\n[1]  TRUE FALSE  TRUE\n\nas.numeric(c(TRUE, FALSE))\n\n[1] 1 0\n\nas.character(c(TRUE, FALSE))\n\n[1] \"TRUE\"  \"FALSE\"",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "r-lang/basic.html#sec-r-lang-basic-vectorization",
    "href": "r-lang/basic.html#sec-r-lang-basic-vectorization",
    "title": "6  Основы R",
    "section": "\n6.9 Векторные операции",
    "text": "6.9 Векторные операции\nВ R можно осуществлять операции над векторами. Это позволяет значительно упростить программный код, не программировать циклы, ускорить процесс написания программ.\n\n6.9.1 Арифметические операторы\n\n\nТаблица 6.2: Векторные арифметические операции\n\n\n\n\n\n\n\n\nОператор\nОписание\nПример\n\n\n\n+\nПоэлементное сложение двух векторов\n\nv &lt;- c(2, 5.5,6)\nt &lt;- c(8, 3, 4)\nv+t\n[1] 10.0  8.5  10.0\n\n\n\n-\nПоэлементное вычитание второго вектора из первого\n\nv &lt;- c( 2,5.5,6)\nt &lt;- c(8, 3, 4)\nv - t\n[1] -6.0  2.5  2.0\n\n\n\n*\nПоэлементное умножение двух векторов\n\nv &lt;- c( 2,5.5,6)\nt &lt;- c(8, 3, 4)\nv * t\n[1] 16.0 16.5 24.0\n\n\n\n/\nПоэлементно делит второй вектор на первый\n\nv &lt;- c( 2,5.5,6)\nt &lt;- c(8, 3, 4)\nv / t\n[1] 0.250000 1.833333 1.500000\n\n\n\n%%\nОстаток от поэлементного деления\n\nv &lt;- c(2, 5.5,6)\nt &lt;- c(8, 3, 4)\nv %% t\n[1] 2.0 2.5 2.0\n\n\n\n%/%\nЦелочисленное поэлементное деление\n\nv &lt;- c( 2,5.5,6)\nt &lt;- c(8, 3, 4)\nv %/% t\n[1] 0 1 1\n\n\n\n^\nПоэлементное возведение в степень\n\nv &lt;- c( 2,5.5,6)\nt &lt;- c(8, 3, 4)\nv ^ t\n[1]  256.000  166.375 1296.000\n\n\n\n\n\n\n\nАналогично векторные операции осуществляются над матрицами.\n\nx &lt;- matrix(1:4, 2, 2);\ny &lt;- matrix(rep(10, 4), 2, 2)\nx * y # поэлементно\n\n     [,1] [,2]\n[1,]   10   30\n[2,]   20   40\n\nx / y\n\n     [,1] [,2]\n[1,]  0.1  0.3\n[2,]  0.2  0.4\n\n\nОператор %*% используется для матричное перемножение по правилам линейной алгебры.\n\nx %*% y\n\n     [,1] [,2]\n[1,]   40   40\n[2,]   60   60\n\n\n\n6.9.2 Операторы сравнения\nВ следующей таблице приведены операторы сравнения, поддерживаемые языком R. Каждый элемент первого вектора сравнивается с соответствующим элементом второго вектора. Результатом сравнения является булево значение.\n\n\nТаблица 6.3: Векторные операторы сравнения\n\n\n\n\n\n\n\n\nОператор\nОписание\nПример\n\n\n\n&gt;\nПроверяет, что каждый элемент первого вектора больше соответствующего элемента второго вектора.\n\nv &lt;- c(2,5.5,6,9)\nt &lt;- c(8,2.5,14,9)\nv &gt; t\n[1] FALSE  TRUE FALSE FALSE\n\n\n\n&lt;\nПроверяет, не меньше ли каждый элемент первого вектора соответствующего элемента второго вектора.\n\nv &lt;- c(2,5.5,6,9)\nt &lt;- c(8,2.5,14,9)\nv &lt; t\n[1]  TRUE FALSE  TRUE FALSE\n\n\n\n==\nПроверяет, равен ли каждый элемент первого вектора соответствующему элементу второго вектора.\n\nv &lt;- c(2,5.5,6,9)\nt &lt;- c(8,2.5,14,9)\nv == t\n[1] FALSE FALSE FALSE  TRUE\n\n\n\n&lt;=\nПроверяет, меньше или равен ли каждый элемент первого вектора соответствующему элементу второго вектора.\n\nv &lt;- c(2,5.5,6,9)\nt &lt;- c(8,2.5,14,9)\nv &lt;= t\n[1]  TRUE FALSE  TRUE  TRUE\n\n\n\n&gt;=\nПроверяет, больше или равен ли каждый элемент первого вектора соответствующему элементу второго вектора.\n\nv &lt;- c(2,5.5,6,9)\nt &lt;- c(8,2.5,14,9)\nv &gt;= t\n[1] FALSE  TRUE FALSE  TRUE\n\n\n\n!=\nПроверяет, не равен ли каждый элемент первого вектора соответствующему элементу второго вектора.\n\nv &lt;- c(2,5.5,6,9)\nt &lt;- c(8,2.5,14,9)\nv != t\n[1]  TRUE  TRUE  TRUE FALSE\n\n\n\n\n\n\n\n\n6.9.3 Логические\nВ следующей таблице приведены логические операторы, поддерживаемые языком R. Они применимы только к векторам типа logical(), numeric() или complex(). Все числа больше 1 считаются логическим значением TRUE.\nКаждый элемент первого вектора сравнивается с соответствующим элементом второго вектора. Результатом сравнения является булево значение.\n\n\nТаблица 6.4: Векторные логические операторы\n\n\n\n\n\n\n\n\nОператор\nОписание\nПример\n\n\n\n&\n\nЛогический оператор И (Element-wise Logical AND).\nОн объединяет каждый элемент первого вектора с соответствующим элементом второго вектора и выдает на выходе TRUE, если оба элемента TRUE.\n\n\nv &lt;- c(3,1,TRUE,2+3i)\nt &lt;- c(4,1,FALSE,2+3i)\nv&t\n[1]  TRUE  TRUE FALSE  TRUE\n\n\n\n|\n\nЛогическое ИЛИ по элементам.\nОн объединяет каждый элемент первого вектора с соответствующим элементом второго вектора и выдает на выходе TRUE, если один из элементов равен TRUE.\n\n\nv &lt;- c(3,0,TRUE,2+2i)\nt &lt;- c(4,0,FALSE,2+3i)\nv|t\n[1]  TRUE FALSE  TRUE  TRUE\n\n\n\n!\nЛогический оператор NOT. Берет каждый элемент вектора и выдает противоположное логическое значение.\n\nv &lt;- c(3,0,TRUE,2+2i)\n!v\n[1] FALSE  TRUE FALSE FALSE\n\n\n\n\n\n\n\nЛогические операторы && и || учитывают только первый элемент векторов и выдают на выходе вектор из одного элемента.\n\n\nТаблица 6.5: Скалярные векторные операторы\n\n\n\n\n\n\n\n\nОператор\nОписание\nПример\n\n\n\n&&\nОператор логического И. Берет первый элемент обоих векторов и выдает значение TRUE, только если оба элемента TRUE.\n\nv &lt;- c(3,0,TRUE,2+2i)\nt &lt;- c(1,3,TRUE,2+3i)\nv&&t\n[1] TRUE\n\n\n\n||\nОператор логического ИЛИ. Берет первый элемент обоих векторов и выдает TRUE, если один из них TRUE.\n\nv &lt;- c(0,0,TRUE,2+2i)\nt &lt;- c(0,3,TRUE,2+3i)\nv||t\nT[1] FALSE",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "r-lang/basic.html#sec-r-lang-basic-branching",
    "href": "r-lang/basic.html#sec-r-lang-basic-branching",
    "title": "6  Основы R",
    "section": "\n6.10 Ветвление",
    "text": "6.10 Ветвление\n\n6.10.1 Оператор if\n\nОператор if состоит из булева выражения, за которым следует один или несколько операторов. Синтаксис оператора выглядит следующим образом\nif(boolean_expression) {\n   # Инструкции будут выполненны, если значение выражения TRUE\n}\nЕсли булево выражение равно true, то будет выполнен блок кода внутри оператора if. Если булево выражение равно false, то будет выполнен первый набор кода после конца оператора if (после закрывающей фигурной скобки).\n\n6.10.2 Оператор else\n\nif(boolean_expression) {\n   # Инструкции будут выполненны, если значение выражения TRUE\n} else {\n   # Инструкции будут выполненны, если значение выражения FALSE\n}\nЕсли булево выражение оценивается как истина, то будет выполнен блок кода if, в противном случае будет выполнен блок кода else.\n\nx &lt;- c('what','is','truth')\n\nif('Truth' %in% x) {\n   'Truth is found'\n} else {\n   'Truth is not found'\n}\n\n[1] \"Truth is not found\"\n\n\nЗа оператором if может следовать необязательный оператор else if...else, что очень удобно для проверки различных условий с помощью одного оператора if...else if\nif(boolean_expression_1) {\n   # Выполняется, если выражение 1 TRUE\n} else if( boolean_expression_2) {\n   # Выполняется, если выражение 2 TRUE\n} else if( boolean_expression_3) {\n   # Выполняется, если выражение 3 TRUE\n} else {\n   # Выполняется если все выражения FALSE\n}\nНапример\n\nx &lt;- c('what','is','truth')\n\nif('Truth' %in% x) {\n   'Truth is found the first time'\n} else if ('truth' %in% x) {\n   'truth is found the second time'\n} else {\n   'No truth found'\n}\n\n[1] \"truth is found the second time\"\n\n\n\n6.10.3 Функция switch\n\nОператор switch() позволяет проверить переменную на равенство со списком значений. Каждое значение называется случаем, и переменная, которая включается, проверяется для каждого случая. Оператор записывается следующим образом:\nswitch(expression, case1, case2, case3, ....)\nК оператору switch применяются следующие правила.\n\nЕсли значение выражения не является символьной строкой, оно приводится к целому числу.\nВнутри switch может быть любое количество операторов case. За каждым case следует значение, с которым нужно сравнить, и двоеточие.\nЕсли значение целого числа находится между 1 и nargs()-1 (максимальное количество аргументов), то соответствующий элемент условия case оценивается и возвращается результат.\nЕсли выражение оценивается как символьная строка, то эта строка сопоставляется (в точности) с именами элементов.\nЕсли имеется более одного совпадения, возвращается первый совпавший элемент.\nАргумент Default недоступен.\nВ случае отсутствия совпадения, если существует неименованный элемент …, возвращается его значение. (Если таких аргументов более одного, возвращается ошибка).\n\nПример индексации\n\nswitch(1, 'one', 'two')\n\n[1] \"one\"\n\n\nИндексация с составными именованными выражениями\n\nswitch(1, foo={'one'}, bar={'two'}) \n\n[1] \"one\"\n\n\nПо имени с составными именованными выражениями\n\nswitch('bar', foo={'one'}, bar={'two'})\n\n[1] \"two\"",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "r-lang/basic.html#sec-r-lang-basic-cylce",
    "href": "r-lang/basic.html#sec-r-lang-basic-cylce",
    "title": "6  Основы R",
    "section": "\n6.11 Циклы",
    "text": "6.11 Циклы\nОператор цикла позволяет выполнить оператор или группу операторов несколько раз.\n\n6.11.1 Типы циклов\nЦикл for\n\nЦикл for используется когда количество итераций известно до начала цикла.\nfor (value in vector) {\n   statements\n}\nЦиклы for в R особенно гибки, поскольку не ограничиваются целыми числами или даже числами на входе. Цикл может быть применен к символьным векторам, логическим векторам, спискам или выражениям.\n\nv &lt;- LETTERS[1:4]\nfor ( i in v) {\n   print(i)\n}\n\n[1] \"A\"\n[1] \"B\"\n[1] \"C\"\n[1] \"D\"\n\n\nЦикл while\n\nЦикл while выполняет один и тот же код снова и снова, пока не будет выполнено условие остановки.\nwhile (test_expression) {\n   statement\n}\nКлючевым моментом цикла while является то, что цикл может никогда не выполняться. Когда условие будет проверено и результат окажется ложным, тело цикла будет пропущено, и будет выполнен первый оператор после цикла while.\n\nv &lt;- c('Hello','while loop')\ncnt &lt;- 2\n\nwhile (cnt &lt; 7) {\n   print(v)\n   cnt &lt;- cnt + 1\n}\n\n[1] \"Hello\"      \"while loop\"\n[1] \"Hello\"      \"while loop\"\n[1] \"Hello\"      \"while loop\"\n[1] \"Hello\"      \"while loop\"\n[1] \"Hello\"      \"while loop\"\n\n\nЦикл repeat\n\nЦикл repeat выполняет один и тот же код снова и снова, пока не будет выполнено условие остановки.\nrepeat { \n   commands \n   if(condition) {\n      break\n   }\n}\nПример\n\nv &lt;- c('Hello','loop')\ncnt &lt;- 2\n\nrepeat {\n   print(v)\n   cnt &lt;- cnt+1\n   if(cnt &gt; 5) {\n      break\n   }\n}\n\n[1] \"Hello\" \"loop\" \n[1] \"Hello\" \"loop\" \n[1] \"Hello\" \"loop\" \n[1] \"Hello\" \"loop\" \n\n\n\n6.11.2 Операторы управления\nОператоры управления циклом изменяют обычную последовательность выполнения. Когда выполнение покидает область видимости, все автоматические объекты, которые были созданы в этой области, уничтожаются.\nКлючевое слово next\n\nОператор next в языке полезен, когда требуется пропустить текущую итерацию цикла, не завершая его. При встрече с next синтаксический анализатор R пропускает дальнейшие вычисления и начинает следующую итерацию цикла.\nnext\n\nv &lt;- LETTERS[1:6]\nfor ( i in v) {\n   \n   if (i == \"D\") {\n      next\n   }\n   print(i)\n}\n\n[1] \"A\"\n[1] \"B\"\n[1] \"C\"\n[1] \"E\"\n[1] \"F\"\n\n\nКлючевое слово break\n\nОператор break в языке программирования R используется следующим образом.\n\nКогда оператор break встречается внутри цикла, цикл немедленно завершается, и управление программой возобновляется в следующем операторе, следующем за циклом.\nОн может быть использован для завершения случая в операторе switch.\n\nbreak\nПример\n\nv &lt;- c(\"Hello\",\"loop\")\ncnt &lt;- 2\n\nrepeat {\n   print(v)\n   cnt &lt;- cnt + 1\n    \n   if(cnt &gt; 5) {\n      break\n   }\n}\n\n[1] \"Hello\" \"loop\" \n[1] \"Hello\" \"loop\" \n[1] \"Hello\" \"loop\" \n[1] \"Hello\" \"loop\"",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "r-lang/basic.html#sec-r-lang-basic-function",
    "href": "r-lang/basic.html#sec-r-lang-basic-function",
    "title": "6  Основы R",
    "section": "\n6.12 Функции",
    "text": "6.12 Функции\nФункция - это набор операторов, организованных вместе для выполнения определенной задачи. В R имеется большое количество встроенных функций, и пользователь может создавать свои собственные функции.\nВ R функция - это объект, поэтому интерпретатор R может передавать функции управление, а также аргументы, которые могут потребоваться функции для выполнения действий.\nФункция, в свою очередь, выполняет свою задачу и возвращает управление интерпретатору, а также любой результат, который может быть сохранен в других объектах.\nЧасто используемые функции\n\n6.12.1 Определение функции\nФункция R создается с помощью ключевого слова function. Основной синтаксис определения функции R выглядит следующим образом\nfunction_name &lt;- function(arg_1, arg_2, ...) {\n   # Инструкции\n   # Инструкции\n}\n\n6.12.2 Элементы объекта функции\nФункция состоит из\n\nИмени – Функция хранится в среде R как объект с этим именем.\nАргументов – Когда функция вызывается, в неё передаетются значения аргументов. Аргументы необязательны, то есть функция может не содержать аргументов. Также аргументы могут иметь значения по умолчанию.\nТела функции – тело функции содержит набор выражений, которые определяют, что делает функция.\nВозвращаемого значения – это последнее выражение в теле функции, которое должно быть вычислено.\n\nВ R есть множество встроенных функций, которые можно вызывать непосредственно в программе, не определяя их предварительно. Также можно создавать и использовать собственные функции, называемые функциями, определяемыми пользователем.\n\n6.12.3 Встроенные функции\nПростыми примерами встроенных функций являются seq(), mean(), sum(), paste() и т. д. Они напрямую вызываются программами, написанными пользователем.\n\nseq(32,44)\n\n [1] 32 33 34 35 36 37 38 39 40 41 42 43 44\n\nmean(25:82)\n\n[1] 53.5\n\nsum(41:68)\n\n[1] 1526\n\n\n\n6.12.4 Пользовательские функции\nОни определяют, что нужно пользователю, и после создания могут использоваться так же, как и встроенные функции. Ниже приведен пример создания и использования функции.\n\nf &lt;- function(a) {\n   for(i in 1:a) {\n      b &lt;- i^2\n      print(b)\n   }\n}\n\n\n6.12.5 Вызов функции\n\nf &lt;- function(a) {\n   for(i in 1:a) {\n      b &lt;- i^2\n      print(b)\n   }\n}\n\nf(6)\n\n[1] 1\n[1] 4\n[1] 9\n[1] 16\n[1] 25\n[1] 36\n\n\nБез аргументов\n\nf &lt;- function() {\n   for(i in 1:5) {\n      print(i^2)\n   }\n}   \n\nf()\n\n[1] 1\n[1] 4\n[1] 9\n[1] 16\n[1] 25\n\n\nПозиционные и именованные аргументы\nАргументы вызова функции могут быть представлены в той же последовательности, что и определены в функции, или же они могут быть представлены в другой последовательности, но приписаны к именам аргументов.\n\nf &lt;- function(a,b,c) {\n   a * b + c\n}\n\nf(5,3,11)\n\n[1] 26\n\nf(a = 11, b = 5, c = 3)\n\n[1] 58\n\n\nАргументы по умолчанию\nМожно задать значения аргументов в определении функции и вызвать функцию без указания аргументов, чтобы получить результат по умолчанию.\n\nf &lt;- function(a = 3, b = 6) {\n   a * b\n}\n\nf()\n\n[1] 18\n\nf(9,5)\n\n[1] 45\n\n\n\n\n\n\n1. \nR Tutorial [Электронный ресурс]. URL: https://www.tutorialspoint.com/r/index.htm (дата обращения: 20.02.2025).\n\n\n2. \nR Tutorial [Электронный ресурс]. URL: https://www.w3schools.com/r/ (дата обращения: 20.02.2025).",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "r-lang/advanced.html",
    "href": "r-lang/advanced.html",
    "title": "7  Продвинутый R",
    "section": "",
    "text": "7.1 Встроенные константы\n[1]\n[2]\nПри объединении объектов разных типов в вектор, они приводятся к более широкому (implicit coercion)\nВ R зарезервирован набор специальных констант:\npi/Inf\n\n[1] 0",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Продвинутый R</span>"
    ]
  },
  {
    "objectID": "r-lang/advanced.html#встроенные-константы",
    "href": "r-lang/advanced.html#встроенные-константы",
    "title": "7  Продвинутый R",
    "section": "",
    "text": "Inf – бесконечность\n\n\nNA – Not Available. Отсутствующее значение. Используется для обозначения пропущенных значений в данных.\n\nNaN – Not A Number. Определяет неопределенное число или «не число».\n\nNULL – представляет нулевой объект. Часто используется когда возвращаема величина выражения или функции не определена.\n\npi – 3.141593",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Продвинутый R</span>"
    ]
  },
  {
    "objectID": "r-lang/advanced.html#пропущенные-значения",
    "href": "r-lang/advanced.html#пропущенные-значения",
    "title": "7  Продвинутый R",
    "section": "\n7.2 Пропущенные значения",
    "text": "7.2 Пропущенные значения\nNA, NaN – используются для работы с пропущенными значениями. is.na – функция для проверки наличия в векторе элементов с пропущенными значениями типа NA. NA может иметь тип integer, numeric, character. is.nan – функция для проверки наличия в векторе элементов с пропущенными значениями типа NaN.\n\nx &lt;- c(1, NaN, NA, 10, 3)\nis.na(x)\n\n[1] FALSE  TRUE  TRUE FALSE FALSE\n\nis.nan(x)\n\n[1] FALSE  TRUE FALSE FALSE FALSE",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Продвинутый R</span>"
    ]
  },
  {
    "objectID": "r-lang/advanced.html#имена",
    "href": "r-lang/advanced.html#имена",
    "title": "7  Продвинутый R",
    "section": "\n7.3 Имена",
    "text": "7.3 Имена\nИмена (Names) – используются для лучшего понимания объектов и написания программного кода. Элементы объектов могут иметь имена. names – функция для присвоения имен элементам объектов.\n\nx &lt;- 1:3\nnames(x)\n\nNULL\n\nnames(x) &lt;- c(\"foo\", \"bar\", \"norf\")\nnames(x)\n\n[1] \"foo\"  \"bar\"  \"norf\"\n\n\nСписки и матрицы также могут иметь имена.\n\nlist(a = 1, b = 2, c = 3)\n\n$a\n[1] 1\n\n$b\n[1] 2\n\n$c\n[1] 3\n\nm &lt;- matrix(1:4, nrow = 2, ncol = 2)\ndimnames(m) &lt;- list(c(\"a\", \"b\"), c(\"c\", \"d\"))\nm\n\n  c d\na 1 3\nb 2 4",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Продвинутый R</span>"
    ]
  },
  {
    "objectID": "r-lang/advanced.html#атрибуты-объектов",
    "href": "r-lang/advanced.html#атрибуты-объектов",
    "title": "7  Продвинутый R",
    "section": "\n7.4 Атрибуты объектов",
    "text": "7.4 Атрибуты объектов\nОбъекты характеризуются атрибутами которые могут быть рассмотрены, как метаданные для объектов. Не все объекты имеют атрибуты. Атрибуты используются для упрощения понимания и описания объектов. Примеры атрибутов объектов:\n\nnames, dimnames\ndimensions\nclass\nlength\nпрочие, определенные пользователем, атрибуты (metadata) Для доступа к атрибутам объекта используется функция attributes\n\n\n\nx &lt;- cbind(a = 1:3, pi = pi)\nx\n\n     a       pi\n[1,] 1 3.141593\n[2,] 2 3.141593\n[3,] 3 3.141593\n\nattributes(x)\n\n$dim\n[1] 3 2\n\n$dimnames\n$dimnames[[1]]\nNULL\n\n$dimnames[[2]]\n[1] \"a\"  \"pi\"",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Продвинутый R</span>"
    ]
  },
  {
    "objectID": "r-lang/advanced.html#векторизированные-вычисления",
    "href": "r-lang/advanced.html#векторизированные-вычисления",
    "title": "7  Продвинутый R",
    "section": "\n7.5 Векторизированные вычисления",
    "text": "7.5 Векторизированные вычисления\nИспользование операторов циклов for, while не удобно при работе в командной строке интерпретатора. В R реализованы функции, оптимизирующее циклически вычисления:\n- lapply – производит циклическое вычисление некоторой функции над элементами списка. - sapply – выполняет то же что lapply, только выводит результаты в упрощенном виде. - apply – производит циклическое вычисление некоторой функции над элементами массива. - tapply – производит циклическое вычисление некоторой функции над заданным набором элементов вектора. - mapply – мультивариативная версия функции lapply (работает сразу с несколькими объектами).\nlapply производит циклическое вычисление некоторой функции над элементами списка. lapply всегда возвращает объект класса список, несмотря на тип объекта на входе. Если объект на входе не список, то он будет преобразован с помощью функции as.list.\nsapply вариант функции lapply, предназначенный для максимального упрощения результатов. Например: 1. Если результат список (list), каждый элемент которого имеет длину 1, то возвращается вектор. 2. Если результат список (list), каждый элемент которого вектор одинаковой длины, то возвращается матрица.\n3. Если результат непонятно как может быть преобразован, то возвращается список.\napply используется для вычисления некоторой функции в пределах заданного набора индексов массива. Особенности: 1. В основном применяется для вычисления некоторой функции по строкам или столбцам массива. Работает даже для трехмерных матриц. 2. Используется для массивов любой размерности.\nmapply – мультивариативный вариант lapply и sapply, предназначенный для параллельного применения в цикле некоторой функции к набору R-объектов.\nПример векторизации функции.\n\nrnorm (5, 1, 2)\n\n[1] -0.3140464  0.6775787  0.7919132 -2.1666640  0.9776693\n\nmapply(rnorm, 1:5, 1:5, 2)\n\n[[1]]\n[1] -2.747405\n\n[[2]]\n[1] 1.522397 2.403597\n\n[[3]]\n[1] -0.640587  3.578228  4.283910\n\n[[4]]\n[1] 1.342126 4.334625 2.119767 3.378326\n\n[[5]]\n[1] 7.886133 3.547100 7.977396 6.544646 6.690738\n\n\ntapply – используется для расчета некоторой функции в цикле по группам элементов вектора. Это удобно когда один вектор формирует несколько выборок.",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Продвинутый R</span>"
    ]
  },
  {
    "objectID": "r-lang/advanced.html#правила-видимости-свободных-переменных-scoping-rules",
    "href": "r-lang/advanced.html#правила-видимости-свободных-переменных-scoping-rules",
    "title": "7  Продвинутый R",
    "section": "\n7.6 Правила видимости свободных переменных (Scoping rules)",
    "text": "7.6 Правила видимости свободных переменных (Scoping rules)\nДля присвоения lm некоторого значения будет осуществляться поиск данной функции в различных областях или пространствах памяти среды – environments. Environment – список или набор R-объектов (по типу символ-значение), которые представляют собой видимое по некоторым правилам пространство памяти. Если работа производится в строке интерпретатора команд, то загружается global environment. В global environment входят все элементы, созданные или загруженные в R. При поиске lm порядок просмотра environments 1. global environment 2. пространства, загруженных пакетов (namespaces).\nglobal environment эквивалентно пространству памяти «пользователя». После просмотра global environment поиск осуществляется от пространства памяти пакета stats к пространству пакета base. Порядок следования пакетов важен! library – функция для загрузки пакетов. Загруженный пакет становится на вторую позицию, остальные пакеты смещаются на одну позицию вниз. Scoping rules определяют правила присвоения значений свободным переменным функций. В R используется lexical или static scoping. Наиболее распространенная альтернатива - dynamic scoping. Фактически задача сводится к вопросу: как R просматривает environments, для того чтобы связать свободную переменную с конкретным значением.\n\nz &lt;- 1\nf &lt;- function(x, y) {\n    x^2 + y / z\n}\n\nГде z – свободная переменная (a free variable). Свободная переменная не является ни формальным аргументом функции, ни локальной переменной функции.\nФункции используются для систематизации повторяющегося программного кода. Функция создается с помощью оператора function и сохраняется как R-объект класса function.\nОсобенности: 1. Объекты класса function можно передавать в качестве аргумента другой функции. 2. Функции могут быть вложенными, т.е. одна функция может быть определена внутри другой. 3. Возвращаемое значение функции – это результат последнего выражения в коде функции.\nАргументы сопоставляются по позициям в списке или по совпадению имен.\n\nmydata &lt;- rnorm(100)\nsd(mydata)\n\n[1] 0.9761307\n\nsd(x = mydata)\n\n[1] 0.9761307\n\nsd(x = mydata, na.rm = FALSE)\n\n[1] 0.9761307\n\nsd(na.rm = FALSE, x = mydata)\n\n[1] 0.9761307\n\nsd(na.rm = FALSE, mydata)\n\n[1] 0.9761307\n\n\n\n7.6.1 Сопоставление аргументов\nЕсли передаются именованные аргументы, то их не обязательно располагать в требуемом порядке. Можно смешивать «порядок» и «имена». Именованный аргумент извлекается из списка, остальные будут ассоциированы по позициям оставшихся аргументов в списке.\n\nargs(lm)\n\nfunction (formula, data, subset, weights, na.action, method = \"qr\", \n    model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, \n    contrasts = NULL, offset, ...) \nNULL\n\n\nИмена аргументов могут совпадать не полностью, а частично. Система сама определяет наиболее подходящий аргумент и присваивает ему значение. Порядок следования операций определения аргументов в функциях: 1) Проверка на точное совпадение именованных аргументов. 2) Проверка на частичное совпадение именованных аргументов. 3) Проверка на точное совпадение позиций неименованных аргументов.\n\nf &lt;- function(a, b = 1, c = 2, d = NULL) {\n    return(1);\n}\n\nАргумент функции в виде “…” используется для передачи стандартных аргументов сторонних функций.\n\nmyplot &lt;- function(x, y, type = \"l\", ...) {\n    plot(x, y, type = type, ...)\n}\n\nАргумент “…” применяется когда число аргументов функции заранее не известно\n\nargs(paste)\n\nfunction (..., sep = \" \", collapse = NULL, recycle0 = FALSE) \nNULL\n\nargs(cat)\n\nfunction (..., file = \"\", sep = \" \", fill = FALSE, labels = NULL, \n    append = FALSE) \nNULL\n\n\nАргументы, идущие после “…”, должны быть именованы полностью.\n\nargs(paste)\n\nfunction (..., sep = \" \", collapse = NULL, recycle0 = FALSE) \nNULL\n\npaste(\"a\", \"b\", sep = \":\")\n\n[1] \"a:b\"\n\npaste(\"a\", \"b\", se = \":\")\n\n[1] \"a b :\"",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Продвинутый R</span>"
    ]
  },
  {
    "objectID": "r-lang/advanced.html#scoping-rules",
    "href": "r-lang/advanced.html#scoping-rules",
    "title": "7  Продвинутый R",
    "section": "\n7.7 Scoping rules",
    "text": "7.7 Scoping rules\nПравило (lexical rules) 1: Значение для свободной переменной функции определяются в том пространстве памяти (environment), где была создана данная функция. Каждое environment имеет родительское environment. Родитель может иметь несколько потомков. Пространство без родителя называется пустым (empty environment). Функция + ее пространство памяти = closure или function closure. Правило (lexical rules) 2: Если значение для свободной переменной функций не найдено в пространстве, где была создана данная функция, то продолжается поиск по линии родительских пространств вплоть до пространства наивысшего уровня top-level environment (global environment или namespace of package). Правило (lexical rules) 3: После просмотра пространства наивысшего уровня (top-level environment) поиск осуществляется вниз по списку пространств загруженных пакетов (namespaces).\nПри достижении пространства последнего пакета (empty environment) в списке и не нахождения значения для свободной переменной выводится сообщение об ошибке.\n\nmake_power &lt;- function(n) {\n    pow &lt;- function(x) {\n        x^n\n    }\n    return(pow)\n}\ncube &lt;- make_power(3)\nsquare &lt;- make_power(2)\ncube(3)\n\n[1] 27\n\nsquare(3)\n\n[1] 9\n\n\nДля просмотра пространства памяти функции можно воспользоваться функциями ls, environment и get.\n\nls(environment(cube))\n\n[1] \"n\"   \"pow\"\n\nget('n', environment(cube))\n\n[1] 3\n\n\n\ny &lt;- 10\nf &lt;- function(x) {\n    y &lt;- 2\n    y^2 + g(x)\n}\n\ng &lt;- function(x) {\n    x*y\n}\n\nДостоинства lexical scoping: 1) Не требуется передача длинных списков аргументов в функции. Это значительно упрощает работу пользователя в интерактивном режиме и в ходе исследовательской (exploratory) работы. 2) Сокращает, а значит и упрощает, программный код. 3) Удобно для решения задач оптимизации (nlm, optim , optimise) для управления целевыми функциями, параметры которых обеспечивают корректное решение задачи.\nцикл с помощью walk по датасетам или по сгенерированным последовательностям\nRecycling rule Some of the preceding statements can be written more concisely. When the operands are of different lengths, the shorter one is recycled as many times as necessary, as in rep(y, length.out=length(x)). For exampl\nУпростите выражение c(sqrt(1), sqrt(2), sqrt(3))?\nThe expression: 4i=1∑n2i−1(−1)i+1=4(11−31+51−71+⋯) slowly converges to π as n approaches ∞. Calculate it for n=1 000 000 and n=1 000 000 000 using the vectorised functions and operators discussed in this chapter, making use of the recycling rule as much as possible",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Продвинутый R</span>"
    ]
  },
  {
    "objectID": "r-lang/advanced.html#ленивые-вычисления",
    "href": "r-lang/advanced.html#ленивые-вычисления",
    "title": "7  Продвинутый R",
    "section": "\n7.8 Ленивые вычисления",
    "text": "7.8 Ленивые вычисления",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Продвинутый R</span>"
    ]
  },
  {
    "objectID": "r-lang/advanced.html#sec-r-lang-advanced-assigment",
    "href": "r-lang/advanced.html#sec-r-lang-advanced-assigment",
    "title": "7  Продвинутый R",
    "section": "\n7.9 Присваивание",
    "text": "7.9 Присваивание",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Продвинутый R</span>"
    ]
  },
  {
    "objectID": "r-lang/advanced.html#sec-r-lang-advanced-formula",
    "href": "r-lang/advanced.html#sec-r-lang-advanced-formula",
    "title": "7  Продвинутый R",
    "section": "\n7.10 Объект формулы",
    "text": "7.10 Объект формулы",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Продвинутый R</span>"
    ]
  },
  {
    "objectID": "r-lang/advanced.html#sec-r-lang-advanced-lambda",
    "href": "r-lang/advanced.html#sec-r-lang-advanced-lambda",
    "title": "7  Продвинутый R",
    "section": "\n7.11 Лямбда функция",
    "text": "7.11 Лямбда функция\n\n\n\n\n1. \nWickham H. Advanced R second edition [Электронный ресурс]. 2022. URL: https://adv-r.hadley.nz/ (дата обращения: 20.02.2025).\n\n\n2. \nGagolewski M. Deep R Programming [Электронный ресурс]. 2025. URL: https://deepr.gagolewski.com/ (дата обращения: 20.02.2025).",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Продвинутый R</span>"
    ]
  },
  {
    "objectID": "linear/overview.html",
    "href": "linear/overview.html",
    "title": "Линейное программирование",
    "section": "",
    "text": "Общая формулировка задачи\nТребуется минимизировать (\\(\\max\\)) или минимизировать (\\(\\min\\)) линейную целевую функцию \\(\\mathrm{F}=c_1x_1+c_2x_2+...c_nx_n=\\mathbf{cx}\\) от \\(n\\) переменных при соблюдении \\(m\\) линейных ограничений вида\n\\[\n\\begin{cases}\na_{11}x_1+a_{12}x_2+a_{13}x_3+\\dots+a_{1n}x_n \\leq b_1 \\\\\n\\vdots \\\\\na_{l1}x_1+a_{l2}x_2+a_{l3}x_3+\\dots+a_{ln}x_n \\geq b_l \\\\\n\\vdots \\\\\na_{m1}x_1+a_{m2}x_2+a_{m3}x_3+\\dots+a_{mn}x_n \\geq b_m \\\\\n\\end{cases}\n\\]\nПри условии, что задача приведена с стандартную форму можно записать формулировку в матрично-векторном виде \\(z=\\mathbf{cx}\\) при ограничениях \\(\\mathbf{Ax}=\\mathbf{b}\\), \\(\\mathbf{x} \\geq \\mathbf{0}\\)",
    "crumbs": [
      "Линейное программирование"
    ]
  },
  {
    "objectID": "linear/overview.html#sec-linear-overview-standart-problem",
    "href": "linear/overview.html#sec-linear-overview-standart-problem",
    "title": "Линейное программирование",
    "section": "Стандартная форма задачи",
    "text": "Стандартная форма задачи\n[1]\n\nВсе ограничения (включая ограничения неотрицательности переменных) преобразуются в равенства с неотрицательной правой частью.\nВсе переменные неотрицательные.\n\n\nПреобразование неравенств в равенства с неотрицательной правой частью\nНеравенства любого типа (со знаками неравенств \\(\\leq\\) и \\(\\geq\\)) можно преобразовать в равенства путём добавления в левую часть неравенств дополнительных переменных – остаточных и избыточных, которые связаны с неравенствами типа \\(\\leq\\) и \\(\\geq\\) соответственно.\nДля неравенств типа \\(\\leq\\) в левую часть неравенства вводится неотрицательная остаточная переменная. Например неравенство переходит в равенство добавлением остаточной переменной \\(s_1\\).\n\\[\n6x_1+4x_2\\ \\leq 24 \\quad \\longrightarrow \\quad 6x_1+4x_2+s_1=24, s_1\\geq0\n\\]\nНеравенства типа \\(\\geq\\) обычно устанавливают нижнюю границу чего либо. Избыточная переменная определяет превышение значения левой части неравенства над этой границей. Например:\n\\[\nx_1+x_2\\ \\geq 800 \\quad \\longrightarrow \\quad x_1+x_2-S_1=800, s_1\\geq0\n\\]\nПоследнее требование – правая часть полученных равенств должна быть неотрицательная. Правую часть равенства можно сделать неотрицательными просто умножив все равенство на \\(-1\\). Например\n\\[\n-x_1+x_2\\ \\leq -3 \\quad \\longrightarrow \\quad -x_1+x_2+s_1=-3, s_1\\geq0\n\\]\nТеперь, умножая обе части равенства на \\(-1\\), получим равенство с неотрицательной правой частью: \\(x_1-x_2-s_1=3\\)\n\n\nПреобразование свободных переменных\nВозможны такие ситуации, когда переменные в задаче ЛП могут принимать любые действительные значения, как положительные, так и отрицательные. В таком случае свободная переменная может быть замещена двумя неотрицательными переменными с использованием следующей подстановки\n\\[\nS_i=S_i^- - S_i^+, S_i^-\\geq0, S_i^+\\geq0\n\\]\nЭлементы линейной алгебры\nГрафическое решение\nАнализ чувствительности\nСимплекс метод\nM-метод и двухэтапный метод\nЦелочисленная линейная задача\nДвойственная задача\nТранспортная задача\nСетевая задача\n\n\n\n\n1. А. Т.Х. Исследование операций. 10-е изд. / под ред. Слепцова А.В. Санкт-Петербург: ООО \"Диалектика\", 2019. С. 1056.",
    "crumbs": [
      "Линейное программирование"
    ]
  },
  {
    "objectID": "linear/algebra.html",
    "href": "linear/algebra.html",
    "title": "8  Элементы линейной алгебры",
    "section": "",
    "text": "8.1 Вектор\n[1] [2]\n[3]",
    "crumbs": [
      "Линейное программирование",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Элементы линейной алгебры</span>"
    ]
  },
  {
    "objectID": "linear/algebra.html#sec-linear-algebra-vector",
    "href": "linear/algebra.html#sec-linear-algebra-vector",
    "title": "8  Элементы линейной алгебры",
    "section": "",
    "text": "Определение 8.1  \n\nВектор\n\n\\(\\mathbf{P}=(p_1,p_2,\\dots,p_n)\\) упорядоченная система \\(n\\) действительных чисел\n\n\n\n\n8.1.1 Операции\n\nРавенство\nДва \\(n\\)-мерных вектора \\(\\mathbf{X}=(x_1,x_2,\\dots,x_n)\\) и \\(\\mathbf{Y}=(y_1,y_2,\\dots,y_n)\\) считаются равными, если их соответствующие компоненты совпадают, т.е. если\n\\[\nx_i=y_i,\\quad для \\quad i=1,2,\\dots,n\n\\]\n\n\nСложение и вычитание\nПусть \\(\\mathbf{P}=(p_1,p_2,\\dots,p_n)\\) и \\(\\mathbf{Q}=(q_1,q_2,\\dots,q_n\\) – два \\(n\\)-мерных вектора. Тогда элементы вектора \\(\\mathbf{R}=(r_1,r_2,\\dots,r_n)\\), равного \\(\\mathbf{R}=\\mathbf{P}\\pm\\mathbf{Q}\\) определяются следующими соотношениями \\(r_i=p_i \\pm q_i\\).\nВ общем случае для любых векторов \\(\\mathbf{P}\\), \\(\\mathbf{Q}\\) и \\(\\mathbf{S}\\), имеющих одинаковую размерность, выполняются следующие соотношения\n\\[\n\\begin{aligned}\n& \\mathbf{P} \\pm \\mathbf{Q} = \\mathbf{Q} \\pm \\mathbf{P} \\quad \\\\\n& (\\mathbf{P} + \\mathbf{Q}) + \\mathbf{S} = \\mathbf{P} + (\\mathbf{Q}+\\mathbf{S})\\\\\n& \\mathbf{P} + (-\\mathbf{P}) = \\mathbf{0}\n\\end{aligned}\n\\]\n\n\nУмножения на скаляр\nДля произвольного вектора \\(\\mathbf{P}\\) и скаляра \\(\\theta\\) (произвольного действительного числа) произведение вектора \\(\\mathbf{P}\\) на скаляр \\(\\theta\\) определяет новый вектор \\(\\mathbf{Q}\\), задаваемый соотношением\n\\[\n\\mathbf{Q}=\\theta \\mathbf{P}=(\\theta p_1,\\theta p_2,\\dots ,\\theta p_n)\n\\]\nВ общем случае для любых векторов \\(\\mathbf{P}\\) и \\(\\mathbf{S}\\) имеющих одинаковую размерность, произвольных скалярных величин \\(\\theta\\) и \\(\\gamma\\) выполняются следющие соотношения\n\\[\n\\begin{aligned}\n&\\theta(\\mathbf{P}+\\mathbf{S})=\\theta \\mathbf{P} + \\theta \\mathbf{S}\\\\\n&\\theta(\\gamma \\mathbf{P})=(\\theta \\gamma)\\mathbf{P}\n\\end{aligned}\n\\]\n\n\nСкалярное произведение\nКаждой паре векторов \\(\\mathbf{A}=(a_1,a_2,\\dots,a_n)\\) и \\(\\mathbf{B}=(b_1,b_2,\\dots,b_n)\\) может быть сопоставлено число\n\\[\n(\\mathbf{A},\\mathbf{B})=\\sum_{i=1}^n{a_i b_i}\n\\]\nназываемое их скалярным произведением.\nСкалярное произведение обладает следующими свойствами\n\\[\n\\begin{aligned}\n&(\\mathbf{A},\\mathbf{B})=(\\mathbf{B},\\mathbf{A})\\\\\n&(\\mathbf{A}_1 + \\mathbf{A}_2,\\mathbf{B}) = (\\mathbf{A}_1,\\mathbf{B}) + (\\mathbf{A}_2,\\mathbf{B})\\\\\n&(\\lambda \\mathbf{A},\\mathbf{B})=\\lambda(\\mathbf{A},\\mathbf{B})\\\\\n&(\\mathbf{A},\\mathbf{A})\\ge0\\\\\n\\end{aligned}\n\\]\n\n\nНормирование и норма\nДлиной или нормой вектора \\(A=(a_1,a_2,\\dots,a_n)\\) называется число\n\\[\n|\\mathbf{A}|=\\sqrt{(\\mathbf{A},\\mathbf{A})}=\\sqrt{\\sum_{i=1}^n{a_i^2}}\n\\]\n\n\n\n8.1.2 Линейная независимость векторов\nВекторы \\(\\mathbf{P}_1,\\mathbf{P}_2,\\dots,\\mathbf{P}_n\\) называются линейно независимыми, если равенство\n\\[\n\\sum_{j=1}^n{\\theta_j \\mathbf{P}_i}=0 \\quad \\implies \\quad \\theta_j=0,\\quad j=1,2,\\dots,n\n\\]\nвыполняется тогда и только тогда, когда все \\(\\theta_j\\) равны нулю (\\(\\theta_j\\) – произвольные действительные числа). Если равенство \\(\\sum_{j=1}^n{\\theta_j \\mathbf{P}_j}=\\mathbf{0}\\) выполняются при некоторых \\(\\theta_j \\ne 0\\), то векторы \\(\\mathbf{P}_1,\\mathbf{P}_2,\\dots,\\mathbf{P}_n\\) называются линейно зависимыми.\nНапример, векторы \\(\\mathbf{P}_1=(1,2)\\) и \\(\\mathbf{P}_2=(2,4)\\) линейно зависимы, поскольку существуют ненулевые числа \\(\\theta_1=2\\) и \\(\\theta_2=-1\\) при которых выполняется равенство \\(\\theta_1 \\mathbf{P}_1 + \\theta_2 \\mathbf{P}_2=\\mathbf{0}\\)\n\nТеорема 8.1 Для линейной независимости системы векторов \\(\\mathbf{A}_i=(a_{i1},a_{i2},\\dots,a_{in})\\) для \\(i=1,2,\\dots,s\\), необходимо и достаточно существование квадратной матрицы порядка \\(s\\)\n\\[\n\\begin{pmatrix}\na_{1j_1} & a_{1j_2} & \\dots & a_{1j_s} \\\\\na_{1j_1} & a_{1j_2} & \\dots & a_{1j_s} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{sj_1} & a_{sj_2} & \\dots & a_{sj_s}\n\\end{pmatrix}\n\\]\nсоставленной из координат векторов \\(\\mathbf{A}_i\\), с определителем, отличным от нуля. Если в частности, \\(s=n\\), то для линейной независимости данной системы векторов необходимо и достаточно, чтобы\n\\[\n|(\\mathbf{A}_1,\\mathbf{A}_2,\\dots,\\mathbf{A}_n)| \\ne 0\n\\]\n\n\nОпределение 8.2  \n\nРангом\n\nпроизвольной системы векторов называется максимальное число линейно независимых векторов данной системы.\n\n\n\n\nОпределение 8.3  \n\nБазисом\n\nназывает совокупность линейно независимых векторов системы, число которых равно её рангу.\n\n\n\nМножество линейно независимых векторов данной системы является её базисом в том и только в том случае, если любой вектор системы представим в виде линейной комбинации векторов рассматриваемого множества.",
    "crumbs": [
      "Линейное программирование",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Элементы линейной алгебры</span>"
    ]
  },
  {
    "objectID": "linear/algebra.html#sec-linear-algebra-matrix",
    "href": "linear/algebra.html#sec-linear-algebra-matrix",
    "title": "8  Элементы линейной алгебры",
    "section": "8.2 Матрица",
    "text": "8.2 Матрица\n\nОпределение 8.4  \n\nМатрицей\n\nназывается прямоугольный массив элементов, структурированный строками и столбцами. В матрице \\(\\mathbf{A}\\) элемент \\(a_{ij}\\) расположен на пересечении \\(i\\)-й строки и \\(j\\)-го столбца массива.\n\n\n\nГоворят, что матрица имеет порядок (размерность) \\(m \\times n\\), если она состоит из \\(m\\) строк b \\(n\\) столбцов. Например следующая матрица имеет размерность \\(4 \\times 3\\)\n\\[\n\\begin{pmatrix}\na_{11} & a_{12} & a_{13} \\\\\na_{21} & a_{22} & a_{23} \\\\\na_{31} & a_{32} & a_{33} \\\\\na_{41} & a_{42} & a_{43}\n\\end{pmatrix} = {\\|a_{ij}\\|}_{4 \\times 3}\n\\]\n\n8.2.1 Типы матриц\n\nОпределение 8.5  \n\nКвадратная матрица\n\nэто матрица, имеющая одинаковое количество строк и столбцов, т.е. у нее \\(m=n\\).\n\n\n\n\nОпределение 8.6  \n\nЕдиничная матрица\n\nэто квадратная матрица, у которой все элементы главной диагонали равны 1, а все остальные – нулю.\n\n\n\nНапример, единичная матрица порядка \\(3 \\times 3\\) имеет вид\n\\[\n\\mathbf{I_3}=\n\\begin{pmatrix}\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1\n\\end{pmatrix}\n\\]\n\nОпределение 8.7  \n\nНулевая матрица\n\nэто матрица все элементы которой равны нулю \\(\\mathbf{B}=\\mathbf{0}\\).\n\n\n\n\nОпределение 8.8  \n\nВектор-строка\n\nэто матрица, имеющая одну строку и \\(n\\) столбцов.\n\n\n\n\\[\n\\mathbf{P}=(p_1,p_2,\\dots,p_n)\n\\]\n\nОпределение 8.9  \n\nВектор-столбец\n\nэто матрица, имеющая \\(m\\) строк и один столбец.\n\n\n\n\\[\n\\mathbf{P}=\n\\begin{pmatrix}\np_1 \\\\\np_2 \\\\\n\\vdots \\\\\np_n\n\\end{pmatrix}\n\\]\n\nОпределение 8.10  \n\nДиагональная матрица\n\nквадратная матрица, все элементы которой, стоящие вне главной диагонали, равны нулю.\n\n\n\n\\[\n\\mathbf{D}=\n\\begin{pmatrix}\nd_{11} & 0 & \\cdots & 0 \\\\\n0 & d_{22} & \\cdots & 0 \\\\\n\\vdots & \\vdots  & \\ddots & \\vdots \\\\\n0 & 0 & 0 & d_{nn} \\\n\\end{pmatrix}\n\\]\nДиагональная матрица \\(\\mathbf{D}\\) с элементами \\((d_1,d_2,\\dots,d_n)\\), стоящими на главной диагонали, обозначается \\(\\mathrm{diag}\\{d_1,d_2,\\dots,d_n\\}\\)\n\nОпределение 8.11  \n\nБлочная матрица\n\nэто представление матрицы, при котором она рассекается вертикальными и горизонтальными линиями на прямоугольные части — блоки\n\n\n\n\\[\n\\mathbf{A}=\n\\begin{pmatrix}\n\\mathbf{A}_{11} & \\mathbf{A}_{12} & \\dots & \\mathbf{A}_{1t} \\\\\n\\mathbf{A}_{21} & \\mathbf{A}_{22} & \\dots & \\mathbf{A}_{2t} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n\\mathbf{A}_{s1} & \\mathbf{A}_{s2} & \\dots & \\mathbf{A}_{st}\n\\end{pmatrix}\n\\]\nгде блок \\(\\mathbf{A}_{\\alpha \\beta}\\) имеет размер \\(m_\\alpha \\times n_\\beta\\) для \\(\\alpha=1,2,\\dots,s\\) и \\(\\beta=1,2,\\dots,t\\).\nНапример матрица размером \\(4 \\times 4\\)\n\\[\n\\mathbf{P} =\n\\begin{pmatrix}\n1 & 1 & 2 & 2 \\\\\n1 & 1 & 2 & 2 \\\\\n3 & 3 & 4 & 4 \\\\\n3 & 3 & 4 & 4\n\\end{pmatrix}\n\\]\nМожет быть представлена в виде блочной матрицы из четырёх блоков размера \\(2 \\times 2\\) каждый. При следующем определении блоков\n\\[\n\\mathbf{P}_{11}=\n\\begin{pmatrix}\n1 & 1 \\\\\n1 & 1\n\\end{pmatrix},\n\\mathbf{P}_{12}=\n\\begin{pmatrix}\n2 & 2 \\\\\n2 & 2\n\\end{pmatrix},\n\\mathbf{P}_{21}=\n\\begin{pmatrix}\n3 & 3 \\\\\n3 & 3\n\\end{pmatrix},\n\\mathbf{P}_{22}=\n\\begin{pmatrix}\n4 & 4 \\\\\n4 & 4\n\\end{pmatrix}\n\\]\nблочная матрица может быть записана в таком виде:\n\\[\n\\mathbf{P}=\n\\left(\n\\begin{array}{c | c}\n\\mathbf{P}_{11} & \\mathbf{P}_{12} \\\\\n\\hline\n\\mathbf{P}_{21} & \\mathbf{P}_{22}\n\\end{array}\\right)\n\\]\n\n\n8.2.2 Операции\nДля матриц определены только операции сложения (вычитания) и умножения Операция деления матриц не определена, но в некоторых случаях её может заменить операция обращения матриц.\n\nСложение и вычитание\nСложение (вычитание) двух матриц \\(\\mathbf{A}=\\|a_{ij}\\|\\) и \\(\\mathbf{B}=\\|b_{ij}\\|\\) возможно только тогда, когда они имеют одинаковую размерность \\((m \\times n)\\). Матрица суммы \\(\\mathbf{D}=\\mathbf{A}+\\mathbf{B}\\) получается путём сложения соответствующих элементов матриц \\(A\\) и \\(B\\), т.е. \\({\\|d_{ij}\\|}_{m \\times n} = {\\|a_{ij}+b_{ij}\\|}_{m \\times n}\\).\nДля произвольных матриц \\(\\mathbf{A}\\), \\(\\mathbf{B}\\) и \\(\\mathbf{C}\\), имеющих одинаковую размерность справедливы следующие соотношения\n\\[\n\\begin{aligned}\n& \\mathbf{A} \\pm \\mathbf{B} = \\mathbf{B} \\pm \\mathbf{A} \\\\\n& \\mathbf{A} \\pm (\\mathbf{B} \\pm \\mathbf{C}) = (\\mathbf{A} \\pm \\mathbf{B}) \\pm \\mathbf{C} \\\\\n& {(\\mathbf{A} \\pm \\mathbf{B})}^T = \\mathbf{A}^T \\pm \\mathbf{B}^T\n\\end{aligned}\n\\]\n\n\nПроизведение\nПроизведение \\(\\mathbf{D}=\\mathbf{AB}\\) для двух матриц \\(\\mathbf{A}=\\|a_{ij}\\|\\) и \\(\\mathbf{B}=\\|b_{ij}\\|\\) определено тогда и только тогда, когда количество столбцов матрицы \\(\\mathbf{A}\\) равно количеству строк матрицы \\(\\mathbf{B}\\). Таким образом, если матрица \\(\\mathbf{A}\\) имеет размерность \\(m \\times r\\), матрица \\(\\mathbf{B}\\) должна иметь размерность \\(r \\times n\\), где \\(m\\) и \\(n\\) — произвольные положительные целые числа. В этом случае матрица их произведения \\(\\mathbf{D}\\) будет иметь размерность \\(m \\times n\\), а её элементы \\(d_{ij}\\) для всех \\(i\\) и \\(j\\) вычисляются по формуле\n\\[\nd_{ij}=\\sum_{k=1}^r{a_{ik}b_{kj}}\n\\]\nНапример, если\n\\[\n\\mathbf{A}=\n\\begin{pmatrix}\n1 & 3 \\\\\n2 & 4\n\\end{pmatrix}\n\\quad и \\quad\n\\mathbf{B}=\n\\begin{pmatrix}\n5 & 7 & 9 \\\\\n6 & 8 & 0\n\\end{pmatrix}\n\\] то\n\\[\n\\mathbf{D}=\n\\begin{pmatrix}\n1 & 3 \\\\\n2 & 4\n\\end{pmatrix}\n\\begin{pmatrix}\n5 & 7 & 9 \\\\\n6 & 8 & 0\n\\end{pmatrix} = \\\\\n=\n\\begin{pmatrix}\n1 \\cdot 5 + 3 \\cdot 6 & 1 \\cdot 7 + 3 \\cdot 8 & 1 \\cdot 9 + 3 \\cdot 0 \\\\\n2 \\cdot 5 + 4 \\cdot 6 & 2 \\cdot 7 + 4 \\cdot 8 & 2 \\cdot 9 + 4 \\cdot 0\n\\end{pmatrix} =\\\\\n=\n\\begin{pmatrix}\n23 & 31 & 9 \\\\\n34 & 46 & 18\n\\end{pmatrix}\n\\]\nВ общем случае \\(\\mathbf{AB} \\ne \\mathbf{BA}\\), даже если произведение \\(\\mathbf{BA}\\) определено.\nПроизведение матриц обладает следующими свойствами\n\\[\n\\begin{aligned}\n& \\mathbf{I}_m \\mathbf{A} = \\mathbf{A}\\mathbf{I}_n,\\quad \\text{где} \\ \\mathbf{I}_m \\ и \\ \\mathbf{I}_n \\ - \\ \\text{единичные матрицы} \\\\\n& \\mathbf{(AB)C} = \\mathbf{A(BC)} \\\\\n& \\mathbf{C(A+B)} = \\mathbf{CA + CB} \\\\\n& \\mathbf{(A+B)C} = \\mathbf{AC + BC} \\\\\n& \\alpha \\mathbf{(AB)} = \\mathbf{A} (\\alpha \\mathbf{B}),\\quad \\text{где} \\ \\alpha \\ - \\text{скаляр}\n\\end{aligned}\n\\]\nПусть матрицы \\(\\mathbf{A}\\) и \\(\\mathbf{B}\\) имеют размерности \\(m \\times r\\) и \\(r \\times n\\) соответственно. Предположим, что эти матрицы представимы в виде совокупности блоков\n\\[\n\\mathbf{A} =\n\\left(\n\\begin{array}{c | c | c}\n\\mathbf{A}_{11} & \\mathbf{A}_{12} & \\mathbf{A}_{13}  \\\\\n\\hline\n\\mathbf{A}_{21} & \\mathbf{A}_{22} & \\mathbf{A}_{23}\n\\end{array}\n\\right)\n\\quad и \\quad\n\\mathbf{B} =\n\\left(\n\\begin{array}{c | c}\n\\mathbf{B}_{11} & \\mathbf{B}_{12} \\\\\n\\hline\n\\mathbf{B}_{21} & \\mathbf{B}_{22} \\\\\n\\hline\n\\mathbf{B}_{31} & \\mathbf{B}_{32} \\\\\n\\end{array}\n\\right)\n\\]\nпричём для всех \\(i\\) и \\(j\\) число столбцов в блоке \\(\\mathbf{A}_{ij}\\) равно числу строк в блоке \\(\\mathbf{B}_{ji}\\). Тогда\n\\[\n\\mathbf{A} \\times \\mathbf{B} =\n\\left(\n\\begin{array}{c | c}\n\\mathbf{A}_{11} \\mathbf{B}_{11} + \\mathbf{A}_{12} \\mathbf{B}_{21} + \\mathbf{A}_{13} \\mathbf{B}_{31} &\n\\mathbf{A}_{11} \\mathbf{A}_{12} + \\mathbf{A}_{12} \\mathbf{B}_{22} + \\mathbf{A}_{13} \\mathbf{B}_{32} \\\\\n\\hline\n\\mathbf{A}_{21} \\mathbf{B}_{11} + \\mathbf{A}_{22} \\mathbf{B}_{21} + \\mathbf{A}_{23} \\mathbf{B}_{31} &\n\\mathbf{A}_{21} \\mathbf{A}_{12} + \\mathbf{A}_{22} \\mathbf{B}_{22} + \\mathbf{A}_{23} \\mathbf{B}_{32} \\\\\n\\end{array}\n\\right)\n\\]\nНапример\n\\[\n\\left(\n\\begin{array}{c | c}\n1 &\n\\begin{matrix}\n2 & 3\n\\end{matrix} \\\\\n\\hline\n\\begin{matrix}\n1 \\\\ 2\n\\end{matrix} &\n\\begin{matrix}\n0 & 5 \\\\\n5 & 6\n\\end{matrix}\n\\end{array}\n\\right)\n\\begin{pmatrix}\n4\\\\\n\\hline\n1 \\\\\n8\n\\end{pmatrix} =\n\\begin{pmatrix}\n(1)(4) +\n\\begin{pmatrix}\n2 & 3\n\\end{pmatrix}\n\\begin{pmatrix}\n1 \\\\\n8\n\\end{pmatrix} \\\\\n\\hline\n\\begin{pmatrix}\n1 \\\\\n2\n\\end{pmatrix}\n(4) +\n\\begin{pmatrix}\n0 & 5 \\\\\n5 & 6\n\\end{pmatrix}\n\\begin{pmatrix}\n1 \\\\ 8\n\\end{pmatrix}\n\\end{pmatrix} =\n\\begin{pmatrix}\n4+2+24\\\\\n\\hline\n\\begin{pmatrix}\n4 \\\\ 8\n\\end{pmatrix} +\n\\begin{pmatrix}\n40 \\\\ 53\n\\end{pmatrix}\n\\end{pmatrix} =\n\\begin{pmatrix}\n30 \\\\ 44 \\\\ 61\n\\end{pmatrix}\n\\]\n\n\nТранспонирование\nМатрица \\(\\mathbf{A}^T\\) называется транспонированной к матрице \\(\\mathbf{A}\\), если элемент \\(a_{ij}\\) матрицы \\(\\mathbf{A}^T\\) равен элементу \\(a_{ji}\\) матрицы \\(\\mathbf{A}\\). Например\n\\[\n\\mathbf{A}=\n\\begin{pmatrix}\n1 & 4 \\\\\n2 & 5 \\\\\n3 & 6\n\\end{pmatrix}\n\\implies\n\\mathbf{A}^T=\n\\begin{pmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6\n\\end{pmatrix}\n\\]\n\n\n\n8.2.3 Определитель\nОпределитель матрицы обычно обозначается как \\(\\det{\\mathbf{A}}\\) или \\(|\\mathbf{A}|\\). Для квадратной матрицы \\(\\mathbf{A}\\) порядка \\(3\\)\n\\[\n\\mathbf{A}=\n\\begin{pmatrix}\na_{11} & a_{12} & a_{13} \\\\\na_{21} & a_{22} & a_{23} \\\\\na_{31} & a_{32} & a_{33}\n\\end{pmatrix}\n\\]\nто\n\\[\n|\\mathbf{A}|=\na_{11}(a_{22}a_{33} - a_{23}a_{32}) - a_{12}(a_{21}a_{33}-a_{31}a_{23}) + a_{13}(a_{21}a_{32} - a_{22}a_{31})\n\\]\nОпределитель обладает следующими свойствами\n\nЕсли все элементы какого-нибудь столбца или строки матрицы равны нулю, определитель этой матрицы равен нулю.\nОпределитель транспонированной матрицы равен определителю исходной матрицы, \\(|{\\mathbf{A}}^T|=|\\mathbf{A}|\\)\nЕсли матрица \\(\\mathbf{B}\\) получена из матрицы \\(\\mathbf{A}\\) путём перестановки двух каких либо строк (или двух столбцов), тогда \\(|\\mathbf{B}|=-|\\mathbf{A}|\\)\n\nЕсли две строки (или два столбца) в матрице одинаковы, то её определитель равен нулю.\nЗначение определителя \\(|\\mathbf{A}|\\) не изменяется, если какую-либо строку матрицы (столбец) умножить на скаляр \\(\\alpha\\) и затем прибавить её к другой строке (столбцу).\nЕсли каждый элемент какой-либо строки (столбца) умножить на скаляр \\(\\alpha\\), то значение определителя также будет умножено на это число \\(\\alpha\\).\nЕсли \\(\\mathbf{A}\\) и \\(\\mathbf{B}\\) – две квадратные матрицы порядка \\(n\\), то \\(|\\mathbf{AB}|=|\\mathbf{A}||\\mathbf{B}|\\)\n\n\n\n8.2.4 Обратная матрица\nЕсли \\(\\mathbf{B}\\) и \\(\\mathbf{C}\\) – две квадратные матрицы порядка \\(n\\), причём такие, что \\(\\mathbf{BC}=\\mathbf{CD}=I\\), тогда матрица \\(\\mathbf{B}\\) называется обратной к матрице \\(\\mathbf{C}\\), при этом матрица \\(\\mathbf{C}\\) также будет опратной к матрице \\(\\mathbf{B}\\). Обратные матрицы обозначаются как \\({\\mathbf{B}}^{-1}\\) и \\({\\mathbf{C}}^{-1}\\).\n\nТеорема 8.2 Если \\(\\mathbf{BC}=\\mathbf{I}\\) и \\(\\mathbf{B}\\) – невырожденная матрица, тогда \\(\\mathbf{C}={\\mathbf{B}}^{-1}\\), причём матрица \\(\\mathbf{C}\\) определяется единственным образом.\n\nОбратные матрицы находят применение при решении систем линейных уравнений. Рассмотрим систему из \\(т\\) линейных уравнений\n\\[\n\\begin{pmatrix}\na_{11} & a_{12} & \\cdots & a_{1n} \\\\\na_{21} & a_{22} & \\cdots & a_{2n} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{n1} & a_{n2} & \\cdots & a_{nn}\n\\end{pmatrix}\n\\begin{pmatrix}\nx_1 \\\\ x_2 \\\\ \\vdots \\\\ x_n\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nb_1 \\\\ b_2 \\\\ \\vdots \\\\ b_n\n\\end{pmatrix}\n\\]\nгде \\(x_i\\) – неизвестные, \\(a_{ij}\\) и \\(b_{i}\\) – заданные константы. Эта система и \\(n\\) уравнений в матричной форме запишется так: \\(\\mathbf{AB}=\\mathbf{b}\\). Поскольку уравнения системы линейно независимы, матрица \\(\\mathbf{A}\\) будет невырожденной, и, следовательно, будет существовать обратная к ней матрица. Таким образом,имеем\n\\[\n{\\mathbf{A}}^{-1}\\mathbf{AX}={\\mathbf{A}}^{-1}\\mathbf{b}\n\\]\nоткуда получаем решение системы: \\(\\mathbf{X}={\\mathbf{A}}^{-1}\\mathbf{b}\\).\n\nВычисление методом последовательных исключений (метод Гаусса–Жордана)\nРассмотрим блочную матрицу \\(\\mathbf{A}|\\mathbf{I}\\), где \\(\\mathbf{A}\\) – невырожденная матрица. Умножая слева эту матрицу на матрицу \\({\\mathbf{A}}^{-1}\\), получим\n\\[\n({\\mathbf{A}}^{-1}\\mathbf{A} | {\\mathbf{A}}^{-1} I) = (\\mathbf{I} | {\\mathbf{A}}^{-1})\n\\]\nТаким образом, при последовательном преобразовании строк исходной матрицы, обеспечивающем преобразование матрицы \\(\\mathbf{A}\\) в \\(\\mathbf{I}\\), одновременно матрица \\(\\mathbf{I}\\) преобразуется в матрицу \\({\\mathbf{A}}^{-1}\\). Как пример рассмотрим систему линейных уравнений\n\\[\n\\begin{pmatrix}\n1 & 2 & 3 \\\\\n2 & 3 & 2 \\\\\n3 & 3 & 4\n\\end{pmatrix}\n\\begin{pmatrix}\nx_1 \\\\ x_2 \\\\ x_3\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n3 \\\\ 4 \\\\ 5\n\\end{pmatrix}\n\\]\nВектор решений \\(\\mathbf{X}\\) и матрицу, обратную к матрице данной системы, можно получить из соотношения\n\\[\n{\\mathbf{A}}^{-1}(\\mathbf{A} | \\mathbf{I} | \\mathbf{b}) =\n(\\mathbf{I} | {\\mathbf{A}}^{-1} | {\\mathbf{A}}^{-1} \\mathbf{b} )\n\\]\nРеализация метода последовательных исключений приводит к следующей последовательности действий. Исходная матрица имеет вид\n\\[\n\\left( \\begin{array}{c | c |c}\n\\begin{matrix}\n1 & 2 & 3 \\\\\n2 & 3 & 2 \\\\\n3 & 3 & 4\n\\end{matrix}\n&\n\\begin{matrix}\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1\n\\end{matrix}\n&\n\\begin{matrix}\n3 \\\\ 4 \\\\ 5\n\\end{matrix}\n\\end{array}\\right)\n\\]\nИтерация 1\n\\[\n\\left( \\begin{array}{c | c | c}\n\\begin{matrix}\n1 & 2 & 3 \\\\\n0 & -1 & -4 \\\\\n0 & -3 & -5\n\\end{matrix}\n&\n\\begin{matrix}\n1 & 0 & 0 \\\\\n-2 & 1 & 0 \\\\\n-3 & 0 & 1\n\\end{matrix}\n&\n\\begin{matrix}\n3 \\\\ -2 \\\\ -4\n\\end{matrix}\n\\end{array}\\right)\n\\]\nИтерация 2\n\\[\n\\left( \\begin{array}{c | c | c}\n\\begin{matrix}\n1 & 0 & -5 \\\\\n0 & 1 & 4 \\\\\n0 & 0 & 7\n\\end{matrix}\n&\n\\begin{matrix}\n-3 & 2 & 0 \\\\\n2 & 1 & 0 \\\\\n3 & -3 & 1\n\\end{matrix}\n&\n\\begin{matrix}\n-1 \\\\ 2 \\\\ 2\n\\end{matrix}\n\\end{array}\\right)\n\\]\nИтерация 3\n\\[\n\\left( \\begin{array}{c | c | c}\n\\begin{matrix}\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1\n\\end{matrix}\n&\n\\begin{matrix}\n-\\frac{6}{7} & -\\frac{1}{7} & \\frac{5}{7} \\\\\n\\frac{2}{7} & \\frac{5}{7} & -\\frac{4}{7} \\\\\n\\frac{3}{7} & -\\frac{3}{7} & \\frac{1}{7}\n\\end{matrix}\n&\n\\begin{matrix}\n\\frac{3}{7} \\\\\n\\frac{6}{7} \\\\\n\\frac{2}{7}\n\\end{matrix}\n\\end{array}\\right)\n\\]\nВ результате получено решение системы: \\(x_1=\\frac{3}{7}\\), \\(x_2=\\frac{6}{7}\\), \\(x_3=\\frac{2}{7}\\). Обратная матрица \\({\\mathbf{A}}^{-1}\\) приведена справа от единичной матрицы.\n\n\nВычисление методом мультипликативного дополнения",
    "crumbs": [
      "Линейное программирование",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Элементы линейной алгебры</span>"
    ]
  },
  {
    "objectID": "linear/algebra.html#sec-linear-algebra-equation-system",
    "href": "linear/algebra.html#sec-linear-algebra-equation-system",
    "title": "8  Элементы линейной алгебры",
    "section": "8.3 Система линейных алгебраических уравнений",
    "text": "8.3 Система линейных алгебраических уравнений\n\n8.3.1 Случай двух переменных\n\nНесовместимость системы\n\\[\n\\begin{pmatrix}\n1 & -1 \\\\\n0 & 0\n\\end{pmatrix}\n\\begin{pmatrix}\nx_1 \\\\ x_2\n\\end{pmatrix} =\n\\begin{pmatrix}\n-1 \\\\ 2\n\\end{pmatrix} \\\\\n\\begin{aligned}\nx_1 - x_2 &= -1 \\\\\n0 &= 2\n\\end{aligned}\n\\]\n\n\nЕдинственное решение\n\\[\n\\begin{pmatrix}\n1 & -1 \\\\\n1 & 2\n\\end{pmatrix}\n\\begin{pmatrix}\nx_1 \\\\ x_2\n\\end{pmatrix} =\n\\begin{pmatrix}\n-1 \\\\ 2\n\\end{pmatrix} \\\\\n\\begin{aligned}\nx_1 &= 0\\\\\nx_2 &= 1\n\\end{aligned}\n\\]\n\n\n\n\n\n\n\n\nБесконечное множество решений\n\\[\n\\begin{pmatrix}\n1 & -1 \\\\\n0 & 0\n\\end{pmatrix}\n\\begin{pmatrix}\nx_1 \\\\ x_2\n\\end{pmatrix} =\n\\begin{pmatrix}\n-1 \\\\ 0\n\\end{pmatrix} \\\\\n\\begin{aligned}\nx_1 - x_2 &= -1 \\\\\n0 &= 0\n\\end{aligned}\n\\]\n\n\n\n\n\n\n\n\nОтсутствие решений\n\\[\n\\begin{pmatrix}\n1 & -1 \\\\\n1 & -1\n\\end{pmatrix}\n\\begin{pmatrix}\nx_1 \\\\ x_2\n\\end{pmatrix} =\n\\begin{pmatrix}\n-1 \\\\ 2\n\\end{pmatrix} \\\\\n\\begin{aligned}\nx_1 - x_2 &= -1 \\\\\n0 &= 3\n\\end{aligned}\n\\]\n\n\n\n8.3.2 Случай n переменных. Метод Гаусса — Жордана\n\nАлгоритм\n\n\nПример\n\n\n\n\n1. Eager E. Linear Algebra for Data Science in R [Электронный ресурс]. 2021. URL: https://rpubs.com/odenipinedo/linear-algebra-for-data-science-in-R (дата обращения: 20.02.2025).\n\n\n2. Гольштейн Евгений Григорьевич Ю.Д.Б. Математические основы и практические задачи. стереотипное. Москва: ЛЕНАНД, 2022. Т. 1. С. 320.\n\n\n3. А. Т.Х. Исследование операций. 10-е изд. / под ред. Слепцова А.В. Санкт-Петербург: ООО \"Диалектика\", 2019. С. 1056.",
    "crumbs": [
      "Линейное программирование",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Элементы линейной алгебры</span>"
    ]
  },
  {
    "objectID": "linear/graphical-solution.html",
    "href": "linear/graphical-solution.html",
    "title": "9  Графическое решение",
    "section": "",
    "text": "Состояние разработки\n\n\n\nТребуется доработка\n\n\n\\[\\begin{cases}\n      \\max{F(x)=2x_1+6x_2}\\\\\n      x_1+4x_2\\leq2048\\\\\n      2x_1+x_2\\leq2048\\\\\n      x2\\leq480\\\\\n      x1,x2\\geq0\n\\end{cases}\\]\nЗадача 1 найти область удовлетворяющую ограничениям. Сразу можно сказать, что рассматривается первая четверть из-за ограничения на положительность переменных. Определим функцию для построения замкнутой области на графике используя библиотеку plotly.\n\n\n\n\n\n\nИтоговая область поиска:\n\n\n\n\n\n\nТеперь можно добавить график уровня функции и совместить его с графиком ограничений\n\n\n\n\n\n\nСледовательно наилучшее значение функции в точке \\((x=\\frac{6144}{7},y=\\frac{2048}{7})\\)",
    "crumbs": [
      "Линейное программирование",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Графическое решение</span>"
    ]
  },
  {
    "objectID": "linear/sensetivity.html",
    "href": "linear/sensetivity.html",
    "title": "10  Анализ чувствительности оптимального решения",
    "section": "",
    "text": "10.1 Изменения целевой функции",
    "crumbs": [
      "Линейное программирование",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Анализ чувствительности оптимального решения</span>"
    ]
  },
  {
    "objectID": "linear/sensetivity.html#sec-linear-sensetivity-constraint",
    "href": "linear/sensetivity.html#sec-linear-sensetivity-constraint",
    "title": "10  Анализ чувствительности оптимального решения",
    "section": "10.2 Изменения правых частей неравенств ограничений",
    "text": "10.2 Изменения правых частей неравенств ограничений\n```{r}\noptimum$duals.from\noptimum$duals.to\n```\nРассмотрим первое ограничение \\(x_1+4x_2\\leq2048\\). Значение \\(\\xi_1=1.4285\\) показывает насколько изменится целевая функция, если значение ограничения увеличится на одну единицу. Значение \\(xi\\) ненулевое, только если ограничение активно. \\(\\xi\\) можно интерпретировать как частную производную целевой функции по правой части неравенства ограничения. \\(\\xi_1=\\frac{\\partial F}{\\partial B_1}\\). Следовательно при изменении ограничения \\(\\xi_i\\) в пределах от \\(\\xi_{from}\\) до \\(\\xi_{till}\\) значение целевой функции изменится как \\(F=F_0+\\Delta B_i \\xi_i\\)\nЗначение \\(\\xi_i\\) дает очень хорошее представление о том, сколько стоит это ограничение. Если значение \\(\\xi_i\\) большое, то это ограничение сильно влияет на целевую функцию. Небольшие изменения ограничения (ослабление) позволит значительно улучшить значение целевой функции. Также имеет значение знак \\(\\xi_i\\). Положительное значение означает, что по мере увеличения ограничения значение целевой функции будет больше, а по мере того, как оно становится более отрицательным, значение целевой функции будет меньше.",
    "crumbs": [
      "Линейное программирование",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Анализ чувствительности оптимального решения</span>"
    ]
  },
  {
    "objectID": "linear/simplex-spec.html",
    "href": "linear/simplex-spec.html",
    "title": "11  Особые случаи применения симплекс метода",
    "section": "",
    "text": "11.1 Альтернативные решения\n\\[\\begin{cases}\n      \\max{F(x)=x_1+2x_2}\\\\\n      x_1\\leq80\\\\\n      5x_1+6x_2\\leq600\\\\\n      x_1+2x_2\\leq160\\\\\n      x1,x2\\geq0\n\\end{cases}\\]\nИзобразим область поиска соответствующую ограничениям\nТеперь можно добавить график уровня функции и совместить его с графиком ограничений\nИз графика следует то, что прямая постоянного уровня целевой функции \\(F(x)=x_1+2x_2\\) совпала с прямой задающей ограничение \\(x_1+2x_2\\leq160\\). Значит все точки принадлежащие прямой проходящей через координаты \\(P(0,80)\\) и \\(Q(60,50)\\) будут соответствовать оптимальному решению.\nlibrary(lpSolve)\nFun &lt;- c(1, 2)\nA &lt;- rbind(c(0, 1), c(5, 6), c(1, 2))\nB &lt;- c(80, 600, 160)\nCD &lt;- c('&lt;=', '&lt;=', '&lt;=')\n\noptimum &lt;- lp(\n  direction = 'max',\n  objective.in = Fun,\n  const.mat = A,\n  const.dir = CD,\n  const.rhs = B,\n  compute.sens = TRUE)\n\noptimum\n\nSuccess: the objective function is 160 \n\noptimum$solution\n\n[1]  0 80\nПроцедура поиска решения находит только одну точку.\noptimum$sens.coef.from\n\n[1] -1e+30  2e+00\n\noptimum$sens.coef.to\n\n[1] 1e+00 1e+30\nАнализ чувствительности показывает, что активно только ограничение \\(x_1+2x_2\\leq160\\), а соответствующее значенеи \\(\\xi=1\\)\noptimum$duals\n\n[1] 0 0 1 0 0\n\noptimum$duals.from\n\n[1]  5.0e+01 -1.0e+30  1.6e+02 -1.0e+30 -1.0e+30\n\noptimum$duals.to\n\n[1] 8.00e+01 1.00e+30 1.84e+02 1.00e+30 1.00e+30",
    "crumbs": [
      "Линейное программирование",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Особые случаи применения симплекс метода</span>"
    ]
  },
  {
    "objectID": "linear/simplex-spec.html#отсутствие-допустимых-решений",
    "href": "linear/simplex-spec.html#отсутствие-допустимых-решений",
    "title": "11  Особые случаи применения симплекс метода",
    "section": "11.2 Отсутствие допустимых решений",
    "text": "11.2 Отсутствие допустимых решений\nВ данном случае условия ограничений не совместимы.\n\\[\\begin{cases}\n      \\max{F(x)=200x_1+300x_2}\\\\\n      2x_1+3x_2\\geq1200\\\\\n      x_1+x_2\\leq400\\\\\n      2x_1+1.5x_2\\geq900\\\\\n      x1,x2\\geq0\n\\end{cases}\\]\n\n\n\n\n\n\n\nlibrary(lpSolve)\nFun &lt;- c(200, 300)\nA &lt;- rbind(c(2, 3), c(1, 2), c(2, 1.5))\nB &lt;- c(1200, 400, 900)\nCD &lt;- c('&gt;=', '&lt;=', '&gt;=')\n\noptimum &lt;- lp(\n  direction = 'max',\n  objective.in = Fun,\n  const.mat = A,\n  const.dir = CD,\n  const.rhs = B,\n  compute.sens = TRUE)\n\noptimum\n\nError: no feasible solution found\n\noptimum$solution\n\n[1] 0 0\n\n\nПроцедура поиска решения завершается с ошибкой",
    "crumbs": [
      "Линейное программирование",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Особые случаи применения симплекс метода</span>"
    ]
  },
  {
    "objectID": "linear/simplex-spec.html#неограниченность-решений",
    "href": "linear/simplex-spec.html#неограниченность-решений",
    "title": "11  Особые случаи применения симплекс метода",
    "section": "11.3 Неограниченность решений",
    "text": "11.3 Неограниченность решений\nЕсли область поиска решения не ограничена, то одна или несколько переменных будут увеличиваться бесконечно, не нарушая ограничений, а значение целевой функции можно принимать произвольно большие значения. Рассмотрим следующую модель:\n\\[\\begin{cases}\n      \\max{F(x)=40x_1+60x_2}\\\\\n      2x_1+x_2\\geq70\\\\\n      x_1+x_2\\geq40\\\\\n      x_1+3x_2\\geq90\\\\\n      x1,x2\\geq0\n\\end{cases}\\]\n\n\n\n\n\n\nОбъединяя добавляя контурный график\n\n\n\n\n\n\nОграничения заданные в этом примере не ограничивают область поиска в направлениии \\(x\\to\\infty\\) и \\(y\\to\\infty\\). Целевая функция неограниченно возрастает в этом направлении, следовательно и решение неограниченно.\n\nlibrary(lpSolve)\nFun &lt;- c(40, 60)\nA &lt;- rbind(c(2, 1), c(1, 1), c(1, 3))\nB &lt;- c(70, 40, 90)\nCD &lt;- c('&gt;=', '&gt;=', '&gt;=')\n\noptimum &lt;- lp(\n  direction = 'max',\n  objective.in = Fun,\n  const.mat = A,\n  const.dir = CD,\n  const.rhs = B,\n  compute.sens = TRUE)\n\noptimum\n\nError: status 3 \n\noptimum$solution\n\n[1] 0 0\n\n\nПроцедура поиска решения завершается с ошибкой 3: UNBOUNDED (3) The model is unbounded.",
    "crumbs": [
      "Линейное программирование",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Особые случаи применения симплекс метода</span>"
    ]
  },
  {
    "objectID": "linear/simplex-spec.html#вырожденность",
    "href": "linear/simplex-spec.html#вырожденность",
    "title": "11  Особые случаи применения симплекс метода",
    "section": "11.4 Вырожденность",
    "text": "11.4 Вырожденность",
    "crumbs": [
      "Линейное программирование",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Особые случаи применения симплекс метода</span>"
    ]
  },
  {
    "objectID": "nonlinear/unconstrained/analytical-one.html",
    "href": "nonlinear/unconstrained/analytical-one.html",
    "title": "12  Безусловная оптимизация функции одной переменной",
    "section": "",
    "text": "12.1 Определение\n[1] [2]",
    "crumbs": [
      "Нелинейное программирование",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Безусловная оптимизация функции одной переменной</span>"
    ]
  },
  {
    "objectID": "nonlinear/unconstrained/analytical-one.html#sec-nonlinear-unconstrained-one-def",
    "href": "nonlinear/unconstrained/analytical-one.html#sec-nonlinear-unconstrained-one-def",
    "title": "12  Безусловная оптимизация функции одной переменной",
    "section": "",
    "text": "Определение 12.1  \n\nТочкой локального максимума\n\nфункции \\(f(x)\\) называется точка \\(x_0\\), если существует такая окрестность этой точки, что для всех \\(x\\) из этой окрестности выполняется неравенство: \\(f(x) &lt; f\\left(x_{0}\\right)\\).\n\n\n\n\nОпределение 12.2  \n\nТочкой локального минимума\n\nфункции \\(f(x)\\) называется точка \\(x_0\\) , если существует такая окрестность этой точки, что для всех \\(x\\) из этой окрестности выполняется неравенство: \\(f(x) &gt; f\\left(x_{0}\\right)\\).",
    "crumbs": [
      "Нелинейное программирование",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Безусловная оптимизация функции одной переменной</span>"
    ]
  },
  {
    "objectID": "nonlinear/unconstrained/analytical-one.html#sec-nonlinear-unconstrained-one-criteria",
    "href": "nonlinear/unconstrained/analytical-one.html#sec-nonlinear-unconstrained-one-criteria",
    "title": "12  Безусловная оптимизация функции одной переменной",
    "section": "12.2 Критерий",
    "text": "12.2 Критерий\n\nТеорема 12.1 (Необходимое условие) Если функция \\(y=f(x)\\) имеет экстремум в точке \\(x_{0}\\), то ее производная \\(f^{\\prime}\\left(x_{0}\\right)\\) либо равна нулю, либо не существует.\nТочки, в которых производная равна нулю: \\(f^{\\prime}(x)=0\\), называются стационарными точками функции.\nТочки, в которых выполняется необходимое условие экстремума для непрерывной функции, называются критическими точками этой функции. То есть критические точки - это либо стационарные точки (решения уравнения \\(f^{\\prime}(x)=0\\)), либо это точки, в которых производная \\(f^{\\prime}(x)\\) не существует.\n\n\n\n\n\n\nУведомление\n\n\n\nНе в каждой своей критической точке функция обязательно имеет максимум или минимум.\n\n\n\n\nТеорема 12.2 (Первое достаточное условие) Пусть для функции \\(y=f(x)\\) выполнены следующие условия:\n\nфункция непрерывна в окрестности точки \\(x_{0}\\)\n\\(f^{\\prime}\\left(x_{0}\\right)=0\\) или \\(f^{\\prime}\\left(x_{0}\\right)\\) не существует\nпроизводная \\(f^{\\prime}(x)\\) при переходе через точку \\(x_{0}\\) меняет свой знак.\n\nТогда в точке \\(x=x_{0}\\) функция \\(y=f(x)\\) имеет экстремум, причем это\n\nминимум, если при переходе через точку \\(x_{0}\\) производная меняет свой знак с минуса на плюс;\nмаксимум, если при переходе через точку \\(x_{0}\\) производная меняет свой знак с плюса на минус.\n\n\n\nПример 12.1 Исследовать функцию \\(y(x)=x^{4}-1\\) на экстремум.\n\n\nРешение 12.1. Находим производную заданной функции:\n\\[y^{\\prime}=\\left(x^{4}-1\\right)^{\\prime}=4 x^{3}\\]\nДалее ищем критические точки функции, для этого решаем уравнение \\(y^{\\prime}(x)=0\\):\n\\[y^{\\prime}=4 x^{3}=0 \\Rightarrow x=0\\]\n\n\n\n\n\n\nПервая производная определена во всех точках. Таким образом, имеем одну критическую точку \\(x=0\\). Наносим эту точку на координатную прямую и исследуем знак производной слева и справа от этой точки (для этого из каждого промежутка берем произвольное значение и находим значение производной в выбранной точке, определяем знак полученной величины):\nТак как при переходе через точку \\(x=0\\) производная сменила свой знак с \\(-\\) на \\(+\\), то в этой точке функция достигает минимума (или минимального значения), причем \\(y_{\\min }=y(0)=0^{4}-1=-1\\).\nЗамечание. Также можно определить интервалы монотонности функции: так как на интервале \\((-\\infty ; 0)\\) производная \\(y^{\\prime}(x) &lt; 0\\), то на этом интервале функция \\(y(x)=x^{4}-1\\) является убывающей; на интервале \\((0 ;+\\infty)\\) производная \\(y^{\\prime}(x)&gt;0\\), значит заданная функция возрастает на нем.\nОтвет: \\(y_{\\min }=y(0)=-1\\)\n\n\nТеорема 12.3 (Второе достаточное условие) Пусть для функции \\(y=f(x)\\) выполнены следующие условия:\n\nона непрерывна в окрестности точки \\(x_{0}\\)\nпервая производная \\(f^{\\prime}(x)=0\\) в точке \\(x_{0}\\)\n\\(f^{\\prime \\prime}(x) \\neq 0\\) в точке \\(x_{0}\\).\n\nТогда в точке \\(x_{0}\\) достигается экстремум, причем\n\nесли \\(f^{\\prime \\prime}\\left(x_{0}\\right)&gt;0\\), то в точке \\(x=x_{0}\\) функция \\(y=f(x)\\) имеет минимум;\nесли \\(f^{\\prime \\prime}\\left(x_{0}\\right) &lt; 0\\), то в точке \\(x=x_{0}\\) функция \\(y=f(x)\\) достигает максимум.\n\n\n\nПример 12.2 Исследовать функцию \\(y(x)=\\frac{x^{2}-1}{x^{2}+1}\\) на экстремум с помощью второй производной.\n\n\nРешение 12.2. Находим первую производную заданной функции:\n\\[y^{\\prime}(x)=\\left(\\frac{x^{2}-1}{x^{2}+1}\\right)^{\\prime}=\\frac{2 x\\left(x^{2}+1\\right)-\\left(x^{2}-1\\right) \\cdot 2 x}{\\left(x^{2}+1\\right)^{2}}=\\frac{4 x}{\\left(x^{2}+1\\right)^{2}}\\]\nНаходим точки, в которых первая производная равна нулю:\n\\[y^{\\prime}(x)=0 \\Rightarrow \\frac{4 x}{\\left(x^{2}+1\\right)^{2}}=0 \\Rightarrow x=0\\]\nВторая производная заданной функции:\n\\[y^{\\prime \\prime}(x)=\\left(\\frac{4 x}{\\left(x^{2}+1\\right)^{2}}\\right)^{\\prime}=\\frac{4\\left(x^{2}+1\\right)^{2}-4 x \\cdot 2\\left(x^{2}+1\\right) \\cdot 2 x}{\\left(x^{2}+1\\right)^{4}}=\\]\n\\[=-\\frac{4\\left(3 x^{2}-1\\right)}{\\left(x^{2}+1\\right)^{3}}\\]\n\n\n\n\n\n\nВ стационарной точке \\(x=0\\) вторая производная \\[y^{\\prime \\prime}(0)=-\\frac{4 \\cdot(-1)}{1^{3}}=4&gt;0\\]\nзначит, в этой точке функция достигает минимум, причем\n\\[y_{\\min }=y(0)=\\frac{0^{2}-1}{0^{2}+1}=-1\\]\nОтвет \\(y_{\\min }=y(0)=-1\\)",
    "crumbs": [
      "Нелинейное программирование",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Безусловная оптимизация функции одной переменной</span>"
    ]
  },
  {
    "objectID": "nonlinear/unconstrained/analytical-one.html#sec-nonlinear-unconstrained-one-derivatives",
    "href": "nonlinear/unconstrained/analytical-one.html#sec-nonlinear-unconstrained-one-derivatives",
    "title": "12  Безусловная оптимизация функции одной переменной",
    "section": "12.3 Таблица производных",
    "text": "12.3 Таблица производных\n\n\n\nТаблица 12.1: Таблица производных\n\n\n\n\n\n\\(F(x)\\)\n\\(F'(x)=\\frac{dF}{dx}\\)\n\n\n\n\n\\(a f(x)+b g(x)\\)\n\\(a f'(x)+b g'(x)\\)\n\n\n\\(f(x)+g(x)\\)\n\\(f'(x)+g'(x)\\)\n\n\n\\(f(x)-g(x)\\)\n\\(f'(x)-g'(x)\\)\n\n\n\\(a f(x)\\)\n\\(a f'(x)\\)\n\n\n\\(f(x) g(x)\\)\n\\(f'(x) g(x) + f(x) g'(x)\\)\n\n\n\\(f(x) g(x) h(x)\\)\n\\(f'(x)g(x)h(x)+ f(x)g'(x)h(x) + f(x)g(x)h'(x)\\)\n\n\n\\(f(g(x))\\)\n\\(f'(g(x)) g'(x)\\)\n\n\n\\(a,\\ const\\)\n\\(0\\)\n\n\n\\(x^a\\)\n\\(a x^{n-1}\\)\n\n\n\\(g(x)^a\\)\n\\(ag(x)^{a-1}g'(x)\\)\n\n\n\\(\\sin{x}\\)\n\\(\\cos{x}\\)\n\n\n\\(\\sin{g(x)}\\)\n\\(g'(x) \\cos{g(x)}\\)\n\n\n\\(\\cos{x}\\)\n\\(-\\sin{x}\\)\n\n\n\\(\\tan{x}\\)\n\\(\\frac{1}{\\cos^2{x}}\\)\n\n\n\\(e^x\\)\n\\(e^x\\)\n\n\n\\(e^{g(x)}\\)\n\\(g'(x) e^{g(x)}\\)\n\n\n\\(a^x\\)\n\\(a^x \\ln{a}\\)\n\n\n\\(\\ln{x}\\)\n\\(\\frac{1}{x}\\)\n\n\n\\(\\ln{g(x)}\\)\n\\(\\frac{g'(x)}{g(x)}\\)\n\n\n\\(\\log_a{x}\\)\n\\(\\frac{1}{x \\ln{a}}\\)\n\n\n\\(\\arcsin{x}\\)\n\\(\\frac{1}{\\sqrt{1-x^2}}\\)\n\n\n\\(\\arcsin{g(x)}\\)\n\\(\\frac{g'(x)}{\\sqrt{1-g(x)^2}}\\)\n\n\n\\(\\arccos{x}\\)\n\\(-\\frac{1}{\\sqrt{1-x^2}}\\)\n\n\n\\(\\arctan{x}\\)\n\\(\\frac{1}{1+x^2}\\)\n\n\n\\(\\arctan{g(x)}\\)\n\\(\\frac{g'(x)}{1+g(x)^2}\\)\n\n\n\n\n\n\n\n\n\n\n1. Емелин А. Возрастание, убывание и экстремумы функции [Электронный ресурс]. URL: http://mathprofi.ru/vozrastanie_ubyvanie_ekstremumy_funkcii.html (дата обращения: 20.02.2025).\n\n\n2. Понятие экстремума функции [Электронный ресурс]. URL: https://www.webmath.ru/poleznoe/formules_8_22.php (дата обращения: 20.02.2025).",
    "crumbs": [
      "Нелинейное программирование",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Безусловная оптимизация функции одной переменной</span>"
    ]
  },
  {
    "objectID": "nonlinear/unconstrained/analytical-many.html",
    "href": "nonlinear/unconstrained/analytical-many.html",
    "title": "13  Безусловная оптимизация функции многих переменных",
    "section": "",
    "text": "13.1 Определение\n[1]\nНапример для функции \\(f(x,y)=(x-1)^2 +(y+2)^2\\) точка \\(M(x_0=1,y_0=-2)\\) будет точкой локального минимума",
    "crumbs": [
      "Нелинейное программирование",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Безусловная оптимизация функции многих переменных</span>"
    ]
  },
  {
    "objectID": "nonlinear/unconstrained/analytical-many.html#sec-nonlinear-unconstrained-many-defenition",
    "href": "nonlinear/unconstrained/analytical-many.html#sec-nonlinear-unconstrained-many-defenition",
    "title": "13  Безусловная оптимизация функции многих переменных",
    "section": "",
    "text": "Определение 13.1  \n\nТочкой локального максимума\n\nназывается такая точка \\(M_0(x_0,y_0,...)\\), что в некоторой \\(\\delta\\)-окрестности этой точки выполняется неравенство \\(f(x,y,...) &lt; f(x_0,y_0,...)\\).\n\n\n\n\nОпределение 13.2  \n\nТочкой локального минимума\n\nназывается такая точка \\(M_0(x_0,y_0,...)\\), что в некоторой \\(\\delta\\)-окрестности этой точки выполняется неравенство \\(f(x,y,...) &gt; f(x_0,y_0,...)\\).",
    "crumbs": [
      "Нелинейное программирование",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Безусловная оптимизация функции многих переменных</span>"
    ]
  },
  {
    "objectID": "nonlinear/unconstrained/analytical-many.html#sec-nonlinear-unconstrained-many-2vars",
    "href": "nonlinear/unconstrained/analytical-many.html#sec-nonlinear-unconstrained-many-2vars",
    "title": "13  Безусловная оптимизация функции многих переменных",
    "section": "13.2 Экстремум функции двух переменных",
    "text": "13.2 Экстремум функции двух переменных\n\nТеорема 13.1 (Необходимое условие) Если дифференцируемая функция имеет экстремум в точке , то обе частные производные 1-го порядка в данной точке равны нулю:\n\\[\n\\frac{\\partial F(x,y)}{\\partial x}=0 \\qquad\n\\frac{\\partial F(x,y)}{\\partial y}=0\n\\]\n\n\nОпределение 13.3  \n\nСтационарной точкой\n\nназывается точка. удовлетворяющая этим условиям. Также эту точку называют критической.\n\n\n\nНо у функции с производными , равными нулю в этой же точке, не наблюдается ничего подобного. Это гиперболический параболоид или «седло» Для точки не существует окрестности, в которой поверхность располагалась бы только вверху или только внизу .\n\n\n\n\n\n\n\nОпределение 13.4  \n\nСледовой точкой\n\nназывается точку такого рода.\n\n\n\n\nПример 13.1 Исследовать на экстремум функцию\n\\[z=3x^2 + xy + 2y^2 -x -4y\\]\n\n\nРешение 13.1. на первом шаге нужно отыскать стационарные точки. Для этого найдем частные производные 1-го порядка:\n\\[\n\\begin{aligned}\n&\\frac{\\partial z}{\\partial x}=\\frac{\\partial}{\\partial x}\\bigl(3x^2+xy+2y^2-x-4y \\bigr)=6x+y-1 \\\\\n&\\frac{\\partial z}{\\partial x}=\\frac{\\partial}{\\partial x}\\bigl(3x^2+xy+2y^2-x-4y \\bigr)=x+4y-4\n\\end{aligned}\n\\]\nРешим систему уравнений\n\\[\n\\begin{cases}\n\\frac{\\partial z}{\\partial x}=0\\\\\n\\frac{\\partial z}{\\partial y}=0\n\\end{cases}\\,\n\\Rightarrow\n\\begin{cases}\n6x+y-1=0\\\\\nx+4y-1=0\n\\end{cases}\\,\n\\]\n\n\n\n\n\n\nТаким образом\n\\[\n\\begin{aligned}\ny=1\\\\\nx=0\n\\end{aligned}\n\\]\nНайдена стационарная точка \\(M_0(0,1)\\). В найденной точке может быть минимум, максимум либо перевал.\n\n\nТеорема 13.2 (Достаточное условие) Для применения достаточного условия нужно вычислить частные производные 2-го порядка в точке Для компактности обычно используют следующие обозначения\n\\[\n\\begin{aligned}\n&A=\\frac{\\partial^2 z}{\\partial x^2}\\\\\n&B=\\frac{\\partial^2 z}{\\partial x \\partial y}\\\\\n&C=\\frac{\\partial^2 z}{\\partial x^2}\\\\\n\\end{aligned}\n\\]\n\nЕсли \\(AC-B^2&gt;0\\), то функция \\(z=f(x,y)\\) имеет экстремум в точке \\(M_0\\), причём, если \\(A&gt;0\\), то это минимум, а если \\(A&lt;0\\) – то максимум.\nЕсли \\(AC-B^2&lt;0\\), то в точке \\(M_0\\) нет экстремума.\nЕсли \\(AC-B^2=0\\), то требуется дополнительное исследование.\n\n\n\nПример 13.2 Определить тип стационарной точки \\(M_0(0,1)\\) для функции \\[z=3x^2 + xy + 2y^2 -x -4y\\]\n\n\nРешение 13.2. Найдем все вторые частные производные.\n\\[\n\\begin{aligned}\n&\\frac{\\partial^2 z}{\\partial x^2}=\\frac{\\partial z}{\\partial x} \\bigl(6x+y-1\\bigr)=A=6\\\\\n&\\frac{\\partial^2 z}{\\partial x \\partial y}=\\frac{\\partial z}{\\partial y} \\bigl(6x+y-1\\bigr)=B=1\\\\\n&\\frac{\\partial^2 z}{\\partial y^2}=\\frac{\\partial z}{\\partial x} \\bigl(x+4y-4\\bigr)=C=4\n\\end{aligned}\n\\]\nТаким образом \\(AC-B^2=6\\cdot 4-1^2=23&gt;0\\), следовательно в точке \\(M_0\\) есть экстремум, и так как \\(A&gt;0\\), то это минимум. Ответ \\(\\min{z}=z(0,1)=-2\\).",
    "crumbs": [
      "Нелинейное программирование",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Безусловная оптимизация функции многих переменных</span>"
    ]
  },
  {
    "objectID": "nonlinear/unconstrained/analytical-many.html#sec-nonlinear-unconstrained-many-3vars",
    "href": "nonlinear/unconstrained/analytical-many.html#sec-nonlinear-unconstrained-many-3vars",
    "title": "13  Безусловная оптимизация функции многих переменных",
    "section": "13.3 Экстремумы трёх переменных",
    "text": "13.3 Экстремумы трёх переменных\n\nТеорема 13.3 (Необходимое условие) Как и для функции двух переменных общий вид необходимых условий сохраняется.\n\\[\n\\frac{\\partial F(x,y,z)}{\\partial x}=0 \\qquad\n\\frac{\\partial F(x,y,z)}{\\partial y}=0 \\qquad\n\\frac{\\partial F(x,y,z)}{\\partial z}=0\n\\]\n\n\nПример 13.3 Найти стационарные точки функции\n\\[\nu=-x^2-5y^2-3z^2+xy-2xz+2yz+11x+2y+18z+10\n\\]\n\nГрафик сечений\n\n\n\n\n\n\n\n\nРешение 13.3. Найдем все первые частные производные\n\\[\n\\begin{aligned}\n&\\frac{\\partial u}{\\partial x}=-2x+y-2z+11\\\\\n&\\frac{\\partial u}{\\partial y}=-10y+x+2z+2\\\\\n&\\frac{\\partial u}{\\partial z}=-6z-2x+2y+18\n\\end{aligned}\n\\]\nЧтобы найти стационарные точки, составим и решим следующую систему\n\\[\n\\begin{cases}\n\\frac{\\partial u}{\\partial x}=0\\\\\n\\frac{\\partial u}{\\partial y}=0\\\\\n\\frac{\\partial u}{\\partial z}=0\\\\\n\\end{cases}\\,\n\\Rightarrow\n\\begin{cases}\n-2x+y-2z+11=0\\\\\n-10y+x+2z+2=0\\\\\n-6z-2x+2y+18=0\n\\end{cases}\\,\n\\]\nТаким образом\n\\[\n\\begin{aligned}\n&x=4\\\\\n&y=1\\\\\n&z=2\n\\end{aligned}\n\\]\nНайдена единственная стационарная точка \\(M_0(4,1,2)\\)\n\n\nТеорема 13.4 (Достаточное условие) Для проверки достаточное условия требуется построить матрицу Гессе, состоящую из всех частных производных второго порядка\n\\[\nH =\n\\begin{pmatrix}\n\\frac{\\partial^2 u(M_0)}{\\partial x^2} & \\frac{\\partial^2 u(M_0)}{\\partial x \\partial y} & \\frac{\\partial^2 u(M_0)}{\\partial x \\partial z} \\\\\n\\frac{\\partial^2 u(M_0)}{\\partial y \\partial x} & \\frac{\\partial^2 u(M_0)}{\\partial y^2}  & \\frac{\\partial^2 u(M_0)}{\\partial y \\partial z} \\\\\n\\frac{\\partial^2 u(M_0)}{\\partial z \\partial x} &  \\frac{\\partial^2 u(M_0)}{\\partial y \\partial z} & \\frac{\\partial^2 u(M_0)}{\\partial z^2}\n\\end{pmatrix}\n\\]\nДанная матрица является симметричной (или симметрической). Это значит, что её элементы симметричны относительно главной диагонали, на которой в данном случае расположены «однобуквенные» частные производные\nДалее нужно вычислить угловые миноры. Это определители, которые «разрастаются» из левого верхнего угла:\n\\[\n\\delta_1=\\frac{\\partial^2 u(M_0)}{\\partial x^2}, \\qquad\n\\delta_2=\n\\begin{vmatrix}\n\\frac{\\partial^2 u(M_0)}{\\partial x^2} & \\frac{\\partial^2 u(M_0)}{\\partial x \\partial y} \\\\\n\\frac{\\partial^2 u(M_0)}{\\partial y \\partial x} & \\frac{\\partial^2 u(M_0)}{\\partial y^2}\n\\end{vmatrix}, \\qquad\n\\delta_3=\n\\begin{vmatrix}\n\\frac{\\partial^2 u(M_0)}{\\partial x^2} & \\frac{\\partial^2 u(M_0)}{\\partial x \\partial y} & \\frac{\\partial^2 u(M_0)}{\\partial x \\partial z} \\\\\n\\frac{\\partial^2 u(M_0)}{\\partial y \\partial x} & \\frac{\\partial^2 u(M_0)}{\\partial y^2}  & \\frac{\\partial^2 u(M_0)}{\\partial y \\partial z} \\\\\n\\frac{\\partial^2 u(M_0)}{\\partial z \\partial x} &  \\frac{\\partial^2 u(M_0)}{\\partial y \\partial z} & \\frac{\\partial^2 u(M_0)}{\\partial z^2}\n\\end{vmatrix}\n\\] 1. Если \\(\\delta_1&gt;0,\\quad \\delta_2&gt;0,\\quad \\delta_3&gt;0\\), то функция \\(u=f(x,y,z)\\) достигает минимума в точке \\(M_0\\) 2. Если \\(\\delta_1&lt;0,\\quad \\delta_2&gt;0,\\quad \\delta_3&lt;0\\) (так и только так!), то функция \\(u=f(x,y,z)\\) достигает максимума в точке \\(M_0\\). 3. Если получилось что-то другое и при этом \\(\\delta_3=|H|\\neq0\\), то \\(M_0\\) – следовая точка. Здесь это уже во многом условное название. 4. Если \\(\\delta_3=|H|=0\\), то признак не даёт ответа о характере точки \\(M_0\\).\n\n\nПример 13.4 Определить тип стационарной точки \\(M_0(4,1,2)\\) для функции\n\\[\nu=-x^2-5y^2-3z^2+xy-2xz+2yz+11x+2y+18z+10\n\\]\n\n\nРешение 13.4. В нашем примере все производные 2-го порядка равны константам\n\\[\n\\begin{aligned}\n&\\frac{\\partial^2 u}{\\partial x^2}=-2\\\\\n&\\frac{\\partial^2 u}{\\partial y^2}=-10\\\\\n&\\frac{\\partial^2 u}{\\partial z^2}=-6\\\\\n&\\frac{\\partial^2 u}{\\partial x \\partial y}=1\\\\\n&\\frac{\\partial^2 u}{\\partial x \\partial z}=-2\\\\\n&\\frac{\\partial^2 u}{\\partial y \\partial z}=2\\\\\n\\end{aligned}\n\\]\nСоставим матрицу Гессе\n\\[\nH=\n\\begin{pmatrix}\n-2 & 1 & -2\\\\\n1 & -10 & 2\\\\\n-2 & 2 & -6\n\\end{pmatrix}\n\\]\nи вычислим её угловые миноры\n\\[\n\\begin{aligned}\n&\\delta_1=2&lt;0\\\\\n&\\delta_2=\n\\begin{vmatrix}\n-2 & 1\\\\\n1 & -10\n\\end{vmatrix}=19&gt;0\\\\\n&\\delta_3=\n\\begin{vmatrix}\n-2 & 1 & -2\\\\\n1 & -10 & 2\\\\\n-2 & 2 & -6\n\\end{vmatrix}=-74&lt;0\n\\end{aligned}\n\\]\nВывод: функция достигает максимума в точке \\(M_0(4,1,2)\\)\n\\(\\max{u}=u(4,1,2)=51\\)",
    "crumbs": [
      "Нелинейное программирование",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Безусловная оптимизация функции многих переменных</span>"
    ]
  },
  {
    "objectID": "nonlinear/unconstrained/analytical-many.html#sec-nonlinear-unconstrained-many-4vars",
    "href": "nonlinear/unconstrained/analytical-many.html#sec-nonlinear-unconstrained-many-4vars",
    "title": "13  Безусловная оптимизация функции многих переменных",
    "section": "13.4 Экстремум функции четырех переменных",
    "text": "13.4 Экстремум функции четырех переменных\nРассмотренный алгоритм исследования распространяется и на функции большего количества переменных Разберём ещё случай функции 4 переменных, а дальше – будет понятно. Чтобы исследовать на экстремум дифференцируемую функцию четырёх аргументов, нужно найти частные производные 1-го порядка и решить систему:\n\\[\n\\begin{cases}\n\\frac{\\partial u}{\\partial x}=0\\\\\n\\frac{\\partial u}{\\partial y}=0\\\\\n\\frac{\\partial u}{\\partial z}=0\\\\\n\\frac{\\partial u}{\\partial v}=0\\\\\n\\end{cases}\n\\]\nПредположим, что в результате решения найдена стационарная точка \\(M_0(x_0,y_0,z_0,v_0\\). Далее нужно найти частные производные 2-го порядка, вычислить их в точке \\(M_0\\) и составить матрицу Гессе:\n\\[\nH_4=\n\\begin{pmatrix}\n\\frac{\\partial^2 u(M_0)}{\\partial x^2} & \\frac{\\partial^2 u(M_0)}{\\partial x \\partial y} & \\frac{\\partial^2 u(M_0)}{\\partial x \\partial z}  & \\frac{\\partial^2 u(M_0)}{\\partial x \\partial v}\\\\\n\\frac{\\partial^2 u(M_0)}{\\partial y \\partial x} & \\frac{\\partial^2 u(M_0)}{\\partial y^2}  & \\frac{\\partial^2 u(M_0)}{\\partial y \\partial z} & \\frac{\\partial^2 u(M_0)}{\\partial y \\partial v} \\\\\n\\frac{\\partial^2 u(M_0)}{\\partial x \\partial z} &  \\frac{\\partial^2 u(M_0)}{\\partial z \\partial y} & \\frac{\\partial^2 u(M_0)}{\\partial z^2} & \\frac{\\partial^2 u(M_0)}{\\partial z \\partial v} \\\\\n\\frac{\\partial^2 u(M_0)}{\\partial v \\partial x} &  \\frac{\\partial^2 u(M_0)}{\\partial v \\partial y} & \\frac{\\partial^2 u(M_0)}{\\partial v \\partial z} & \\frac{\\partial^2 u(M_0)}{\\partial v^2} \\\\\n\\end{pmatrix}\n\\] после чего вычислить её угловые миноры \\(\\delta_1,\\delta_2,\\delta_3,\\delta_4\\).\nЕсли все миноры положительны, то в точке \\(M_0\\) – минимум, если знакочередуются в следующем порядке: \\(\\delta_1&lt;0,\\quad \\delta_2&gt;0,\\quad \\delta_3&lt;0, \\quad \\delta_4&gt;0\\) (и именно в таком!), то в точке \\(M_0\\) – максимум. Если имеет место другой случай, но \\(\\delta_4=|H_4|\\neq0\\) , то \\(M_0\\) – седловая точка; если же \\(\\delta_4=|H_4|=0\\), то признак не даёт ответа о характере точки \\(M_0\\). Этот алгоритм известен как проверка квадратичной формы полного дифференциала 2-го порядка на знакоопределённость методом Сильвестра (для функций 2, 3, 4 и большего количества переменных).\n\n\n\n\n1. Емелин А. Экстремумы функций двух и трёх переменных [Электронный ресурс]. URL: http://mathprofi.ru/extremumy_funkcij_dvuh_i_treh_peremennyh.html (дата обращения: 20.02.2025).",
    "crumbs": [
      "Нелинейное программирование",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Безусловная оптимизация функции многих переменных</span>"
    ]
  },
  {
    "objectID": "nonlinear/constrained/analytical-many.html",
    "href": "nonlinear/constrained/analytical-many.html",
    "title": "14  Условная оптимизация функции многих переменных",
    "section": "",
    "text": "14.1 Прямоугольные ограничения неравенства\n\\[\n\\begin{cases}\n\\min{F(\\vec{x})}=x_1^2+x_2^2+x_1x_2+2x_1+4x_2+5\\\\\n-4 \\leq x_1 \\leq 4 \\\\\n2 \\leq x_2 \\leq 3\n\\end{cases}\n\\]\nПреобразуем ограничения\n\\[\n\\begin{cases}\ng_1:x_1 + 4 \\geq 0\\\\\ng_2:4 - x_1 \\geq 0\\\\\ng_3:x_2 - 2 \\geq 0\\\\\ng_4:3 - x_2 \\geq 0\n\\end{cases}\n\\]\nЗапишем функцию лагранжа нашей системы\n\\[\n\\begin{cases}\nL(\\vec{x},\\vec{\\mu}) = F(x) - \\sum_{i=1}^4{\\mu_i g_i} \\\\\nL(\\vec{x},\\vec{\\mu}) = x_1^2+x_2^2+x_1 x_2+2 x_1+4 x_2+5 - \\mu_1(x_1+4) - \\mu_2(4-x_1) - \\mu_3(x_2-2) - \\mu_4 (3-x_2)\\\\\n\\frac{\\partial L(\\vec{x},\\vec{\\mu})}{\\partial x_1}=2x_1 + x_2 + 2 - \\mu_1 + \\mu_2 = 0\\\\\n\\frac{\\partial L(\\vec{x},\\vec{\\mu})}{\\partial x_2}=2x_2 + x_1 + 4 - \\mu_3 + \\mu_4 = 0\\\\\ng_1:\\mu_1(x_1+4)=0\\\\\ng_2:\\mu_2(4-x_1)=0\\\\\ng_3:\\mu_3(3-x_2)=0\\\\\ng_4:\\mu_4(3-x_2)=0\\\\\n\\mu_1,\\mu_2,\\mu_3,\\mu_4\\geq0\n\\end{cases}\n\\]\nНеобходимо найти решение этой системы. Подход заключается в следующем: будем рассматривать для каждого \\(\\mu_i&gt;0\\) и \\(\\mu_i=0\\) . Предположим, что \\(\\mu_1&gt;0\\), следовательно из уравнения для \\(g_1 \\implies x_1=-4, \\mu_2=0\\). Запишем полученную систему\n\\[\n\\begin{cases}\nx_2-6-\\mu_1=0\\\\\n2x_2-\\mu_3+\\mu_4=0\\\\\n\\mu_3(x_2-2)=0\\\\\n\\mu_4(3-x_2)=0\\\\\n\\mu_1,\\mu_3,\\mu_4\\geq0\n\\end{cases}\n\\]\nДалее опять предположим, что \\(\\mu_3&gt;0\\). Из этого следует, что \\(x_2=2\\) и \\(\\mu_1=-4\\), что является противоречием. Рассмотрим случай, когда \\(\\mu_3=0\\). Предположим, что \\(\\mu_4&gt;0\\). Из этого следует, что \\(x_2=3\\) и \\(\\mu_1=-3\\), что является противоречием. Далее проверим \\(\\mu_4=0\\), получаем \\(x_2=0\\) и \\(\\mu_1=-6\\), что опять приводит к противоречию. Следовательно \\(\\mu_3=0\\).\nТаким образом перебрав все ‘ветви’ системы приходим к решению:\n\\[\n\\begin{cases}\nx_1 = -2\\\\\nx_2 = 2\\\\\n\\mu_1 = 0\\\\\n\\mu_2 = 0\\\\\n\\mu3 = 6\\\\\n\\mu_4 = 0\n\\end{cases}\n\\]\nПолучаем, что минимум в точке \\((-2,2,13)\\). Докажем, это это минимум. Матрица Гессе функции \\(F(x_1,x_2)\\) выглядит следующим образом\n\\[\n\\begin{bmatrix}2 & 1\\\\1 & 2\\end{bmatrix}\n\\]",
    "crumbs": [
      "Нелинейное программирование",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Условная оптимизация функции многих переменных</span>"
    ]
  },
  {
    "objectID": "nonlinear/constrained/analytical-many.html#sec-nonlinear-constrained-many-linear",
    "href": "nonlinear/constrained/analytical-many.html#sec-nonlinear-constrained-many-linear",
    "title": "14  Условная оптимизация функции многих переменных",
    "section": "14.2 Линейные ограничения неравенства",
    "text": "14.2 Линейные ограничения неравенства\nЯвляются частным случаем нелинейных, большинство алгоритмов работает с ними, как с нелинейными.\n\\[\n\\begin{cases}\n      \\min{F(\\vec{x})}=x_1^2+x_2^2+x_1x_2+2x_1+4x_2+5\\\\\n      2 x_1 + x_2 \\geq 0\\\\\n      x_1 + 2 x_2 \\leq 1\n\\end{cases}\n\\]\n\n\n\n\n\n\nПреобразуем ограничения\n\\[\n\\begin{cases}\ng_1:(2 x_1 + x_2) \\geq 0\\\\\ng_2:(-x_1-2x_2+1) \\geq 0\n\\end{cases}\n\\]\nСформируем функцию Лагранжа\n\\[\n\\begin{cases}\nL(\\vec{x},\\vec{\\mu})=x_1^2+x_2^2+x_1x_2+2x_1+4x_2+5-\\mu_1(2x_1+x_2)-\\mu_2(-x_1-2x_2+1)\\\\\n\\frac{\\partial L(\\vec{x},\\vec{\\mu})}{\\partial x_1}=2x_1 + x_2 + 2 - 2\\mu_1 + \\mu_2 = 0\\\\\n\\frac{\\partial L(\\vec{x},\\vec{\\mu})}{\\partial x_2}=2x_2 + x_1 + 4 - \\mu_1 + 2\\mu_2 = 0\\\\\ng_1:\\mu_1(2x_1+x_2)=0\\\\\ng_2:\\mu_2(-x_1-2x_2+1)=0\\\\\n\\mu_1,\\mu_2 \\geq 0\n\\end{cases}\n\\]\nДопустим, что \\(\\mu_1&gt;0\\), тогда \\((2x_1+x_2)=0\\), \\(x_2=-2x_1\\), откуда система:\n\\[\n\\begin{cases}\n2-2\\mu_1+\\mu_2=0\\\\\n4-3x_1-\\mu_1+2\\mu_2=0\\\\\n\\mu_2(3x_1+1)=0\\\\\n\\mu_1,\\mu_2&gt;0\n\\end{cases}\n\\]\nПредположим, что \\(\\mu_2&gt;0\\), следовательно \\(x_1=-\\frac{1}{3}\\) и система преобразуется в:\n\\[\n\\begin{cases}\n2-2\\mu_1+\\mu_2=0\\\\\n7-\\mu_1+2\\mu_2=0\\\\\n\\mu_1,\\mu_2&gt;0\n\\end{cases}\n\\]\nОткуда следует, что \\(\\mu_2=-4\\), что является противоречием. Рассмотрим случай, когда \\(\\mu_2=0\\). Тогда\n\\[\n\\begin{cases}\n2-2\\mu_1=0\\\\\n4-3x_1-\\mu_1=0\\\\\n\\mu_1&gt;0\n\\end{cases}\n\\]\nЛегко получить решение:\n\\[\n\\begin{cases}\nx_1 = 1\\\\\nx_2 = -2\\\\\n\\mu_1 = 1\\\\\n\\mu_2 = 0\n\\end{cases}\n\\]",
    "crumbs": [
      "Нелинейное программирование",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Условная оптимизация функции многих переменных</span>"
    ]
  },
  {
    "objectID": "nonlinear/constrained/analytical-many.html#sec-nonlinear-constrained-nonlinear",
    "href": "nonlinear/constrained/analytical-many.html#sec-nonlinear-constrained-nonlinear",
    "title": "14  Условная оптимизация функции многих переменных",
    "section": "14.3 Нелинейные ограничения равенства",
    "text": "14.3 Нелинейные ограничения равенства\n\\[\n\\begin{cases}\n\\min{F(\\vec{x})}=x_1^2+x_2^2+x_1x_2+2x_1+4x_2+5\\\\\ng1:x_1^2 - x_1 x_2 = -2\n\\end{cases}\n\\]\n\n\n\n\n\n\nПереформулируем ограничения\n\\[x_1^2 - x_1 x_2 + 2 = 0\\]\nСформируем функцию Лагранжа\n\\[\n\\begin{cases}\nL(\\vec{x},\\vec{\\mu})=x_1^2+x_2^2+x_1x_2+2x_1+4x_2+5-\\mu_1(x_1^2-x_1x_2+2)\\\\\n\\frac{\\partial L(\\vec{x},\\vec{\\mu})}{\\partial x_1}=2x_1 + x_2 + 2 - \\mu_1(2x_1-x_2)= 0\\\\\n\\frac{\\partial L(\\vec{x},\\vec{\\mu})}{\\partial x_2}=2x_2 + x_1 + 4 + \\mu_1 x_1 = 0\\\\\ng_1:\\mu_1(x_1^2-x_1x_2+2)=0\\\\\n\\mu_1 \\geq 0\n\\end{cases}\n\\]\nПусть \\(\\mu_1&gt;0\\), тогда \\(x_1^2-x_1x_2+2=0\\). Рассмотрим случай, когда \\(x_1=x_2\\). Система представляется так:\n\\[\n\\begin{cases}\n2x_1+x_2+2-\\mu_1(2x_1-x_2)=0\\\\\n2x_2+x_1+4+\\mu_1x_1=0\\\\\n\\mu_1(x_1^2-x_1x_2+2)=0\\\\\n\\mu_1\\geq 0\n\\end{cases}\n\\]\nПусть \\(\\mu_1&gt;0\\), следовательно \\(x_1^2-x_1x_2+2=0\\). Выразим \\(x_2=\\frac{2+x_1^2}{x_1}\\), тогда система после подстановки и преобразования:\n\\[\n\\begin{cases}\nx_1^2(3-\\mu_1)+2x_1+\\mu_1+2=0\\\\\n(3+\\mu_1)x_1^2+4x_1+4=0\\\\\n\\end{cases}\n\\]\nВыразим из второго уравнения\n\\[\n\\mu_1=-\\frac{3x_1^2+4x_1+4}{x_1^2}\n\\]\nИ подставим в первое\n\\[\n6x_1^4+6x_1^3-8x_1-8=0\n\\]\nОтсюда подбором получается корень \\(x_1=-1\\). Общее решение:\n\\[\n\\begin{cases}\nx_1=-3\\\\\nx_2=-3\\\\\n\\mu_1=1\n\\end{cases}\n\\]",
    "crumbs": [
      "Нелинейное программирование",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Условная оптимизация функции многих переменных</span>"
    ]
  },
  {
    "objectID": "lab/1/intro.html",
    "href": "lab/1/intro.html",
    "title": "15  1. Введение",
    "section": "",
    "text": "15.1 Инструкции",
    "crumbs": [
      "Лабораторные работы",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>1. Введение</span>"
    ]
  },
  {
    "objectID": "lab/1/intro.html#sec-lab-1-instructions",
    "href": "lab/1/intro.html#sec-lab-1-instructions",
    "title": "15  1. Введение",
    "section": "",
    "text": "15.1.1 Установка\n\nУстановить R Глава 1.1\n\nУстановить RTools Глава 1.2\n\nУстановить IDE для работы: RStudio Глава 1.3 или другу IDE, которую поддерживает Quarto.\nСоздать интерактивный блокнот Quarto Глава 2.1.1 и сохранить его в отдельном каталоге (например lab1 ).\nИзучить возможности визуального редактора RStudio IDE Глава 2.1.2\n\nСкопировать код из примера Глава 3.1, вставить в редакторе Глава 2.1.3 и запустить рендер (Глава 2.2.3 или Глава 3.3).\nСкопировать в рабочий каталог файлы окружения renv и восстановить пакеты Глава A.2.3\n\nОтрендерить пример Глава 3.3 или Глава 2.2.3\n\n\n15.1.2 Теория\n\nИзучить язык разметки Quarto Markdown Глава 4 и LaTeX Глава 5\n\nИзучить основы языка R Глава 6\n\nИзучить библиотеку для построения графиков plotly Приложение B или ggplot ?sec-r-tools-ggplo2\n\nПовторить отдельные элементы из линейной алгебры Глава 8\n\nПовторить теорию определения экстремумов функций Глава 12 и Глава 13\n\n\n\nПример 15.1 Чтобы попасть из пункта А (остановка автобуса) в пункт В (лодочная станция) человек должен пройти сначала по асфальтовой дороге шириной \\(S\\), а затем по песчаному пляжу шириной \\(s\\). Скорость передвижения по асфальту \\(V\\) , скорость передвижения по песку \\(v\\). Спрашивается, в каком месте нужно свернуть с асфальтовой дороги, чтобы затратить меньше времени на путь.\n\n\nРешение 15.1. Решим задачу с конкретными значениями, в виду сложности аналитического решения (сводится к уравнению 4 степени): \\(D = 100\\), \\(S = 40\\), \\(V = 5\\), \\(s = 60\\), \\(v = 3\\)\n\n\n\n\n\n\nКритерий оптимальности задается функцией \\(t(x)\\), которую надо минимизировать, изменяя варьируемый параметр \\(х\\). Остальные параметры задачи \\((v,V,D,s,S)\\) являются фиксированными. \\[t(x) = \\frac{\\sqrt{x^2+S^2}}{V} + \\frac{\\sqrt{(D-x)^2+s^2}}{v}\\] \\[\\begin{cases}\n      \\min{t(x)} - ?\\\\\n      \\frac{dt}{dx}=0\\\\\n      \\frac{d^2t}{dx^2}&gt;0\n\\end{cases}\\,\\] \\[t'(x)=\\frac{x}{V \\sqrt{S^2+x^2}}-\\frac{d-x}{v \\sqrt{(d-x)^2+s^2}}\\]\nГрафик целевой функции \\(t(x)\\)\n\n\n\n\n\n\nГрафик производной целевой функции \\(t'(x)\\)\n\n\n\n\n\n\nСледовательно оптимальное значение пути, пройденного по дороге \\(x = 65.64\\)",
    "crumbs": [
      "Лабораторные работы",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>1. Введение</span>"
    ]
  },
  {
    "objectID": "lab/1/intro.html#sec-lab-1-task",
    "href": "lab/1/intro.html#sec-lab-1-task",
    "title": "15  1. Введение",
    "section": "\n15.2 Задания",
    "text": "15.2 Задания\n\n15.2.1 Отчёт\nСоздать документ Quarto в RStudio Глава 2.1.1 или через командную строку Глава 3. Отчёт загружается на образовательный портал.\n\n15.2.2 Язык программирования R\n\nУпражнение 15.1 Упростите выражение (Глава 6.3.1):\nc(sqrt(1), sqrt(2), sqrt(3))\nСоздайте последовательность 2 способами (-1, -0.75, -0.5, …, 0.75, 1).\n\n\n\n\n\n\nУровень 1\n\n\n\n\n\nУпражнение 15.2 Построить график (Глава B.2) кусочно-гладкой функции (Глава 6.12.1) используя функцию ifelse()\n\\[\nf(x)=\\begin{cases}\n      x^2,\\qquad x \\leq -3\\\\\n      x^3, \\qquad -3 &lt; x &lt; 3\\\\\n      2x+1, 3\\leq x\n\\end{cases}\\,\n\\]\n\n\n\n\n\n\nУровень 1\n\n\n\n\n\nУпражнение 15.3 С помощью ряда Лейбница можно получить значение числа \\(\\pi\\) . Данный ряд сходится очень медленно.\n\\[\n\\pi = 4 \\sum_{i=0}^n{\\frac{(-1)^i}{2i+1}}\n\\]\nИспользовав по максимуму векторные операции (Глава 6.9) рассчитайте для различных \\(n\\) от \\(n=10\\) до \\(n=10^{8}\\)\n\nчисло \\(\\pi\\) и его ошибку\nпостройте график (Глава B.2) ошибки от \\(n\\)\n\n\n\n\n\n\n\n\nУровень 2\n\n\n\n\n\nУпражнение 15.4 Создать список (Глава 6.4) содержащий буквы от ‘a' до’z'. Продемонстрировать использование операторов индексации (Глава 6.4.1).\n\n\n\n\n\n\nУровень 1\n\n\n\n\n\nУпражнение 15.5 Создать список (Глава 6.4) матриц (Глава 6.5) размером 2x2 заполненных случайными целыми числами. Используя циклы (Глава 6.11) получите:\n\nсписок с элементов (2,2) каждой матрицы (Глава 6.4.1 , Глава 6.5.1).\nвектор состоящий из элементов (1,1), (1,2) этих матриц.\n\n\n\n\n\n\n\nУровень 1\n\n\n\n\n\nУпражнение 15.6  \n\nсоздайте пятимерный массив и заполните его целыми числами.\nпреобразуйте его как список массивов размерности 4.\nпреобразуйте его как список списков массивов размерности 3.\n\n\n\n\n\n\n\nУровень 2\n\n\n\n\n\n15.2.3 Линейная алгебра\n\nУпражнение 15.7 Решить СЛАУ (Глава 8.3) \\(AX=b\\) встроенным методом (?sec-r-tools-basic-solve). Элементы матриц сгенерировать произвольно. solve()\n\n\n\n\n\n\nУровень 1\n\n\n\n\n\nУпражнение 15.8 Для произвольных матриц \\(A\\) и \\(B\\) заполненных случайными числами проверить следующие свойства:\n\n\n\\((A+B)^T=A^T+B^T\\) Глава 8.2.2.3\n\n\\((AB)^T=B^TA^T\\)\n\n\\(\\det{A}=\\det{A^T}\\) Глава 8.2.3\n\n\\(\\det{AB}=\\det{A}\\det{B}\\)\n\\(\\det{A^{-1}}=(\\det{A})^{-1}\\)\n\n\\((AB)^{-1}=B^{-1}A^{-1}\\) Глава 8.2.4\n\n\\((A-B)^{-1}=A^{-1}+A^{-1}B(A-B)^{-1}\\)\n\nРассмотрите функции inverse() ?sec-r-tools-basic-inverse, det() ?sec-r-tools-basic-det\n\n\n\n\n\n\nУровень 1\n\n\n\n\n\nУпражнение 15.9 Реализовать решение системы линейных уравнений методом гаусса Глава 8.3.2.1 используя векторные операции.\n\n\n\n\n\n\nУровень 3\n\n\n\n\n\n15.2.4 Исследование операций\n\nУпражнение 15.10  \n\nПостроить объемный (Глава B.3) и контурный (Глава B.4) графики функций \\(z = x^2 - y^2\\) и \\(z = x^2 + y^2\\).\nГрафически определить минимум.\nК какому типу относятся кривые, изображенные на контурном графике.\n\n\n\n\n\n\n\nУровень 1\n\n\n\n\n\nУпражнение 15.11 Найти максимальную скорость тела движущегося по закону\n\\[\ns = 18t + 9t^2 - t^3\n\\]\n\nПостроить график функции и её производной (Пример B.4).\nАналитически определить максимум функции (Глава 12).\nДоказать, что данная точка является максимумом (Теорема 12.2) или (Теорема 12.3) .\n\n\n\n\n\n\n\nУровень 2\n\n\n\n\n\nУпражнение 15.12 Суточные расходы при плавании судна состоят из двух частей: постоянной, равной \\(а\\), и переменной, возрастающий пропорционально кубу скорости. При какой скорости \\(v\\) плавание судна окажется наиболее экономичным?\n\nопределите целевую функцию\nаналитически определите максимум целевой функции (Глава 12)\nпостройте график целевой функции (Глава B.2)\n\n\n\n\n\n\n\nУровень 2\n\n\n\n\n\nУпражнение 15.13 Имеется квадратный лист жести, сторона которого \\(а=60\\ см\\). Вырезая по всем его углам равные квадраты и загибая оставшуюся часть, нужно изготовить коробку без крышки. Каковы должны быть размеры вырезаемых квадратов, чтобы коробка имела наибольший объем?\n\n\nРаскройка листа жести\n\n\nопределите целевую функцию\nаналитически определите максимум целевой функции (Глава 12)\nпостройте график целевой функции (Глава B.2)\n\n\n\n\n\n\n\nУровень 3\n\n\n\n\n\n15.2.5 Прикладная магия\n\nУпражнение 15.14 Пусть дана функция общего вида \\(f(x,y)\\) и система уравнений \\(Ax=b\\) для двух переменных. Постройте контурный график функции, на котором изобразите точки пересечения прямых. Обработать случаи параллельных прямых, совпадающих прямых Глава 8.3.1.\n\n\n\n\n\n\nУровень 4\n\n\n\nДополнительно попробуйте использовать встроенный интерфейса формулы используя переменно число аргументов для функции. Считайте символ ~ эквивалентом символу =. Глава 7.10\n```{r}\nf(2*x+3*y~0, 2*x~3y+1~0)\n```",
    "crumbs": [
      "Лабораторные работы",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>1. Введение</span>"
    ]
  },
  {
    "objectID": "lab/1/intro.html#sec-lab-1-scoring",
    "href": "lab/1/intro.html#sec-lab-1-scoring",
    "title": "15  1. Введение",
    "section": "\n15.3 Разбалловка",
    "text": "15.3 Разбалловка\n\nРазбалловка\n\nОбъём работы\nИтоговый балл\n\n\n\nХорошо отдохнул(-а)\nНе сдано\n\n\nВсе задачи уровня 1\n2\n\n\nВсе задачи уровней 1 и 2\n3\n\n\nВсе задачи уровней 1, 2 и 3\n4\n\n\nВсе задачи уровней 2, 3 и 4\n5",
    "crumbs": [
      "Лабораторные работы",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>1. Введение</span>"
    ]
  },
  {
    "objectID": "lab/1/intro.html#проверочная-работа",
    "href": "lab/1/intro.html#проверочная-работа",
    "title": "15  1. Введение",
    "section": "\n15.4 Проверочная работа",
    "text": "15.4 Проверочная работа",
    "crumbs": [
      "Лабораторные работы",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>1. Введение</span>"
    ]
  },
  {
    "objectID": "lab/2/linear.html",
    "href": "lab/2/linear.html",
    "title": "16  2. Линейное программирование",
    "section": "",
    "text": "16.1 Инструкции",
    "crumbs": [
      "Лабораторные работы",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>2. Линейное программирование</span>"
    ]
  },
  {
    "objectID": "lab/2/linear.html#sec-lab-1-instructions",
    "href": "lab/2/linear.html#sec-lab-1-instructions",
    "title": "16  2. Линейное программирование",
    "section": "",
    "text": "16.1.1 Установка\n\n16.1.2 Теория\n\nПример 16.1 Пример\n\n\nРешение 16.1. Решение примера",
    "crumbs": [
      "Лабораторные работы",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>2. Линейное программирование</span>"
    ]
  },
  {
    "objectID": "lab/2/linear.html#задания",
    "href": "lab/2/linear.html#задания",
    "title": "16  2. Линейное программирование",
    "section": "\n16.2 Задания",
    "text": "16.2 Задания\n\nУпражнение 16.1 (Простота и наглядность) \\[\n\\begin{aligned}\n&\\mathrm{F}=5x_1+4x_2 \\rightarrow \\max \\\\\n&\\begin{cases}\n6x_1+4x_2\\leq24\\\\\nx_1+2x_2\\leq6\\\\\n-x_1+x_2\\leq1\\\\\nx_1,x_2\\geq0\n\\end{cases}\n\\end{aligned}\n\\]\n\nПостроить целевую функцию\nПостроить прямые, определяющие ограничения\nОпределить точки пересечения прямых\nОпределить решение графически.\n\n\n\n\n\n\n\nСовет\n\n\n\nМожно добавлять элементы на график последовательно отображая их Глава B.6.\n\n\n\n\n\n\n\n\nУровень 1\n\n\n\n\n\nУпражнение 16.2 (Пакет с пакетами) С помощью пакета Приложение D получить решение задачи. Используйте, Глава D.1 или Глава D.2 на своё усмотрение.\n\\[\n\\begin{aligned}\n&\\mathrm{F}=3x_1+4x_2+2x_3+5x_4+6x_5+7x_6+8x_7+9x_8+10x_9+11x_{10} \\rightarrow \\max \\\\\n&\\begin{cases}\nx_1+2x_2+3x_3+x_4+4x_5+6x_6+7x_8+8x_9+9x_{10} \\leq 30\\\\\n2x_1+x_2+2x_3+3x_4+2x_5+3x_6+4x_7+5x_8+x_9+3x_{10}\\leq 20\\\\\n3x_1+4x_2+x_3+4x_4+5x_5+2x_6+x_7+3x_8+2x_9+x_{10} \\leq 25\\\\\n4x_1+2x_2+5x_3+x_4+2x_5+3x_6+5x_7+6x_8+2x_9+4x_{10} \\leq 25\\\\\nx_1+2x_2+5x_3+x_4+2x_5+4x_6+5x_7+x_8+x_9+3x_{10} \\leq 18 \\\\\n5x_1+6x_2+x_3+3x_4+4x_5+5x_6+6x_7+7x_8+x_9+2x_{10} \\leq 22 \\\\\n2x_1+3x_2+4x_3+x_4+4x_5+3x_6+2x_7+5x_8+7x_9+8x_{10} \\leq 19 \\\\\nx_i\\geq0,\\forall x_i\n\\end{cases}\n\\end{aligned}\n\\]\n\n\n\n\n\n\nУровень 1\n\n\n\n\n\nУпражнение 16.3 (Учебный план) Для новых специальностей на факультете радиофизики запланировано 3500 учебных часов. Основные разделы подготовки студентов и затраты на разработку приведены ниже.\n\n\nРаздел\nЗатраты\n\n\n\nАэрокосмос\n3\n\n\nФизика\n1\n\n\nМикроэлектроника\n2\n\n\nМатематика\n1\n\n\nКомпьютерная безопасность\n3\n\n\nПрограммирование\n1\n\n\nРадиофизика\n2\n\n\nСтатистика\n1\n\n\nМашинное обучение\n2\n\n\n\nСоотношение между часами учебных дисциплин должно быть не меньше, чем указано в диаграмме\n\n\n\n\n\ngraph LR\n    AeroSpace(Аэрокосмос)\n    Physics(Физика)\n    MicroEl(Микроэлектроника)\n    Math(Математика)\n    CyberSecurity(Инфобез)\n    Programming(Программирование)\n    RadioPhysics(Радиофизика)\n    Statistics(Статистика)\n    MachineLearning(Машинное обучение)\n\n    RadioPhysics --&gt;|2| Math\n    RadioPhysics --&gt;|2| Physics\n    MachineLearning --&gt;|1| Math\n    MachineLearning --&gt;|1| Statistics\n    MachineLearning --&gt;|1| Programming\n    AeroSpace --&gt;|1| RadioPhysics\n    AeroSpace --&gt;|1| Programming\n    CyberSecurity --&gt;|2| Programming\n    CyberSecurity --&gt;|1| Math\n    CyberSecurity --&gt;|1| Physics\n    MicroEl --&gt;|2| Programming\n    MicroEl --&gt;|1| Physics\n\n\n\n\n\n\nСогласно положению за период обучения должно быть прочитано часов не менее\n\n\nРаздел\nЧасы\n\n\n\nКомпьютерная безопасность\n400\n\n\nАэрокосмос\n300\n\n\nРадиофизика\n300\n\n\nМашинное обучение\n400\n\n\nМикроэлетроника\n300\n\n\n\nОпределите наиболее выгодное распределение часов (стоимость) для студента и для факультета.\n\n\n\n\n\n\nУровень 2\n\n\n\n\n\nУпражнение 16.4 (Работа не волк, а work) Лишенный стипендии студент для поддержания своего финансового уровня должен подрабатывать и получить не менее 700 руб в месяц. У него есть следующие альтернативы\n\n\n\n\n\n\n\n\n\nРабота\nЧасов, не менее\nЧасов, не более\nНапряженность\nДоход/час\n\n\n\nКурьер\n10\n20\n12\n10\n\n\nПовар\n20\n40\n8\n11\n\n\nГрузчик\n5\n60\n15\n8\n\n\nПродавец\n25\n70\n10\n12\n\n\nФриланс разработчик\n20\n50\n20\n30\n\n\n\nПонятно, что общая напряженность в месяц пропорциональна количеству отработанных часов. Найдите оптимальную занятость студента.\n\n\n\n\n\n\nУровень 2\n\n\n\n\n\nУпражнение 16.5 (На всю котлету) Столовая № 8 готовит блюда из картошки, овощей, курицы, свинины, крупы. Возможные ежедневные поставки ограничены. Стоимость кг сырья составляет. Минимальный дневной спрос.\n\nБазовые продукты\n\nПродукт\nОгр. поставок кг\nСтоимость/кг\n\n\n\nОвощи\n50\n3\n\n\nКрупа\n30\n1\n\n\nМясо\n10\n12\n\n\nМакароны\n20\n5\n\n\n\n\nГотовые блюда\n\nБлюдо\nСостав\nПропорция\nДневное потребление\n\n\n\nСупы\nОвощи, Крупа, Мясо\n2:3:1\n15\n\n\nГарнир\nОвощи, Крупа\n1:1\n20\n\n\nГорячее\nМясо, Макароны\n3:2\n10\n\n\nСалаты\nМясо, Овощи\n1:8\n5\n\n\n\nРазработайте модель ЛП оптимального производственного плана и потребности в ингредиентах. Как изменится решение, если стоимость блюда, а если измениться ограничение. При какой наименьшей стоимости будет иметь смысл производить. Как существенно повысить прибыль, если есть всего одна возможность.\n\n\n\n\n\n\nУровень 2\n\n\n\n\n\nУпражнение 16.6 (А что, если болт?) В хозяйственном магазине покупают монтажные наборы из винтов, болтов, гаек и и шайб. Винты поставляют в коробках по 5 кг по цене 110 руб за коробку. Болты поставляют в коробках по 3 кг ценой по 150 руб, гайки в коробках по 3 кг стоимостью 70 руб, а шайбы в коробках по 1 кг ценой 20 руб за коробку. Монтажный набор должен весить не меньше 500 грамм и включать (по весу) не менее 10% винтов и 25% болтов, не не более 15% гаек и 10% шайб. Чтобы пакет был правильно укомплектован, количество болтов не должно превосходить количество гаек и количество шайб. Один болт вести в 10 раз больше гайки и в 50 раз больше шайбы. Создайте модель ЛП для определения оптимального состава монтажного набора и найдите решение. // Таха 2.68 c 83\n\n\n\n\n\n\nУровень 3\n\n\n\n\n\nУпражнение 16.7 (Враг в отражении) Решите двойственную к следующей задачу ЛП, а затем найдите оптимальное решение прямой задачи. Даёт ли в этом случае вычислительное преимущество по сравнению с решением прямой задачи ЛП? // 4.11 с 190 Таха\n\\[\n\\begin{aligned}\n&\\mathrm{F}=5x_1+6x_2+3x_3 \\rightarrow \\min \\\\\n&\\begin{cases}\n5x_1+5x_2+3x_3 \\geq 50,\\\\\nx_1+x_2-x_3 \\geq 20, \\\\\n7x_1+6x_2-9x_3 \\geq 30, \\\\\n5x_1+5x_2+5x_3 \\geq 35, \\\\\n2x_1+4x_2-15x_3 \\geq 10, \\\\\n12x_1+10x_2 \\geq 90, \\\\\nx_2-10x_3 \\geq 20, \\\\\nx_1,x_2,x_3 \\geq 0\n\\end{cases}\n\\end{aligned}\n\\]\n\n\n\n\n\n\nУровень 3\n\n\n\n\n\nУпражнение 16.8 (Верный алгоритм)  \nСимплекс метод\nРеализовать симплекс, считая входные данные “хорошими” (не обрабатывать особые случаи и ошибки).\n\n\n\n\n\n\nУровень 4\n\n\n\nДвухэтапный метод\nРеализовать M-метод или двухэтапный метод.\n\n\n\n\n\n\nУровень 4",
    "crumbs": [
      "Лабораторные работы",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>2. Линейное программирование</span>"
    ]
  },
  {
    "objectID": "lab/2/linear.html#sec-lab-2-scoring",
    "href": "lab/2/linear.html#sec-lab-2-scoring",
    "title": "16  2. Линейное программирование",
    "section": "\n16.3 Разбалловка",
    "text": "16.3 Разбалловка\n\nРазбалловка\n\nОбъём работы\nИтоговый балл\n\n\n\n\nСимплекс метод — надежный и творческий инструмент для решения проблем.\nНе сдано\n\n\nВсе задачи уровня 1\n2\n\n\nВсе задачи уровней 1 и 2\n3\n\n\nВсе задачи уровней 1, 2 и 3\n4\n\n\nВсе задачи уровней 2, 3 и 4\n5",
    "crumbs": [
      "Лабораторные работы",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>2. Линейное программирование</span>"
    ]
  },
  {
    "objectID": "lab/2/linear.html#проверочная-работа",
    "href": "lab/2/linear.html#проверочная-работа",
    "title": "16  2. Линейное программирование",
    "section": "\n16.4 Проверочная работа",
    "text": "16.4 Проверочная работа\n\nРешить графически задачу для двух переменных\nПривести в стандартную форму\nПостроить модель текстовой задаче\nОпределить, какой из особых случаев реализован\n\nВырожденность\nАльтернативные оптимальные решения\nОтсутствие допустимых решений\nНеограниченность\n\n\nГрафический анализ чувствительности оптимального решения\n\nПо коэффициентам целевой функции\nПо ограничениям\n\n\nСформулировать двойственную задачу\nРешить задачу\n\nСимплекс методом\nМ-Методом\nДвухэтапным симплекс методом",
    "crumbs": [
      "Лабораторные работы",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>2. Линейное программирование</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Литература",
    "section": "",
    "text": "1. RStudio. Introduction to renv [Electronic\nresource]. 2024. URL: https://rstudio.github.io/renv/articles/renv.html\n(accessed: 20.02.2025).\n\n\n2. Wickham H. Advanced R second\nedition [Electronic resource]. 2022. URL: https://adv-r.hadley.nz/ (accessed:\n20.02.2025).\n\n\n3. Gagolewski M. Deep r programming [Electronic\nresource]. 2025. URL: https://deepr.gagolewski.com/\n(accessed: 20.02.2025).\n\n\n4. R\ntutorial [Electronic resource]. URL: https://www.tutorialspoint.com/r/index.htm\n(accessed: 20.02.2025).\n\n\n5. R\ntutorial [Electronic resource]. URL: https://www.w3schools.com/r/\n(accessed: 20.02.2025).\n\n\n6. Learn LaTeX in 30 minutes [Electronic\nresource]. URL: https://www.overleaf.com/learn/latex/Learn_LaTeX_in_30_minutes\n(accessed: 20.02.2025).\n\n\n7. Equation sheet [Electronic resource]. URL: http://www.equationsheet.com/\n(accessed: 20.02.2025).\n\n\n8. Eager E. Linear algebra for data science in r\n[Electronic resource]. 2021. URL: https://rpubs.com/odenipinedo/linear-algebra-for-data-science-in-R\n(accessed: 20.02.2025).\n\n\n9. Гольштейн Евгений Григорьевич Ю.Д.Б.\nМатематические основы и практические задачи. стереотипное. Москва:\nЛЕНАНД, 2022. Vol. 1. P. 320.\n\n\n10. Емелин А. Возрастание, убывание и экстремумы\nфункции [Electronic resource]. URL: http://mathprofi.ru/vozrastanie_ubyvanie_ekstremumy_funkcii.html\n(accessed: 20.02.2025).\n\n\n11. Понятие экстремума функции [Electronic\nresource]. URL: https://www.webmath.ru/poleznoe/formules_8_22.php\n(accessed: 20.02.2025).\n\n\n12. Емелин А. Экстремумы функций двух и трёх\nпеременных [Electronic resource]. URL: http://mathprofi.ru/extremumy_funkcij_dvuh_i_treh_peremennyh.html\n(accessed: 20.02.2025).\n\n\n13. А.\nТ.Х. Исследование операций. 10th ed. / ed. Слепцова А.В.\nСанкт-Петербург: ООО \"Диалектика\", 2019. P. 1056.",
    "crumbs": [
      "Литература"
    ]
  },
  {
    "objectID": "r-tools/renv.html",
    "href": "r-tools/renv.html",
    "title": "Приложение A — Система управления пакетами renv",
    "section": "",
    "text": "A.1 Терминология\nRenv расшифровывается как Reproducible Environment. Эта библиотека позволяет автоматизировать управление пакетами и их зависимостями. [1]",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Система управления пакетами renv</span>"
    ]
  },
  {
    "objectID": "r-tools/renv.html#sec-r-tools-renv-defenitions",
    "href": "r-tools/renv.html#sec-r-tools-renv-defenitions",
    "title": "Приложение A — Система управления пакетами renv",
    "section": "",
    "text": "Определение A.1  \n\nБиблиотека (library)\n\nэто каталог, содержащий установленные пакеты (packages). Следующий код загружает пакет {r} library(dplyr), из библиотеки общей для всей системы. Текущие библиотеки можно посмотреть с помощью функции .libPaths() . Доступные пакеты можно узнать с помощью команды {r} lapply(.libPaths(), list.files) или через вкладку Packeges в RStudio.\n\n\n\n\nОпределение A.2  \n\nРепозиторий\n\nэто источник пакетов; install.packages() загружает пакет из репозитория и помещает его в библиотеку (каталог компьютере). Наиболее важным репозиторием является CRAN; Другие свободно доступные репозитории включают Bioconductor, Posit Public Package Manager и R Universe. Узнать какие репозитории активны в текущем сеансе можно с помощью команды {r} getOption('repos')",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Система управления пакетами renv</span>"
    ]
  },
  {
    "objectID": "r-tools/renv.html#sec-r-tools-renv-project",
    "href": "r-tools/renv.html#sec-r-tools-renv-project",
    "title": "Приложение A — Система управления пакетами renv",
    "section": "A.2 Проект",
    "text": "A.2 Проект\n\nA.2.1 Инициализация\nПроект инициализируется с renv::init(). Эта команда добавляет в проект три новых файла и директории:\n\nБиблиотека проекта, renv/library, содержащая все пакеты, которые в данный момент используются проекте. Renv инициализирует библиотеку для кажого проекта гаранитируя изоляцию проектов друг от друга. Разные проекты могут использовать разные версии пакетов, а установка, обновление или удаление пакетов в одном проекте не влияет на другие проекты.\nФайл блокировки renv.lock в который записываются метаданные об установленных пакетах.\nПрофиль проекта R, .Rprofile. Этот файл запускается автоматически при каждом запуске интерпретатора R (в данном проекте) и позволяет renv настроить пути к пакетам .\n\n\n\nA.2.2 Сохранение состояния\nДля сохранения состояния текущего проекта выполняется команда renv::snapshot(), которая записывает метаданные пакетов в файл renv.lock.\n\n\nA.2.3 Восстановление\nДля того, чтобы восстановить пакеты из другого проекта (например размещённого на github) требуется 4 файла:\nrenv.lock\n.Rprofile\nrenv/activate.R\nrenv/settings.json\nПосле сохранения этих файлов в каталоге проекта для восстановления пакетов выполняется команда renv::restore()\n\n\nA.2.4 Установка пакетов\nУстановка пакетов возможна стандартным способом install.packages() или с помощью renv::install().\n\n\nA.2.5 Обновление пакетов\nОбновление пакетов производится вызовом renv::update(). После обновления необходимо сохранить изменения Глава A.2.2.",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Система управления пакетами renv</span>"
    ]
  },
  {
    "objectID": "r-tools/renv.html#sec-r-tools-renv-project-infrastructure",
    "href": "r-tools/renv.html#sec-r-tools-renv-project-infrastructure",
    "title": "Приложение A — Система управления пакетами renv",
    "section": "A.3 Инфраструктура",
    "text": "A.3 Инфраструктура\nФайл блокировки всегда называется renv.lock и представляет собой json-файл, в котором записана вся информация, необходимая для воссоздания проекта. Пример файла блокировки с пакетом markdown, установленным из CRAN, и пакетом mime, установленным с GitHub:\n{\n  \"R\": {\n    \"Version\": \"4.4.2\",\n    \"Repositories\": [\n      {\n        \"Name\": \"CRAN\",\n        \"URL\": \"https://cloud.r-project.org\"\n      }\n    ]\n  },\n  \"Packages\": {\n    \"markdown\": {\n      \"Package\": \"markdown\",\n      \"Version\": \"1.0\",\n      \"Source\": \"Repository\",\n      \"Repository\": \"CRAN\",\n      \"Hash\": \"4584a57f565dd7987d59dda3a02cfb41\"\n    },\n    \"mime\": {\n      \"Package\": \"mime\",\n      \"Version\": \"0.12.1\",\n      \"Source\": \"GitHub\",\n      \"RemoteType\": \"github\",\n      \"RemoteHost\": \"api.github.com\",\n      \"RemoteUsername\": \"yihui\",\n      \"RemoteRepo\": \"mime\",\n      \"RemoteRef\": \"main\",\n      \"RemoteSha\": \"1763e0dcb72fb58d97bab97bb834fc71f1e012bc\",\n      \"Requirements\": [\n        \"tools\"\n      ],\n      \"Hash\": \"c2772b6269924dad6784aaa1d99dbb86\"\n    }\n  }\n}\n\n\n\n\n1. RStudio. Introduction to renv [Электронный ресурс]. 2024. URL: https://rstudio.github.io/renv/articles/renv.html (дата обращения: 20.02.2025).",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Система управления пакетами renv</span>"
    ]
  },
  {
    "objectID": "r-tools/plotly.html",
    "href": "r-tools/plotly.html",
    "title": "Приложение B — Графическая библиотека plotly",
    "section": "",
    "text": "B.1 Установка\nНазвания графиков рекомендуется добавлять с помощью (Глава 4.1.6).",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Графическая библиотека plotly</span>"
    ]
  },
  {
    "objectID": "r-tools/plotly.html#sec-r-tools-plotly-install",
    "href": "r-tools/plotly.html#sec-r-tools-plotly-install",
    "title": "Приложение B — Графическая библиотека plotly",
    "section": "",
    "text": "```{r}\ninstall.packages('plotly')\n```\n\n\n\n\n\n\nСовет\n\n\n\nЕсли график строится успешно, то рекомендуется игнорировать сообщения и предупреждения с помощью message и warning см Глава 4.1.4\n```{r}\n#| warning: false\n#| message: false\n```\n\n\n\n\n\n\n\n\nВажное уведомление\n\n\n\nДля отображения графика во всех примерах требуется удалить последнее применение функции |&gt; pshow(). Например Пример B.1\n```{r}\n#| warning: false\n#| message: false\n\nlibrary(plotly)\nx &lt;- seq(0, 2*pi, length.out=100)\ny &lt;- sin(x)           \nplot_ly(x = x, y = y,\n        type = 'scatter',\n        mode = 'lines') |&gt;\n        pshow()\n```\nДолжно стать\n```{r}\n#| warning: false\n#| message: false\n\nlibrary(plotly)\nx &lt;- seq(0, 2*pi, length.out=100)\ny &lt;- sin(x)           \nplot_ly(x = x, y = y,\n        type = 'scatter',\n        mode = 'lines')\n```",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Графическая библиотека plotly</span>"
    ]
  },
  {
    "objectID": "r-tools/plotly.html#sec-r-tools-plotly-line2d",
    "href": "r-tools/plotly.html#sec-r-tools-plotly-line2d",
    "title": "Приложение B — Графическая библиотека plotly",
    "section": "B.2 2D График",
    "text": "B.2 2D График\n\nПример B.1 (Явные вычисления)  \n\nlibrary(plotly)\n1x &lt;- seq(0, 2*pi, length.out=100)\n2y &lt;- sin(x)\n3plot_ly(x = x, y = y,\n4        type = 'scatter',\n5        mode = 'lines') |&gt;\n  pshow()          \n\n\n1\n\nИспользуя функцию seq() создаём вектор x из 100 точек от \\(0\\) до \\(2\\pi\\).\n\n2\n\nПолучаем вектор y применяя функцию sin() к вектору x Глава 6.9\n\n3\n\nВызываем функцию plotly::plot_ly() определяя и передаем данные явным образом Глава 6.12.5.2\n\n4\n\nПараметр type = 'scatter' определяет тип графика: по точкам.\n\n5\n\nПараметр mode = 'lines' определяет тип отображения непрерывной линией\n\n\n\n\n\n\n\n\n\n\nПример B.2 (Неявные вычисления через объект формулы) Предыдущий пример можно упростить использовав специфичную для языка r синтаксическую конструкцию объекта формулы Глава 7.10 . Такой подход применяется если зависимость \\(y=f(x)\\) простая и встречается в коде только один раз.\n\nlibrary(plotly)\n1x &lt;- seq(0, 2*pi, length.out=100)\n2plot_ly(x = x,\n3        y = ~sin(x),\n4        type = 'scatter', mode = 'lines') |&gt;\n  pshow()                                  \n\n\n1\n\nИспользуя функцию seq() создаём вектор x из 100 точек от \\(0\\) до \\(2\\pi\\)\n\n2\n\nПервый аргумент x передаём явным образом.\n\n3\n\nВместо явного задания вектора y передаём в аргумент формулу ~sin(x).\n\n4\n\nОпределяем параметры отображения\n\n\n\n\n\n\n\n\n\n\nПример B.3 (Добавить маркеры)  \n\nlibrary(plotly)\n1x &lt;- seq(0, 2*pi, length.out=10)\n2plot_ly(x = x, y = ~sin(x),\n3        type = 'scatter',\n4        mode = 'lines + markers') |&gt;\n  pshow()\n\n\n1\n\nИспользуя функцию seq() создаём вектор x из 10 точек от \\(0\\) до \\(2\\pi\\)\n\n2\n\nПередаём данные\n\n3\n\nИспользуя тип графика по точкам\n\n4\n\nДля отображения маркеров используется параметр mode = lines + markers.\n\n\n\n\n\n\n\n\n\n\nПример B.4 (Объединить графики)  \n\nlibrary(plotly)\n1x &lt;- seq(0, 2*pi, length.out=100)\n2plot_ly(x = x, y = ~sin(x), type = 'scatter', mode = 'lines',\n3        name = 'sin(x)') |&gt;\n4  add_trace(x = x, y = ~cos(x), type = 'scatter', mode = 'lines',\n5            name = 'cos') |&gt;\n  pshow()                                                \n\n\n1\n\nИспользуя функцию seq() создаём вектор x из 100 точек от \\(0\\) до \\(2\\pi\\)\n\n2\n\nПередаём данные как в примерах выше\n\n3\n\nНазвание перовй линии определяется параметром name = 'sin(x)'. Полученная фигура передаётся в функцию plotly::add_trace() с помощью оператора конвейера ?sec-r-tools-basic-pipe.\n\n4\n\nПараметры plotly::add_trace() аналогичны параметрам plot_ly().\n\n5\n\nНазвание второй линии определяется параметром name = 'cos(x)'.",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Графическая библиотека plotly</span>"
    ]
  },
  {
    "objectID": "r-tools/plotly.html#sec-r-tools-plotly-surface3d",
    "href": "r-tools/plotly.html#sec-r-tools-plotly-surface3d",
    "title": "Приложение B — Графическая библиотека plotly",
    "section": "B.3 3D Поверхность",
    "text": "B.3 3D Поверхность\nОдин из способ построить 3D график это сгенерировать сетку точек в виде матрицы значений \\(z=f(x,y)\\).\n\nПример B.5 (Без масштаба осей) Общий вид графика сохраняется, однако вместо значений по осям x и y будет отложено количество точек, использованное для построения.\n\n1x &lt;- y &lt;- seq(0, pi/2, length.out = 100)\n2z &lt;- outer(x, y,\n3           \\(x,y) { sin(x*y) })  |&gt;\n4  t()\n\n5plot_ly(z = z,\n6        type = \"surface\") |&gt;\n  pshow() \n\n\n1\n\nИспользуя функцию seq() создаём вектор x из 100 точек от \\(0\\) до \\(\\frac{\\pi}{2}\\).\n\n2\n\nС помощью функции outer ?sec-r-tools-basic-outer генерируем матрицу Глава 6.5 размером 100x100\n\n3\n\nДля каждой комбинации x,y будет вызвана переданная лямбда функция Глава 7.11 . Матрица передаётся с помощью оператора конвейера ?sec-r-tools-basic-pipe в функцию транспонирования t().\n\n4\n\nМатрица транспонируется t() для соответствия осей матрицы осям графика.\n\n5\n\nПередаём для построения только z.\n\n6\n\nИспользуется тип графика поверхность.\n\n\n\n\n\n\n\n\n\n\nПример B.6 (С масштабом осей)  \n\n1x &lt;- y &lt;- seq(0, pi/2, length.out = 100)\n2z &lt;- outer(x, y,\n3           \\(x,y) { sin(x*y) })  |&gt;\n4  t()\n\n5plot_ly(z = z, x = x, y = y,\n6        type = \"surface\") |&gt;\n  pshow()                                \n\n\n1\n\nИспользуя функцию seq() создаём вектор x из 100 точек от \\(0\\) до \\(\\frac{\\pi}{2}\\).\n\n2\n\nС помощью функции outer ?sec-r-tools-basic-outer генерируем матрицу Глава 6.5 размером 100x100\n\n3\n\nДля каждой комбинации x,y будет вызвана переданная лямбда функция Глава 7.11 . Матрица передаётся с помощью оператора конвейера ?sec-r-tools-basic-pipe в функцию транспонирования t().\n\n4\n\nМатрица транспонируется t() для соответствия осей матрицы осям графика.\n\n5\n\nПередаём данные для построения, кроме z ещё и x с y.\n\n6\n\nИспользуется тип графика поверхность.",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Графическая библиотека plotly</span>"
    ]
  },
  {
    "objectID": "r-tools/plotly.html#sec-r-tools-plotly-contour2d",
    "href": "r-tools/plotly.html#sec-r-tools-plotly-contour2d",
    "title": "Приложение B — Графическая библиотека plotly",
    "section": "B.4 2D Контурный график",
    "text": "B.4 2D Контурный график\nКонтурные графики позволяют изображать 3D-данные на 2D-графиках. Каждый контур представляет одно значение z.\n\nПример B.7 (Без масштаба осей) Общий вид графика сохраняется, однако вместо значений по осям x и y будет отложено количество точек, использованное для построения.\n\n1x &lt;- y &lt;- seq(0, pi/2, length.out = 100)\n2z &lt;- outer(x, y,\n3           \\(x,y) { sin(x*y) })|&gt;\n4  t()\n\n5plot_ly(z = z,\n6        type='contour') |&gt;\n  pshow() \n\n\n1\n\nИспользуя функцию seq() создаём вектор x из 100 точек от \\(0\\) до \\(\\frac{\\pi}{2}\\).\n\n2\n\nС помощью функции outer ?sec-r-tools-basic-outer генерируем матрицу Глава 6.5 размером 100x100\n\n3\n\nДля каждой комбинации x,y будет вызвана переданная лямбда функция Глава 7.11 . Матрица передаётся с помощью оператора конвейера ?sec-r-tools-basic-pipe в функцию транспонирования t().\n\n4\n\nМатрица транспонируется t() для соответствия осей матрицы осям графика.\n\n5\n\nПередаём данные для построения.\n\n6\n\nИспользуется тип графика контурный.\n\n\n\n\n\n\n\n\n\n\nПример B.8 (С масштабом осей)  \n\n1x &lt;- y &lt;- seq(0, pi/2, length.out = 100)\n2z &lt;- outer(x, y,\n3           \\(x,y) { sin(x*y) })|&gt;\n4  t()\n\n5plot_ly(x = x, y = y, z = z,\n6        type='contour') |&gt;\n  pshow()                               \n\n\n1\n\nИспользуя функцию seq() создаём вектор x из 100 точек от \\(0\\) до \\(\\frac{\\pi}{2}\\).\n\n2\n\nС помощью функции outer() ?sec-r-tools-basic-outer генерируем матрицу Глава 6.5 размером 100x100\n\n3\n\nДля каждой комбинации x,y будет вызвана переданная лямда функция Глава 7.11 . Матрица передаётся с помощью оператора конвейера ?sec-r-tools-basic-pipe в функцию транспонирования t().\n\n4\n\nМатрица транспонируется t() для соответствия осей матрицы осям графика.\n\n5\n\nПередаём данные для построения, кроме z ещё и x с y.\n\n6\n\nИспользуется тип графика контурный.",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Графическая библиотека plotly</span>"
    ]
  },
  {
    "objectID": "r-tools/plotly.html#sec-r-tools-plotly-slice3d",
    "href": "r-tools/plotly.html#sec-r-tools-plotly-slice3d",
    "title": "Приложение B — Графическая библиотека plotly",
    "section": "B.5 3D График плотности срезов",
    "text": "B.5 3D График плотности срезов\nСоздаёт контурный график по поверхности среза как функцию \\(u=f(x,y,z)\\).\n\nlibrary(plotly)\n\n1f &lt;- \\(x,y,z) x^2-5*y^2-3*z^2+x*y-2*x*z+2*y*z+11*x+2*y+18*z+10\n2x &lt;- y &lt;- z &lt;- seq(-5, 5, length.out = 20)\n3d &lt;- tidyr::crossing(x = x, y = y, z = z)\n4u &lt;- purrr::pmap_dbl(d,f)\n\n5plot_ly(data = d,\n6  type='isosurface',\n7  x = ~x, y = ~y, z = ~z,\n8  value = u,\n9  isomin = -100, isomax = 100,\n10  colorscale='RdBu',\n11  surface = list(show = TRUE, count = 1),\n12  slices = list(z = list(show = TRUE, locations = -5:5),\n13                y = list(show = TRUE, locations = 0)),\n14  caps = list(x = list(show = FALSE),\n15              y = list(show = FALSE))) |&gt;\n  pshow_protected()\n\n\n1\n\nЗадаём функцию \\(u=f(x,y,z)\\) с помощью лямда функции Глава 7.11.\n\n2\n\nИспользуя функцию seq() создаём вектора x,y,z из \\(20\\) точек от \\(-5\\) до \\(5\\).\n\n3\n\nС помощью функции ?sec-r-tools-tidyr-crossing генерируем датафрейм ?sec-r-tools-tibble размером 20x20x20 в котором будут все комбинации значений переменных x, y и z.\n\n4\n\nПрименяем функцию f к каждой строке датафрейма d с помощью функции purrr::pmap_dbl() Глава C.1 в результате получаем вектор u, который содержит значения функции для всех точек её области определения.\n\n5\n\nВызываем функцию построения графика plotly::plot_ly() и передаём туда датафрейм с координатами точек построения.\n\n6\n\nОпределяем тип графика контурные поверхности\n\n7\n\nС помощью формул Глава 7.10 показываем от каких переменных из датафрейма зависят оси.\n\n8\n\nПередаём вектор со значениями функции\n\n9\n\nОпределяем минимальное и максимальное значение u для отрисовки контурных линий.\n\n10\n\nВыбираем нестандартную цветовую палитру для лучшей визуализации.\n\n11\n\nДобавляем на график одну поверхность соответствующую уравнению \\(u=f(x,y,z)=const\\)\n\n12\n\nДобавляем 5 срезы по оси z от \\(-5\\) до \\(5\\) с шагом \\(1\\)\n\n13\n\nДобавляем один срез по оси y\n\n14\n\nОтключаем отображение координатной сетки по оси x\n\n15\n\nОтключаем отображение координатной сетки по оси y",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Графическая библиотека plotly</span>"
    ]
  },
  {
    "objectID": "r-tools/plotly.html#sec-r-tools-plotly-combine",
    "href": "r-tools/plotly.html#sec-r-tools-plotly-combine",
    "title": "Приложение B — Графическая библиотека plotly",
    "section": "B.6 Комбинированные графики",
    "text": "B.6 Комбинированные графики\nМожно добавлять элементы на график последовательно отображая их.\n\nlibrary(plotly)\nx &lt;- y &lt;- seq(0, pi/2, length.out = 100)\nz &lt;- outer(x, y, \\(x,y) { sin(x*y) })|&gt;t()\n\nfig &lt;- plot_ly(x = x, y = y, z = z, type='contour')\nfig |&gt; pshow()\n\n\n\n\n\nТеперь добавим линию\n\nfig &lt;- fig |&gt; add_trace(x = x,\n                        y = ~cos(x),\n                        type = 'scatter',\n                        mode = 'lines', \n                        name = 'cos')\nfig |&gt; pshow_protected()\n\n\n\n\n\n\nИ выделим точки на этой линии\n\nfig &lt;- fig |&gt; \n  add_trace(x = c(0.4, 0.6, 1),\n            y = cos(c(0.4,0.6,1)),\n            type = 'scatter',\n            mode = 'markers',\n            name = 'points',\n              marker = list(color = 'red'))\nfig |&gt; pshow_protected()",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Графическая библиотека plotly</span>"
    ]
  },
  {
    "objectID": "r-tools/plotly.html#sec-r-tools-plotly-extra",
    "href": "r-tools/plotly.html#sec-r-tools-plotly-extra",
    "title": "Приложение B — Графическая библиотека plotly",
    "section": "B.7 Дополнительные возможности",
    "text": "B.7 Дополнительные возможности",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Графическая библиотека plotly</span>"
    ]
  },
  {
    "objectID": "r-tools/purrr.html",
    "href": "r-tools/purrr.html",
    "title": "Приложение C — Функциональные операторы Purrr",
    "section": "",
    "text": "C.1 pmap",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Функциональные операторы Purrr</span>"
    ]
  },
  {
    "objectID": "r-tools/lpsolve.html",
    "href": "r-tools/lpsolve.html",
    "title": "Приложение D — Решатель LPSolve",
    "section": "",
    "text": "D.1 lpSolve",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Решатель LPSolve</span>"
    ]
  },
  {
    "objectID": "r-tools/lpsolve.html#sec-r-tools-lpsolve-lpsolve",
    "href": "r-tools/lpsolve.html#sec-r-tools-lpsolve-lpsolve",
    "title": "Приложение D — Решатель LPSolve",
    "section": "",
    "text": "D.1.1 Установка\n\n\n\n\n\n\nВажное уведомление\n\n\n\nУбедитесь в том, что Rtools установлены в системе Глава 1.2\n\n\n```{r}\ninstall.packages('lpSolve')\n```\n\n\nD.1.2 Модель\nНа основе примера Пример D.1. Для начала требуется определить целевую функцию \\(\\mathrm{Z}\\). В пакете lpsolve целевая функция задается как вектор Глава 6.3 коэффициентов.\n\nZ &lt;- c(11, 5, 4)\n\nОграничения задаются в виде матрицы коэффициентов \\(\\mathbf{A}\\). Пакет может работать с общей формулировкой задачи Глава 1, поэтому приведение к стандартной форме не требуется\n\nA &lt;- rbind(c(3, 2, 8),\n           c(2, 0, 1),\n           c(3, 3, 1))\n\n\n\n\n\n\n\nСовет\n\n\n\nЕсли требуется задать ограничения вида \\(x_i\\leq b_i, \\quad \\forall x_i\\) то рекомендуется задать коэффициенты матрицы \\(\\mathbf{A}\\) ограничений (единичную матрицу Определение 8.6) с помощью функции функцию diag(). Например\n\ndiag(3)\n\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n[3,]    0    0    1\n\n\n\n\nПравые части и знаки ограничений задаются отдельно\n\nB &lt;- c(11, 5, 13)\nS &lt;- c('&lt;=', '&lt;=', '&lt;=')\n\n\n\n\n\n\n\nСовет\n\n\n\nЕсли требуется задать много однотипных ограничен рекомендуемый применить функцию rep() . Например {r} B &lt;- rep('&lt;=', 10).\n\n\n\n\nD.1.3 Решение\nДля поиска решения вызывается функция lpSolve::lp()\n\nlibrary(lpSolve)\n\noptimum &lt;- lp(           \n1  direction = 'max',\n2  objective.in = Z,\n3  const.mat = A,\n4  const.dir = S,\n5  const.rhs = B,\n6  compute.sens = TRUE)\noptimum\n\n\n1\n\nЗадать направление оптимизации: максимизацию 'max' или минимизацию 'min'\n\n2\n\nЗадать целевую (objective) функцию вектором коэффициентов.\n\n3\n\nЗадать матрицу коэффициентов ограничений.\n\n4\n\nЗадать знаки ограничений символьным вектором\n\n5\n\nЗадать вектор правых частей ограничений.\n\n6\n\nДополнительно рассчитать чувствительность оптимального решения\n\n\n\n\nSuccess: the objective function is 36.25 \n\n\nМаксимальное значение целевой функции получается\n\noptimum$objval\n\n[1] 36.25\n\n\nЭто значение достигается при следующих значения переменных. Его можно получить из объекта решения optimum по ключу solution\n\noptimum$solution\n\n[1] 2.50 1.75 0.00\n\n\n\n\n\n\n\n\nСовет\n\n\n\nЕсли в задаче много переменных, то иногда бывает трудно определить какие из них приняли ненулевые значения. Отображения результатов можно упростить используя функцию which()\nНапример\n\nx &lt;- c(0,1,2,0,4,5,0,6,8,0,0,1)\nx\n\n [1] 0 1 2 0 4 5 0 6 8 0 0 1\n\n\nУзнать индексы ненулевых элементов\n\nind &lt;- which(x!=0)\nind\n\n[1]  2  3  5  6  8  9 12\n\n\nИ вывести только ненулевые элементы\n\nx[ind]\n\n[1] 1 2 4 5 6 8 1\n\n\n\n\n\n\nD.1.4 Анализ чувствительности оптимального решения\n\nЦелевой функции\nДиапазон в кортом можно изменять коэффициенты целевой функции Глава 10.1 не меняя при этом характер решения (точку, соответствующую оптимальному решению) можно определить следующим образом\n\noptimum$sens.coef.from\n\n[1]  7.5e+00  0.0e+00 -1.0e+30\n\noptimum$sens.coef.to\n\n[1] 1.000000e+30 7.333333e+00 2.175000e+01\n\n\nСоответственно точка \\(( 2.5,1.75,0 )\\) соответствующая оптимальному решению не сдвинется, если по одному изменять коэффициенты в следующих пределах\n\\[\n\\begin{aligned}\n&7.5  \\leq c_1 \\leq 10^{30}\\\\\n&0  \\leq c_2 \\leq 7.3333333\\\\\n&-10^{30}  \\leq c_3 \\leq 21.75\n\\end{aligned}\n\\]\n\n\nОграничений\nКоэффициенты чувствительности по ограничениям Глава 10.2 (также встречается название двойственные значения).\n\noptimum$duals\n\n[1]   2.50   1.75   0.00   0.00   0.00 -17.75\n\n\nЭто значение показывает как измениться целевая функция при изменении правой части ограничения на единицу.\nНапример значение целевой функции измениться с \\(36.25\\) на \\(38.75\\) (шаг \\(2.5\\)) при изменении ограничения \\(3x_1+2x_2+8x_3 \\leq 11\\) на ограничение \\(3x_1+2x_2+8x_3 \\leq 12\\).\nОбратите внимание, количество двойственных значений гораздо больше, чем количество ограничений, которые были заданы в задаче изначально. Дело в том, что пакет неявным образом добавляет в модель ограничения вида \\(x_i \\geq 0 ,\\forall x_i\\), если другого не заданно. Это сделано для удобства разработчика.\nДалее определяется диапазон в котором действительно данное двойственное значение.\n\noptimum$sens.coef.from\n\n[1]  7.5e+00  0.0e+00 -1.0e+30\n\noptimum$sens.coef.from\n\n[1]  7.5e+00  0.0e+00 -1.0e+30\n\n\nТаким образом для первого ограничения \\(3x_1+2x_2+8x_3 \\leq 11\\) двойственное значение \\(2.5\\) сохраняется при изменении правой части \\(7.5 \\leq b_1 \\leq 7.5\\)\n\n\n\nD.1.5 Целочисленная модель\nДля решения задачи Пример D.1 в целых числах при построении модели добавляется параметр all.int=TRUE. В этом случае анализ чувствительности Глава D.1.4 не применим и параметр compute.sens = TRUE будет проигнорирован\n\noptimum &lt;- lp(           \n  direction = 'max',\n  objective.in = Z,\n  const.mat = A,\n  const.dir = S,\n  const.rhs = B,\n  all.int = TRUE)\noptimum\n\nSuccess: the objective function is 32 \n\noptimum$solution\n\n[1] 2 2 0\n\n\nАналогично для решения задачи двоичного программирования устанавливается параметр all.bin=TRUE\n\noptimum &lt;- lp(           \n  direction = 'max',\n  objective.in = Z,\n  const.mat = A,\n  const.dir = S,\n  const.rhs = B,\n  all.bin = TRUE)\noptimum\n\nSuccess: the objective function is 16 \n\noptimum$solution\n\n[1] 1 1 0\n\n\nЗадача целочисленного и двоичного программирования в пакете lpSolve решается методом ветвей и границ ?sec-linear-integer-method-branch-and-bound.",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Решатель LPSolve</span>"
    ]
  },
  {
    "objectID": "r-tools/lpsolve.html#sec-r-tools-lpsolve-lpsolveapi",
    "href": "r-tools/lpsolve.html#sec-r-tools-lpsolve-lpsolveapi",
    "title": "Приложение D — Решатель LPSolve",
    "section": "D.2 lpSolveAPI",
    "text": "D.2 lpSolveAPI\n\nD.2.1 Установка\n\n\n\n\n\n\nВажное уведомление\n\n\n\nУбедитесь в том, что Rtools установлены в системе Глава 1.2\n\n\n```{r}\ninstall.packages('lpSolveAPI')\n```\n\n\nD.2.2 Модель\nНа основе примера Пример D.1 создаём объект модели задачи линейного программирования lpSolveAPI::make.lp() с 3 переменными и 0 ограничений (будут добавлены позднее).\n\nlibrary(lpSolveAPI)\nlprob &lt;- make.lp(0, 3)\n\nДалее выбирается тип оптимизации lpSolveAPI::lp.control(), в данном случае максимизация. Вывод функции подавляется с помощью invisible(), чтобы отменить печать информации на экран.\n\ninvisible(lp.control(lprob, sense = 'max'))\n\nДалее задаются ограничения. Ограничения матрицы \\(\\mathbf{A}\\) вводятся построчно lpSolveAPI::add.constraint(). По умолчанию на переменные накладывается условие \\(\\forall{i}: x_i\\geq0\\)\n\nadd.constraint(lprob, c(3, 2, 8), '&lt;=', 11)\nadd.constraint(lprob, c(2, 0, 1), '&lt;=', 5)\nadd.constraint(lprob, c(3, 3, 1), '&lt;=', 13)\n\nЗадание целевой функции lpSolveAPI::set.objfn(). Объект модели можно конструировать в произвольном порядке\n\nset.objfn(lprob, c(11, 5, 4))\n\nИтоговое представление модели можно получить вызвав объект модели\n\nlprob\n\nModel name: \n            C1    C2    C3        \nMaximize    11     5     4        \nR1           3     2     8  &lt;=  11\nR2           2     0     1  &lt;=   5\nR3           3     3     1  &lt;=  13\nKind       Std   Std   Std        \nType      Real  Real  Real        \nUpper      Inf   Inf   Inf        \nLower        0     0     0        \n\n\n\n\nD.2.3 Решение\nДалее вызовом lpSolveAPI::solve() полученная модель решается. В случае успеха возвращается status_code == 0\n\nstatus_code &lt;- solve(lprob)\nstatus_code\n\n[1] 0\n\n\nНаилучшее значение целевой функции lpSolveAPI::get.objective()\n\nget.objective(lprob)\n\n[1] 36.25\n\n\nЗначение переменных, при которых достигнуто максимальное значение целевой функции lpSolveAPI::get.variables()\n\nget.variables(lprob)\n\n[1] 2.50 1.75 0.00\n\n\n\n\nD.2.4 Анализ чувствительности оптимального решения\n\nЦелевая функция\nПолучим список с двумя ключами objfrom и objtill с помощью функции lpSolveAPI::get.sensitivity.obj()\n\nget.sensitivity.obj(lprob)\n\n$objfrom\n[1]  7.5e+00  0.0e+00 -1.0e+30\n\n$objtill\n[1] 1.000000e+30 7.333333e+00 2.175000e+01\n\n\nСоответственно точка \\(( 2.5,1.75,0 )\\) соответствующая оптимальному решению не сдвинется, если по одному изменять коэффициенты в следующих пределах\n\\[\n\\begin{aligned}\n&7.5  \\leq c_1 \\leq 10^{30}\\\\\n&0  \\leq c_2 \\leq 7.3333333\\\\\n&-10^{30}  \\leq c_3 \\leq 21.75\n\\end{aligned}\n\\]\n\n\nОграничения\nДля анализа чувствительности ограничений применяется функция lpSolveAPI::get.sensitivity.rhs().\n\nget.sensitivity.rhs(lprob)\n\n$duals\n[1]   2.50   1.75   0.00   0.00   0.00 -17.75\n\n$dualsfrom\n[1]  7.500000e+00  4.666667e+00 -1.000000e+30 -1.000000e+30 -1.000000e+30\n[6] -2.439024e-02\n\n$dualstill\n[1] 1.116667e+01 7.333333e+00 1.000000e+30 1.000000e+30 1.000000e+30\n[6] 5.384615e-01\n\n\nЭто значение показывает как измениться целевая функция при изменении правой части ограничения на единицу.\nНапример значение целевой функции измениться с \\(36.25\\) на \\(38.75\\) (шаг \\(2.5\\)) при изменении ограничения \\(3x_1+2x_2+8x_3 \\leq 11\\) на ограничение \\(3x_1+2x_2+8x_3 \\leq 12\\).\nОбратите внимание, количество двойственных значений гораздо больше, чем количество ограничений, которые были заданы в задаче изначально. Дело в том, что пакет неявным образом добавляет в модель ограничения вида \\(x_i \\geq 0 ,\\forall x_i\\), если другого не заданно. Это сделано для удобства разработчика.\nТаким образом для первого ограничения \\(3x_1+2x_2+8x_3 \\leq 11\\) двойственное значение \\(2.5\\) сохраняется при изменении правой части \\(7.5 \\leq b_1 \\leq 11.1666667\\)\nset.objfn(LP, c(-mat[, 'score'], 0, 0))\nset.type(LP, n+1, \"binary\")\nset.type(LP, n+2, \"binary\")\nset.bounds(LP, lower = c(mat[, 'lb'], 0, 0))\nset.bounds(LP, upper = c(mat[, 'ub'], 1, 1))",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Решатель LPSolve</span>"
    ]
  }
]