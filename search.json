[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Исследование операций",
    "section": "",
    "text": "Интерактивный курс по исследованию операций\nОбзор методов и разделов.\nNeos alghorytm guide\nhttps://cran.r-project.org/web/views/Optimization.html",
    "crumbs": [
      "Интерактивный курс по исследованию операций"
    ]
  },
  {
    "objectID": "index.html#sec-index-syllabus",
    "href": "index.html#sec-index-syllabus",
    "title": "Исследование операций",
    "section": "Программа курса",
    "text": "Программа курса\nОформление отчёта по компьютерной части ?sec-lab-report. В лабораторных работах решаются задания уровней 1 – 3\n\nЗанятие 1\n\n\n\n\n\n\n\n\nРаздел\nЗадания\nОценка\n\n\n\n\nКомпьютер\n\n17  R\n21  Введение\n18  Линейная алгебра\n\n\n2\n2\n1\n\n\n\nПрактика\n\n31  Модели исследования операций\n32  Линейная алгебра\n\n\n3\n1\n\n\n\nТест\n\n?sec-exam-basic-model\n\n\n0\n\n\n\n\n\n\nЗанятие 2\n\n\n\n\n\n\n\n\nРаздел\nЗадания\nОценка\n\n\n\n\nКомпьютер\n\n22  Линейное программирование\n\n\n5\n\n\n\nПрактика\n\n33  Линейное программирование. Графическое представление\n34  Линейное программирование. Модели\n35  Линейное программирование. Симплекс метод\n\n\n1.5\n1.5\n2\n\n\n\nТест\n\n?sec-exam-linear\n\n\n0\n\n\n\n\n\n\nЗанятие 3\n\n\n\n\n\n\n\n\nРаздел\nЗадания\nОценка\n\n\n\n\nКомпьютер\n\n24  Целочисленное линейное программирование\n23  Транспортные модели\n\n\n2\n8\n\n\n\n\n\n\nЗанятие 4\n\n\n\n\n\n\n\n\nРаздел\nЗадания\nОценка\n\n\n\n\nКомпьютер\n\n?sec-lab-alghorithm-graph-theory\n25  Сетевые модели\n\n\n2\n8\n\n\n\nПрактика\n\n?sec-practice-network\n\n\n0\n\n\n\nТест\n\n?sec-exam-network\n\n\n0\n\n\n\n\n\n\nЗанятие 5\n\n\n\n\n\n\n\n\nРаздел\nЗадания\nОценка\n\n\n\n\nКомпьютер\n19  Нелинейное программирование 26  Нелинейная оптимизация\n0\n\n\nТест\n?sec-exam-nonlinear\n0\n\n\n\n\n\nЗанятие 6\n\n\n\n\n\n\n\n\nРаздел\nЗадания\nОценка\n\n\n\n\nКомпьютер\n20  Эволюционная оптимизация 27  Эволюционная оптимизация\n0\n\n\nПрактика\n?sec-practice-evolutionary\n0\n\n\nТест\n?sec-exam-evolutionary\n0\n\n\n\n\n\nЗанятие 7\n\n\n\nРаздел\nЗадания\nОценка\n\n\n\n\nКомпьютер\n?sec-lab-model-game-theory\n0\n\n\nПрактика\n?sec-practice-game-theory\n0\n\n\n\n\n\nЭкзамен автоматом\n4 уровень — творческое задание, имеющее несколько правильных решений.\n\n\n\n\n\n\n\nРаздел\nЗадания\n\n\n\n\nКомпьютер\n\n28  R\n?sec-lab-extra-linear\n29  Cетевые модели\n?sec-lab-extra-nonlinear\n30  Эволюционная оптимизация\n?sec-lab-extra-genetic\n\n\n\nПрактика\n\n?sec-practice-nonlinear",
    "crumbs": [
      "Интерактивный курс по исследованию операций"
    ]
  },
  {
    "objectID": "enviroment/overview.html",
    "href": "enviroment/overview.html",
    "title": "Среда разработки",
    "section": "",
    "text": "Важное уведомлениеСостояние разработки\n\n\n\nВ разработке\n\n\nНабор инструментов позволяет создавать современные отчёты и не только. Здесь пару примеров.",
    "crumbs": [
      "Среда разработки"
    ]
  },
  {
    "objectID": "enviroment/setup.html",
    "href": "enviroment/setup.html",
    "title": "1  Установка и настройка",
    "section": "",
    "text": "1.1 R\nДля установки на другие платформы смотрите https://cloud.r-project.org/",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Установка и настройка</span>"
    ]
  },
  {
    "objectID": "enviroment/setup.html#sec-enviroment-setup-r",
    "href": "enviroment/setup.html#sec-enviroment-setup-r",
    "title": "1  Установка и настройка",
    "section": "",
    "text": "1.1.1 Установка\n\nWindowsArch linux\n\n\nСкачать и установить\nhttps://cran.r-project.org/bin/windows/base/release.html\n\n\n\n\n\n\nСовет\n\n\n\nРекомендуется установить в расположение по умолчанию. Иначе придется настраивать пути в ручную для RStudio или через переменные среды.\n\n\n\n\nhttps://archlinux.org/packages/extra/x86_64/r/\nsudo pacman -S r\n\n\n\n\n\n1.1.2 Дальнейшие действия\nПроверит установку можно вызвав интерпретатор R:\nRscript --version\nполучается следующий вывод\nRscript (R) version 4.4.2 (2024-10-31)",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Установка и настройка</span>"
    ]
  },
  {
    "objectID": "enviroment/setup.html#sec-enviroment-setup-rtools",
    "href": "enviroment/setup.html#sec-enviroment-setup-rtools",
    "title": "1  Установка и настройка",
    "section": "1.2 RTools",
    "text": "1.2 RTools\nВ состав RTools входят компиляторы C, C++, Fortran, библиотеки линейной алгебры LAPAK и BLAS, и другие утилиты необходимые для сборки некоторых пакетов в R. Название RTools специфично для Windows, для других платформ требуется установить отдельные пакеты.\n\n1.2.1 Установка\n\nWindowsArch linux\n\n\nСкачать и установить\nhttps://cran.r-project.org/bin/windows/Rtools/rtools44/rtools.html\n\n\n\n\n\n\nСовет\n\n\n\nРекомендуется установить в расположение по умолчанию. Иначе придется настраивать пути в ручную для RStudio или через переменные среды.\n\n\n\n\nsudo pacman -S blas-openblas gcc-fortran gcc\n\n\n\n\n\n1.2.2 Дальнейшие действия\nДля проверки установки рекмендуется выполнить в командной строке\nRscript -e \"install.packages('lpSolve'); library(lpSolve)\"\nЕсли установка прошла успешно, то команда завершится с кодом 0 (ничего не выведет).",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Установка и настройка</span>"
    ]
  },
  {
    "objectID": "enviroment/setup.html#sec-enviroment-setup-rstudio",
    "href": "enviroment/setup.html#sec-enviroment-setup-rstudio",
    "title": "1  Установка и настройка",
    "section": "1.3 RStudio",
    "text": "1.3 RStudio\n\n1.3.1 Установка\n\nWindowsArch linux\n\n\nСкачать и установить\nhttps://rstudio.org/download/latest/stable/desktop/windows/RStudio-latest.exe\n\n\nyay -S rstudio-desktop-daily-bin\n\n\n\n\n\n1.3.2 Дальнейшие действия\nПосле установки проверить создание проекта Глава 2 .",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Установка и настройка</span>"
    ]
  },
  {
    "objectID": "enviroment/setup.html#sec-enviroment-setup-vscode",
    "href": "enviroment/setup.html#sec-enviroment-setup-vscode",
    "title": "1  Установка и настройка",
    "section": "1.4 VSCode",
    "text": "1.4 VSCode\nДля работы с VSCode требуется установить расширение Quarto.",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Установка и настройка</span>"
    ]
  },
  {
    "objectID": "enviroment/setup.html#sec-enviroment-setup-quarto",
    "href": "enviroment/setup.html#sec-enviroment-setup-quarto",
    "title": "1  Установка и настройка",
    "section": "1.5 Quarto",
    "text": "1.5 Quarto\nДалее приводится отдельная установка, которая подходит если не используется RStudio, например VSCode или Vim. Quarto входит в состав RStudio Глава 1.3 поэтому этот шаг можно пропустить.\n\n1.5.1 Установка\n\nWindowsArch linux\n\n\nСкачать и установить\nhttps://github.com/quarto-dev/quarto-cli/releases/download/v1.6.41/quarto-1.6.41-win.msi\n\n\nyay -S quarto-cli-bin-pre-release\n\n\n\n\n\n1.5.2 Дальнейшие действия\nПосле установки изучите Глава 3 для создания проекта.",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Установка и настройка</span>"
    ]
  },
  {
    "objectID": "enviroment/rstudio.html",
    "href": "enviroment/rstudio.html",
    "title": "2  RStudio IDE",
    "section": "",
    "text": "2.1 Quarto",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>RStudio IDE</span>"
    ]
  },
  {
    "objectID": "enviroment/rstudio.html#sec-enviroment-rstudio-quarto",
    "href": "enviroment/rstudio.html#sec-enviroment-rstudio-quarto",
    "title": "2  RStudio IDE",
    "section": "",
    "text": "2.1.1 Создать новый документ\n\n\n\nМеню создания документа\n\n\n\n\n\nОпции при создании документа\n\n\n\n\n2.1.2 Визуальный редактор\n\n\n\nПример в визуальном редакторе\n\n\n\nФорматирование\n\n\n\nМеню форматирование\n\n\n\n\nЗаголовки\n\n\n\nМеню стиля заголовка\n\n\n\n\nВставка ресурсов\n\n\n\nВставка ресурсов\n\n\n\n\nВставка изображения\n\n\n\nМеню вставки изображения\n\n\n\n\nВставка ссылки\n\n\n\nМеню вставки ссылки\n\n\n\n\nРедактирование таблиц\n\n\n\nМеню редактора таблиц\n\n\n\n\n\n2.1.3 Редактор исходного кода\n\n\n\nРедактор исходного кода",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>RStudio IDE</span>"
    ]
  },
  {
    "objectID": "enviroment/rstudio.html#sec-enviroment-rstudio-shortcuts",
    "href": "enviroment/rstudio.html#sec-enviroment-rstudio-shortcuts",
    "title": "2  RStudio IDE",
    "section": "2.2 Сочетание клавиш",
    "text": "2.2 Сочетание клавиш\nБольшинство сочетаний клавиш работают в visual режиме. Вызов меню интерактивного выбора для вставки конвента Crtl-/Crtl-/\n\n\n2.2.1 Форматирование и написание текста\nВыделив текст к нему можно применить стили\n\n\n\n\n\n\n\nДействие\nСочетание клавиш\n\n\n\n\nЖирный\nCtrl-BCtrl-B\n\n\nКурсив\nCtrl-ICtrl-I\n\n\nКод\nCtrl-DCtrl-D\n\n\nВставить ссылку\nCtrl-KCtrl-K\n\n\nВставить изображение\nCtrl-Shift-ICtrl-Shift-I\n\n\nОтменить действие\nCtrl-ZCtrl-Z\n\n\nПовторить отмененное действие\nCtrl-Shift-ZCtrl-Shift-Z\n\n\nСвернуть все блоки (текст и код)\nAlt-OAlt-O\n\n\nРазвернуть все блоки (текст и код)\nAlt-Shift-OAlt-Shift-O\n\n\n\n\n\n2.2.2 Код\n\n\n\n\n\n\n\nДействие\nСочетание клавиш\n\n\n\n\nВставить блок кода на языке R\nCtrl-Alt-ICtrl-Alt-I\n\n\nПрисваивание на языке R &lt;-\nAlt--Alt--\n\n\nВыполнить блок кода\nCrtl-Shift-EnterCrtl-Shift-Enter, Ctrl-Alt-CCtrl-Alt-C\n\n\nВыполнить предыдущий блок кода\nCrtl-Shift-Alt-PCrtl-Shift-Alt-P\n\n\nВыполнить все предидущие блоки кода\nCtrl-Alt-PCtrl-Alt-P\n\n\nВыполнить следующий блок кода\nCtrl-Alt-NCtrl-Alt-N\n\n\nВыполнить все блоки кода\nCtrl-Alt-RCtrl-Alt-R\n\n\nАвтодополнение кода\nTabTab, Ctrl-SpaceCtrl-Space\n\n\n\n\n\n2.2.3 Рендеринг\nВызов предпросмотра в файлах и проектах Quarto .qmd или конвертации в .Rmd Ctrl-Shift-KCtrl-Shift-K",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>RStudio IDE</span>"
    ]
  },
  {
    "objectID": "enviroment/quarto.html",
    "href": "enviroment/quarto.html",
    "title": "3  Quarto",
    "section": "",
    "text": "3.1 Установка примера\nПри использовании из командной строки без IDE.\nОткрыть файл примера кода\nВызвав интерактивный сеанс R установить пакеты\nЕсли пакет tidyverse устанавливается с ошибками см. пункт renv",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "enviroment/quarto.html#sec-enviroment-quarto-example-install",
    "href": "enviroment/quarto.html#sec-enviroment-quarto-example-install",
    "title": "3  Quarto",
    "section": "",
    "text": "⤓ example.qmd\n\n\n\n\n```{r}\ninstall.packages(\"ggplot2\")\ninstall.packages(\"palmerpenguins\")\n```",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "enviroment/quarto.html#sec-enviroment-quarto-render",
    "href": "enviroment/quarto.html#sec-enviroment-quarto-render",
    "title": "3  Quarto",
    "section": "\n3.2 Render",
    "text": "3.2 Render\nПри рендеринге Quarto генерирует новый файл, содержащий выделенный текст, код и результаты из файла .qmd. Новый файл может представлять собой документ HTML, PDF, MS Word и другие форматы. По умолчанию Quarto рендерит в HTML . Например:\nquarto render example.qmd\nРезультат выполнения команды\nprocessing file: example.qmd\n1/5                \n2/5 [load-packages]\n3/5                \n4/5 [plot-penguins]\n5/5                \noutput file: example.knit.md\n\npandoc \n  to: html\n  output-file: example.html\n  standalone: true\n  section-divs: true\n  html-math-method: mathjax\n  wrap: none\n  default-image-extension: png\n  \nmetadata\n  document-css: false\n  link-citations: true\n  date-format: long\n  lang: en\n  title: Пример блокнота Quarto\n  editor: visual\n  \nOutput created: example.html\nexample.html представляет собой Рисунок 3.1",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "enviroment/quarto.html#sec-enviroment-quarto-preview",
    "href": "enviroment/quarto.html#sec-enviroment-quarto-preview",
    "title": "3  Quarto",
    "section": "\n3.3 Preview",
    "text": "3.3 Preview\nРендеринг и предварительный просмотр документа или проекта веб-сайта. Автоматически перезагружает браузер при изменении входных файлов или ресурсов документа. При предварительном просмотре для рендеринга используются самые последние результаты выполнения вычислительных документов.\nquarto preview example.qmd\nРезультат выполнения команды примерно такой:\nprocessing file: example.qmd\n1/5                \n2/5 [load-packages]\n3/5                \n4/5 [plot-penguins]\n5/5                \noutput file: example.knit.md\n\npandoc \n  to: html\n  output-file: example.html\n  standalone: true\n  section-divs: true\n  html-math-method: mathjax\n  wrap: none\n  default-image-extension: png\n  \nmetadata\n  document-css: false\n  link-citations: true\n  date-format: long\n  lang: en\n  title: Пример блокнота Quarto\n  editor: visual\n  \nOutput created: example.html\n\nWatching files for changes\nBrowse at http://localhost:7980/\nВ браузере отобразится следующая страничка\n\n\n\n\n\nРисунок 3.1: Пример preview в html",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "enviroment/markdown.html",
    "href": "enviroment/markdown.html",
    "title": "4  Язык разметки Markdown",
    "section": "",
    "text": "4.1 Блоки кода\nдиаграмма обработки markdown\nРабочие блокноты Quarto основаны на проекте Pandoc и используют язык разметки Мarkdown.\nMarkdown — это простой текстовый формат, который легко писать и, что еще более важно, легко читать:\nРассмотрим наиболее часто встречаемые примитивы разметки\nQuarto позволяет объединить исполняемый код и сопутствующее описание в готовый документ. Чтобы узнать больше о Quarto, посетите https://quarto.org. Блоки кода, которые используют фигурные скобки вокруг имени языка (например, ```{r}), являются исполняемыми и будут запущены Quarto во время рендеринга\nВ результате получим следующее. Рисунок 4.1 более подробно изучает влияние температуры на уровень озона.\nlibrary(ggplot2)\n\nggplot(airquality, aes(Temp, Ozone)) + \n  geom_point() + \n  geom_smooth(method = \"loess\")\n\n\n\n\n\n\nРисунок 4.1: Температура и уровень озона.\nИз исполняемых блоков кода можно создавать самые разные типы выходных данных, включая графики, таблицы и простой текст.",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Язык разметки Markdown</span>"
    ]
  },
  {
    "objectID": "enviroment/markdown.html#sec-markdown-codeblocks",
    "href": "enviroment/markdown.html#sec-markdown-codeblocks",
    "title": "4  Язык разметки Markdown",
    "section": "",
    "text": "## Качество воздуха\n\n@fig-airquality более подробно изучает влияние температуры на уровень озона.\n\n```{r}\n#| label: fig-airquality\n#| fig-cap: \"Температура и уровень озона.\"\n#| warning: false\n\nlibrary(ggplot2)\n\nggplot(airquality, aes(Temp, Ozone)) + \n  geom_point() + \n  geom_smooth(method = \"loess\")\n```\n\n\n\n\n4.1.1 Встраиваемый код\nВстраиваемый (Inline) код позволяет вам выполнять код в markdown, например, для автоматического использования самых последних вычислений в повествовании. Синтаксис встроенного кода похож на блоки кода, за исключением того, что используеся один тик (`) вместо тройных тиков (```). Встраиваемый код может использоваться в середине markdown. Например, следующий код сохраняет переменную radius в блоке кода, а затем обращается к ней в предложении с помощью встроенного кода:\n```{r}\nradius &lt;- 5\n```\n\nThe radius of the circle is `{r} radius`\nВ результате получаем:\nThe radius of the circle is 5.\n\n\n\n\n\n\nОсторожность\n\n\n\nВстроенные выражения должны быть ограничены простыми значениями, которые предварительно вычисляются в обычных ячейках кода (а не вызовами функций, которые выполняют нетривиальную работу). Это связано с тем, что протокол, используемый для встроенных выражений, несовместим с библиотеками, использующими многопоточность.\n\n\n\n4.1.2 Разные языки в одном документе\nДвижки рендеринга Knitr и Jupyter позволяют совмещать вычисления на разных языках в одном документе. Например:\n\n```{r}\n#| cache: true\nplot(pressure, pch=21, col='blue', bg='lightblue')\n```\n\n\n\n\n\n\n\n\n```{python}\n#| warning: false\n#| message: false\n#| error: false\n#| cache: true\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Data for plotting\nt = np.arange(0.0, 2.0, 0.01)\ns = 1 + np.sin(2 * np.pi * t)\n\nfig, ax = plt.subplots()\nax.plot(t, s)\n\nax.set(xlabel='time (s)', ylabel='voltage (mV)',\n       title='About as simple as it gets, folks')\nax.grid()\n\nfig.savefig(\"test.png\")\nplt.show()\n```\n\n\n\n\n\n\n\n```{julia}\n#| warning: false\n#| message: false\n#| error: false\n#| cache: true\n\nusing Plots\nx = range(0, 10, length=100);\ny1 = sin.(x);\ny2 = cos.(x);\nplot(x, [y1 y2])\n```\n\n4.1.3 Рендеринг и сохранение\nПри рендеринге документа Quarto блоки кода выполняются автоматически. Прямо над документом находится панель инструментов, содержащая различные параметры, включая Render (сегментированная синяя стрелка). По умолчанию документ qmd конвертируется в html.\n\n4.1.4 Опции блоков кода\nЗадать название блока можно с помощь параметра label:\n```{r}\n#| label: convert\nairquality$TempC &lt;- (5 / 9) * (airquality$Temp - 32)\n```\nПараметр echo: false отключает печать кода (отображается только вывод).\n``` r\nlibrary(tidyverse)\nlibrary(palmerpenguins)\npenguins |&gt;\n  mutate(\n    bill_ratio = bill_depth_mm / bill_length_mm,\n    bill_area  = bill_depth_mm * bill_length_mm\n  )\n```\n\nLine 3  \nTake `penguins`, and then,\n\nLines 4-7  \nadd new columns for the bill ratio and bill area.\n\n4.1.5 Параметры вывода\nСуществует широкий спектр опций для настройки вывода из выполненного кода. Все эти опции могут быть указаны либо глобально, либо для каждого блока кода. Например, вот модификация примера R, указывающая, что мы не хотим “отражать” код в выходном документе:\n---\ntitle: \"My Document\"\nexecute:\n  echo: false\n---\nПараметр echo может быть переопределен для конкретно блока кода. Например:\n```{r}\n#| echo: true\n\nplot(cars)\n```\nПараметры блока кода включены в специальный комментарий в верхней части блока (строки в верхней части, начинающиеся с #|, считаются параметрами).\nНаиболее распространенные параметры приведены далее:\n\n\n\n\n\n\nOption\nDescription\n\n\n\neval\nВычислить блок (если false, то блок кода просто дублируется в вывод).\n\n\necho\nВключить исходный код в вывод\n\n\noutput\n\nВключить результаты выполнения кода в выходные данные (true, false)\nasis, чтобы указать, что выходные данные представляют собой markdown и не должны содержать расширений Quarto).\n\n\n\nwarning\nВключать предупреждения в вывод\n\n\nerror\nВключать ошибки в вывод (это подразумевает, что ошибки выполнения кода не остановят обработку документа).\n\n\n\nПример Knitr с некоторыми из этих дополнительных параметров:\n---\ntitle: \"Knitr Document\"\nexecute:\n  echo: false\n---\n\n```{r}\n#| warning: false\n\nlibrary(ggplot2)\nggplot(airquality, aes(Temp, Ozone)) + \n  geom_point() + \n  geom_smooth(method = \"loess\", se = FALSE)\n```\n\n```{r}\nsummary(airquality)\n```\n\n4.1.6 Названия рисунков\nМожно указать подпись и замещающий текст для рисунков, сгенерированных из кода, используя параметры fig-cap и fig-alt. Например, здесь эти параметры добавляются в ячейку кода которая создает график:\n\n```{python}\n#| fig-cap: \"График в полярных координатах\"\n#| fig-alt: \"График линии в полярных координатах\"\n#| cache: true\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\nfig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\nax.plot(theta, r)\nax.set_rticks([0.5, 1, 1.5, 2])\nax.grid(True)\nplt.show()\n```\n\n\n\nГрафик в полярных координатах",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Язык разметки Markdown</span>"
    ]
  },
  {
    "objectID": "enviroment/markdown.html#sec-markdown-text-editing",
    "href": "enviroment/markdown.html#sec-markdown-text-editing",
    "title": "4  Язык разметки Markdown",
    "section": "\n4.2 Форматирование текста",
    "text": "4.2 Форматирование текста\n\n\n\n\n\n\nЯзык разметки Markdown\nРезультат\n\n\n\n*курсив*, **жирный**, ***жирный курсив***\n\nкурсив, жирный, жирный курсив\n\n\n\nверхний индекс^2^ / subscript~2~\nверхний индекс2 / нижний индекс2\n\n\n\n~~зачёркнутый~~\nзачёркутый",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Язык разметки Markdown</span>"
    ]
  },
  {
    "objectID": "enviroment/markdown.html#sec-markdown-headers",
    "href": "enviroment/markdown.html#sec-markdown-headers",
    "title": "4  Язык разметки Markdown",
    "section": "\n4.3 Заголовки",
    "text": "4.3 Заголовки\n\nЗаголовки\n\n\n\n\n\nЯзык разметки Markdown\nРезультат\n\n\n\n## Заголовок 2\n\n4.4 Заголовок 2\n\n\n### Заголовок 3\n\n4.4.1 Заголовок 3\n\n\n#### Заголовок 4\nЗаголовок 4\n\n\n##### Заголовок 5\nЗаголовок 5\n\n\n###### Заголовок 6\nЗаголовок 6",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Язык разметки Markdown</span>"
    ]
  },
  {
    "objectID": "enviroment/markdown.html#sec-markdown-link-and-image",
    "href": "enviroment/markdown.html#sec-markdown-link-and-image",
    "title": "4  Язык разметки Markdown",
    "section": "\n4.5 Ссылки и Изображения",
    "text": "4.5 Ссылки и Изображения\n\n\nЯзык разметки Markdown\nРезультат\n\n\n\n&lt;https://rct.bsu.by&gt;\nhttps://rct.bsu.by\n\n\n[Название](https://rct.bsu.by)\nНаш факультет\n\n\n![Название](rctbsu.png)\n\n\nНаш факультет\n\n\n\n\n[![Название](rctbsu.png)](https://rct.bsu.by)\nКартинка становится кликабельной при рендеринге",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Язык разметки Markdown</span>"
    ]
  },
  {
    "objectID": "enviroment/markdown.html#sec-markdown-crossref",
    "href": "enviroment/markdown.html#sec-markdown-crossref",
    "title": "4  Язык разметки Markdown",
    "section": "\n4.6 Перекрестные ссылки",
    "text": "4.6 Перекрестные ссылки\nПерекрестные ссылки на рисунки создаются, добавлением к ним идентификатора с префиксом fig-, а затем ссылаясь на рисунок с помощью префикса @. Например:\n![Грач](rctbsu.png){#fig-grach}\n\nКак показано на рисунке @fig-grach.\nДля рисунков, созданных блоками исполняемого кода, используется label с префиксом fig-, чтобы сделать их перекрестно-ссылочными. Например:\nДля демонстрации графика линии используется @fig-cars-plot.\n\n```{r}\n#| label: fig-cars-plot\n#| fig-cap: \"Cars plot \"\n\nplot(cars)\n```\nДля демонстрации графика линии используется Рисунок 4.2.\n\n```{r}\n#| label: fig-cars-plot\n#| fig-cap: \"Cars plot \"\n#| cache: true\n\nplot(cars)\n```\n\n\n\n\n\n\nРисунок 4.2: Cars plot\n\n\n\n\n\n4.6.1 Размещение и подзаголовки рисунков\nПодзаголовки для вычисляемых рисунков задаются с использованием опций fig-cap и fig-subcap. Если использовать параметр label с префиксом fig- то рисунок будет пронумерован и [перекрестно-ссылаемым].\n```{r}\n#| label: fig-charts\n#| fig-cap: \"Charts\"\n#| fig-subcap: \n#|   - \"Cars\"\n#|   - \"Pressure\"\n#| layout-ncol: 2\n#| cache: true\n\nplot(cars)\nplot(pressure)\n```\n\n\n\n\n\n\n\n\n\n(a) Cars\n\n\n\n\n\n\n\n\n\n(b) Pressure\n\n\n\n\n\n\nРисунок 4.3: Charts\n\n\n\n\n\n\n\n\nУведомление\n\n\n\nРисунки будут размещены в две колонки только при конвертации в html",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Язык разметки Markdown</span>"
    ]
  },
  {
    "objectID": "enviroment/markdown.html#sec-markdonw-list",
    "href": "enviroment/markdown.html#sec-markdonw-list",
    "title": "4  Язык разметки Markdown",
    "section": "\n4.7 Списки",
    "text": "4.7 Списки\n\n\n\n\n\n\nЯзык разметки Markdown\nOutput\n\n\n\n* маркированный список\n    + пункт 1\n    + пункт 2\n        - подпункт 1\n\nмаркированный список\n\nпункт 1\nпункт 2\n\nподпункт 1\n\n\n\n\n\n\n\n1. нумерованный список\n2. пункт 2\n    i) подпункт 1\n         A.  вложение 1\n\nordered list\nitem 2\n\nsub-item 1\n\nsub-sub-item 1\n\n\n\n\n\n\n\n- [ ] Задача 1\n- [x] Задача 2\n\nЗадача 1\nЗадача 2\n\n\n\n(@)  Сквозная нумерация списка\n\nпродолжается после\n\n(@)  прерывания\n\n\nСквозная нумерация списка\n\nпродолжается после\n\nпрерывания\n\n\n\n\nтермин\n: его определение\n\nтермин\n\nего определение\n\n\n\n\n\n\n4.7.1 Блочное размещение\nНапример, например мы можем разместить 2 списка рядом:\n::: {layout-ncol=2}\n### List One\n\n- Item A\n- Item B\n- Item C\n\n### List Two\n\n- Item X\n- Item Y\n- Item Z\n:::\n\n\nПервый список\n\nЭлемент A\nЭлемент B\nЭлемент C\nВторой список\n\nЭлемент X\nЭлемент Y\nЭлемент Z\n\n\n\n\n\n\n\n\n\nУведомление\n\n\n\nСписки будут размещены в две колонки только при конвертации в html",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Язык разметки Markdown</span>"
    ]
  },
  {
    "objectID": "enviroment/markdown.html#sec-markdown-tables",
    "href": "enviroment/markdown.html#sec-markdown-tables",
    "title": "4  Язык разметки Markdown",
    "section": "\n4.8 Таблицы",
    "text": "4.8 Таблицы\n\n4.8.1 Простые таблицы\nВ обычных таблицах могут содержаться только элементы представленные простым текстом.\nРазметка Markdown\nВыравнивание по\n| Правому краю | Левому краю | Умолчанию | Центру |\n|-------------:|:------------|-----------|:------:|\n|           12 | 12          | 12        |   12   |\n|          123 | 123         | 123       |  123   |\n|            1 | 1           | 1         |   1    |\nРезультат\nВыравнивание по\n\n\nПравому краю\nЛевому краю\nУмолчанию\nЦентру\n\n\n\n12\n12\n12\n12\n\n\n123\n123\n123\n123\n\n\n1\n1\n1\n1\n\n\n\n4.8.2 Расширенные таблицы\nРасширенные таблицы (grid tables) — это более продвинутый тип таблиц разметки, которые допускают произвольные блочные элементы (несколько абзацев, блоков кода, списков и т. д.). Например: строка =s отделяет заголовок от тела таблицы и может быть опущена для таблицы без заголовка. Ячейки таблиц сетки могут содержать произвольные блочные элементы (несколько абзацев, блоков кода, списков и т. д.)\nВыравнивания можно указывать так же, как и в случае с таблицами конвейера, помещая двоеточия на границах разделительной линии после заголовка.\nРазметка Markdown\n+-----------+-----------+--------------------+\n| Fruit     | Price     | Advantages         |\n+===========+===========+====================+\n| Bananas   | $1.34     | - built-in wrapper |\n|           |           | - bright color     |\n+-----------+-----------+--------------------+\n| Oranges   | $2.10     | - cures scurvy     |\n|           |           | - tasty            |\n+-----------+-----------+--------------------+\n\n: Пример расширенной таблицы\nРезультат\n\nПример расширенной таблицы\n\n\n\n\n\n\nFruit\nPrice\nAdvantages\n\n\n\nBananas\n$1.34\n\nbuilt-in wrapper\nbright color\n\n\n\nOranges\n$2.10\n\ncures scurvy\ntasty",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Язык разметки Markdown</span>"
    ]
  },
  {
    "objectID": "enviroment/markdown.html#sec-markdown-equations",
    "href": "enviroment/markdown.html#sec-markdown-equations",
    "title": "4  Язык разметки Markdown",
    "section": "\n4.9 Формулы",
    "text": "4.9 Формулы\nДля вставки формулы в текст используется $. Для выделения отдельным блоком используется $$. Например:\n\nФормулы\n\n\n\n\n\nЯзык разметки Markdown\nРезультат\n\n\n\nформула в тексте: $E = mc^{2}$\nформула в тексте: \\(E=mc^{2}\\)\n\n\n\nотдельный блок формул:\n\n$$E = mc^{2}$$\n\nотдельный блок формул:\n\\[E = mc^{2}\\]\n\n\n\n\nВыражения записываются на языке LaTeX, подробнее Глава 5",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Язык разметки Markdown</span>"
    ]
  },
  {
    "objectID": "enviroment/markdown.html#sec-markdown-diagram",
    "href": "enviroment/markdown.html#sec-markdown-diagram",
    "title": "4  Язык разметки Markdown",
    "section": "\n4.10 Диаграммы",
    "text": "4.10 Диаграммы\nQuarto имеет встроенную поддержку для диаграмм Mermaid и Graphviz. Mermaid – это инструмент для создания диаграмм и графиков на основе Javascript, который использует определения текста, вдохновленные Markdown, и рендерер для создания и изменения сложных диаграмм.\n\n```{mermaid}\nflowchart LR\n  A[Hard edge] --&gt; B(Round edge)\n  B --&gt; C{Decision}\n  C --&gt; D[Result one]\n  C --&gt; E[Result two]\n```\n\n\n\n\nflowchart LR\n  A[Hard edge] --&gt; B(Round edge)\n  B --&gt; C{Decision}\n  C --&gt; D[Result one]\n  C --&gt; E[Result two]",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Язык разметки Markdown</span>"
    ]
  },
  {
    "objectID": "enviroment/markdown.html#sec-markdown-quote",
    "href": "enviroment/markdown.html#sec-markdown-quote",
    "title": "4  Язык разметки Markdown",
    "section": "\n4.11 Цитаты",
    "text": "4.11 Цитаты\n &gt; Blockquote\n\nЭто короткая цитата",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Язык разметки Markdown</span>"
    ]
  },
  {
    "objectID": "enviroment/markdown.html#sec-markdown-special-symbols",
    "href": "enviroment/markdown.html#sec-markdown-special-symbols",
    "title": "4  Язык разметки Markdown",
    "section": "\n4.12 Специальные символы",
    "text": "4.12 Специальные символы\n\n\n\n\n\n\nMarkdown Syntax\nOutput\n\n\n\nendash: --\nendash: –\n\n\nemdash: ---\nemdash: —\n\n\n\n\n\n\n\n\n\nУведомление\n\n\n\nСимволы подставляются только при конвертации в html",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Язык разметки Markdown</span>"
    ]
  },
  {
    "objectID": "enviroment/latex.html",
    "href": "enviroment/latex.html",
    "title": "5  Язык разметки LaTeX",
    "section": "",
    "text": "5.1 Греческие буквы\nДля оформления уравнений и формул в рабочих блокнотах Quarto используется общепринятый стандарт разметки математических выражений LaTeX.\n[1] [2]",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Язык разметки LaTeX</span>"
    ]
  },
  {
    "objectID": "enviroment/latex.html#sec-latex-greek-letters",
    "href": "enviroment/latex.html#sec-latex-greek-letters",
    "title": "5  Язык разметки LaTeX",
    "section": "",
    "text": "Таблица 5.1: Греческие символы\n\n\n\n\n\n\n\n\n\n\n\n\n\nСтрочная\n\nПрописная\n\nАльтернативная\n\n\n\n\n\n$\\alpha$\n\\(\\alpha\\)\n$A$\n\\(A\\)\n\n\n\n\n$\\beta$\n\\(\\beta\\)\n$B$\n\\(B\\)\n\n\n\n\n$\\gamma$\n\\(\\gamma\\)\n$\\Gamma$\n\\(\\Gamma\\)\n\n\n\n\n$\\delta$\n\\(\\delta\\)\n$\\Delta$\n\\(\\Delta\\)\n\n\n\n\n$\\epsilon$\n\\(\\epsilon\\)\n$E$\n\\(E\\)\n$\\varepsilon$\n\\(\\varepsilon\\)\n\n\n$\\zeta$\n\\(\\zeta\\)\n$Z$\n\\(Z\\)\n\n\n\n\n$\\eta$\n\\(\\eta\\)\n$H$\n\\(H\\)\n\n\n\n\n$\\theta$\n\\(\\theta\\)\n$\\Theta$\n\\(\\Theta\\)\n$\\vartheta$\n\\(\\vartheta\\)\n\n\n$\\zeta$\n\\(\\zeta\\)\n$Z$\n\\(Z\\)\n\n\n\n\n$\\kappa$\n\\(\\kappa\\)\n$K$\n\\(K\\)\n$\\varkappa$\n\\(\\varkappa\\)\n\n\n$\\lambda$\n\\(\\lambda\\)\n$Lambda$\n\\(\\Lambda\\)\n\n\n\n\n$\\mu$\n\\(\\mu\\)\n$M$\n\\(M\\)\n\n\n\n\n$\\nu$\n\\(\\nu\\)\n$N$\n\\(N\\)\n\n\n\n\n$\\xi$\n\\(\\xi\\)\n$\\Xi$\n\\(\\Xi\\)\n\n\n\n\n$\\omicron$\n\\(\\omicron\\)\n$O$\n\\(O\\)\n\n\n\n\n$\\pi$\n\\(\\pi\\)\n$\\Pi$\n\\(\\Pi\\)\n$\\varpi$\n\\(\\varpi\\)\n\n\n$\\rho$\n\\(\\rho\\)\n$P$\n\\(P\\)\n$\\varrho$\n\\(\\varrho\\)\n\n\n$\\sigma$\n\\(\\sigma\\)\n$\\Sigma$\n\\(\\Sigma\\)\n$\\varsigma$\n\\(\\varsigma\\)\n\n\n$\\tau$\n\\(\\tau\\)\n$T$\n\\(T\\)\n\n\n\n\n$\\upsilon$\n\\(\\upsilon\\)\n$\\Upsilon$\n\\(\\Upsilon\\)\n\n\n\n\n$\\phi$\n\\(\\phi\\)\n$\\Phi$\n\\(\\Phi\\)\n$\\varphi$\n\\(\\varphi\\)\n\n\n$\\chi$\n\\(\\chi\\)\n$X$\n\\(X\\)\n\n\n\n\n$\\psi$\n\\(\\psi\\)\n$\\Psi$\n\\(\\Psi\\)\n\n\n\n\n$\\omega$\n\\(\\omega\\)\n$\\Omega$\n\\(\\Omega\\)",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Язык разметки LaTeX</span>"
    ]
  },
  {
    "objectID": "enviroment/latex.html#sec-latex-other-symbols",
    "href": "enviroment/latex.html#sec-latex-other-symbols",
    "title": "5  Язык разметки LaTeX",
    "section": "5.2 Прочие символы",
    "text": "5.2 Прочие символы\n\n\n\nТаблица 5.2: Прочие символы\n\n\n\n\n\n\n\n\n\n\n\n$\\infty$\n\\(\\infty\\)\n$\\forall$\n\\(\\forall\\)\n\n\n$\\Re$\n\\(\\Re\\)\n$\\Im$\n\\(\\Im\\)\n\n\n$\\nabla$\n\\(\\nabla\\)\n$\\exists$\n\\(\\exists\\)\n\n\n$\\partial$\n\\(\\partial\\)\n$\\nexists$\n\\(\\nexists\\)\n\n\n$\\emptyset$\n\\(\\emptyset\\)\n$\\varnothing$\n\\(\\varnothing\\)\n\n\n$\\wp$\n\\(\\wp\\)\n$\\complement$\n\\(\\complement\\)\n\n\n$\\neg$\n\\(\\neg\\)\n$\\cdots$\n\\(\\cdots\\)\n\n\n$\\square$\n\\(\\square\\)\n$\\surd$\n\\(\\surd\\)\n\n\n$\\blacksquare$\n\\(\\blacksquare\\)\n$\\triangle$\n\\(\\triangle\\)",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Язык разметки LaTeX</span>"
    ]
  },
  {
    "objectID": "enviroment/latex.html#sec-latex-arrows",
    "href": "enviroment/latex.html#sec-latex-arrows",
    "title": "5  Язык разметки LaTeX",
    "section": "5.3 Стрелки",
    "text": "5.3 Стрелки\n\n\n\nТаблица 5.3: Стрелки\n\n\n\n\n\n\n\n\n\n\n\n$\\leftarrow$\n\\(\\leftarrow\\)\n$\\Leftarrow$\n\\(\\Leftarrow\\)\n\n\n$\\rightarrow$\n\\(\\rightarrow\\)\n$\\rightarrow$\n\\(\\Rightarrow\\)\n\n\n$\\leftrightarrow$\n\\(\\leftrightarrow\\)\n$\\rightleftharpoons$\n\\(\\rightleftharpoons\\)\n\n\n$\\uparrow$\n\\(\\uparrow\\)\n$\\downarrow$\n\\(\\downarrow\\)\n\n\n$\\Uparrow$\n\\(\\Uparrow\\)\n$\\Downarrow$\n\\(\\Downarrow\\)\n\n\n$\\Leftrightarrow$\n\\(\\Leftrightarrow\\)\n$\\Updownarrow$\n\\(\\Updownarrow\\)\n\n\n$\\mapsto$\n\\(\\mapsto\\)\n$\\longmapsto$\n\\(\\longmapsto\\)\n\n\n$\\nearrow$\n\\(\\nearrow\\)\n$\\searrow$\n\\(\\searrow\\)\n\n\n$\\swarrow$\n\\(\\swarrow\\)\n$\\nwarrow$\n\\(\\nwarrow\\)\n\n\n$\\leftharpoonup$\n\\(\\leftharpoonup\\)\n$\\rightharpoonup$\n\\(\\rightharpoonup\\)\n\n\n$\\leftharpoondown$\n\\(\\leftharpoondown\\)\n$\\rightharpoondown$\n\\(\\rightharpoondown\\)",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Язык разметки LaTeX</span>"
    ]
  },
  {
    "objectID": "enviroment/latex.html#sec-latex-operators",
    "href": "enviroment/latex.html#sec-latex-operators",
    "title": "5  Язык разметки LaTeX",
    "section": "5.4 Бинарные операторы и символы отношения",
    "text": "5.4 Бинарные операторы и символы отношения\n\n\n\nТаблица 5.4: Операторы\n\n\n\n\n\n\n\n\n\n\n\n$\\times$\n\\(\\times\\)\n$\\cdot$\n\\(\\cdot\\)\n\n\n$\\div$\n\\(\\div\\)\n$\\cap$\n\\(\\cap\\)\n\n\n$\\cup$\n\\(\\cup\\)\n$\\neq$\n\\(\\neq\\)\n\n\n$\\leq$\n\\(\\leq\\)\n$\\geq$\n\\(\\geq\\)\n\n\n$\\in$\n\\(\\in\\)\n$\\perp$\n\\(\\perp\\)\n\n\n$\\notin$\n\\(\\notin\\)\n$\\subset$\n\\(\\subset\\)\n\n\n$\\simeq$\n\\(\\simeq\\)\n$\\approx$\n\\(\\approx\\)\n\n\n$\\wedge$\n\\(\\wedge\\)\n$\\vee$\n\\(\\vee\\)\n\n\n$\\oplus$\n\\(\\oplus\\)\n$\\otimes$\n\\(\\otimes\\)\n\n\n$\\Box$\n\\(\\Box\\)\n$\\boxtimes$\n\\(\\boxtimes\\)\n\n\n$\\equiv$\n\\(\\equiv\\)\n$\\cong$\n\\(\\cong\\)",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Язык разметки LaTeX</span>"
    ]
  },
  {
    "objectID": "enviroment/latex.html#sec-latex-functions",
    "href": "enviroment/latex.html#sec-latex-functions",
    "title": "5  Язык разметки LaTeX",
    "section": "5.5 Выделяемые функции",
    "text": "5.5 Выделяемые функции\n\n\n\nТаблица 5.5: Функции\n\n\n\n\n\n\n\n\n\nLaTeX\nРезультат\n\n\n\n\n$\\cos{x}$\n\\[\n\\cos{x}\n\\]\n\n\n$\\sin{x}$\n\\[\n\\sin{x}\n\\]\n\n\n$\\csc{x}$\n\\[\n\\csc{x}\n\\]\n\n\n$\\exp{x}$\n\\[\n\\exp\n\\biggl(\\,\n\\sum_{n=1}^{10}\n\\frac{1}{n}\n\\biggr)\n\\]\n\n\n$\\min_{sub} expr$\n\\[\n\\min_{\\forall s \\in S_j} q_k(s)\n\\]\n\n\n$\\gcd$\n\\[\n\\gcd{144,12}\n\\]\n\n\n$\\log_b n$\n\\[\nA(n) \\in\n\\Theta(n^{\\log_b a}) =\n\\Theta(n^{\\log_2 2} ) =\n\\Theta(n)\n\\]\n\n\n$\\sup_i f$\n\\[\n\\sup_{x&gt;0}f(x)\n\\]",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Язык разметки LaTeX</span>"
    ]
  },
  {
    "objectID": "enviroment/latex.html#скобки",
    "href": "enviroment/latex.html#скобки",
    "title": "5  Язык разметки LaTeX",
    "section": "5.6 Скобки",
    "text": "5.6 Скобки\n\n\n\nТаблица 5.6: Скобки\n\n\n\n\n\n\n\n\n\n\nТип\nLaTeX\nРезультат\n\n\n\n\nКруглые скобки\n$(x+y)$\n\\((x+y)\\)\n\n\nКвадратные скобки\n$[x+y]$\n\\([x+y]\\)\n\n\nФигурные скобки\n$\\{x+y\\}$\n\\(\\{x+y\\}\\)\n\n\nУгловые скобки\n$\\langle x+y \\rangle$\n\\(\\langle x+y \\rangle\\)\n\n\nВертикальные черты\n$|x+y|$\n\\(|x+y|\\)\n\n\nДвойные вертикальные черты\n$\\|x+y\\|$\n\\(\\|x+y\\|\\)\n\n\nБольшие круглые левые скобки\n$\\big( \\Big( \\bigg( \\Bigg($\n\\(\\big( \\Big( \\bigg( \\Bigg(\\)\n\n\nБольшие круглые правые скобки\n$\\big) \\Big) \\bigg) \\Bigg)$\n\\(\\big) \\Big) \\bigg) \\Bigg)\\)\n\n\nБольшие квадратные левые скобки\n$\\big[ \\Big[ \\bigg[ \\Bigg[$\n\\(\\big[ \\Big[ \\bigg[ \\Bigg[\\)\n\n\nБольшие квадратные правые скобки\n$\\big] \\Big] \\bigg] \\Bigg]$\n\\(\\big] \\Big] \\bigg] \\Bigg]\\)\n\n\nБольшие фигурные левые скобки\n$\\big\\{ \\Big\\{ \\bigg\\{ \\Bigg\\{$\n\\(\\big\\{ \\Big\\{ \\bigg\\{ \\Bigg\\{\\)\n\n\nБольшие фигурные правые скобки\n$\\big\\} \\Big\\} \\bigg\\} \\Bigg\\}$\n\\(\\bigl\\} \\Big\\} \\bigg\\} \\Bigg\\}\\)",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Язык разметки LaTeX</span>"
    ]
  },
  {
    "objectID": "enviroment/latex.html#sec-latex-matrix",
    "href": "enviroment/latex.html#sec-latex-matrix",
    "title": "5  Язык разметки LaTeX",
    "section": "5.7 Матрицы",
    "text": "5.7 Матрицы\n\n\n\nТаблица 5.7: Матрицы\n\n\n\n\n\n\n\n\n\n\nТип\nLaTeX\nРезультат\n\n\n\n\nОбычная\n$$\n\\begin{matrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n7 & 8 & 9\n\\end{matrix}\n$$\n\\[\n\\begin{matrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n7 & 8 & 9\n\\end{matrix}\n\\]\n\n\nКвадратные скобки\n$$ M =\n\\begin{bmatrix}\n\\frac{5}{6} & \\frac{1}{6} & 0 \\\\\n\\frac{5}{6} & 0 & \\frac{1}{6} \\\\\n0 & \\frac{5}{6} & \\frac{1}{6}\n\\end{bmatrix}\n$$\n\\[ M =\n\\begin{bmatrix}\n\\frac{5}{6} & \\frac{1}{6} & 0 \\\\\n\\frac{5}{6} & 0 & \\frac{1}{6} \\\\\n0 & \\frac{5}{6} & \\frac{1}{6}\n\\end{bmatrix}\n\\]\n\n\nВыражение\n$$\nM =\n\\begin{bmatrix}\n1 & 0 \\\\\n0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 0 \\\\\n0 & 1\n\\end{bmatrix}\n$$\n\\[\nM =\n\\begin{bmatrix}\n1 & 0 \\\\\n0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 0 \\\\\n0 & 1\n\\end{bmatrix}\n\\]\n\n\nКруглые скобки\n$$\nM =\n\\begin{pmatrix}\n1 & 0 \\\\\n0 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\n1 & 0 \\\\\n0 & 1\n\\end{pmatrix}\n$$\n\\[\nM =\n\\begin{pmatrix}\n1 & 0 \\\\\n0 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\n1 & 0 \\\\\n0 & 1\n\\end{pmatrix}\n\\]\n\n\nОбщий вид\n$$\nA_{m,n} =\n\\begin{pmatrix}\na_{1,1} & a_{1,2} & \\cdots & a_{1,n} \\\\\na_{2,1} & a_{2,2} & \\cdots & a_{2,n} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{m,1} & a_{m,2} & \\cdots & a_{m,n}\n\\end{pmatrix}\n$$\n\\[\nA_{m,n} =\n\\begin{pmatrix}\na_{1,1} & a_{1,2} & \\cdots & a_{1,n} \\\\\na_{2,1} & a_{2,2} & \\cdots & a_{2,n} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{m,1} & a_{m,2} & \\cdots & a_{m,n}\n\\end{pmatrix}\n\\]",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Язык разметки LaTeX</span>"
    ]
  },
  {
    "objectID": "enviroment/latex.html#sec-latex-big-operators",
    "href": "enviroment/latex.html#sec-latex-big-operators",
    "title": "5  Язык разметки LaTeX",
    "section": "5.8 Большие операторы",
    "text": "5.8 Большие операторы\n\n\n\nТаблица 5.8: Большие операторы\n\n\n\n\n\n\n\n\n\n$a_{n_i}$\n\\(a_{n_i}\\)\n\n\n$\\int_{i=1}^n$\n\\(\\int_{i=1}^n\\)\n\n\n$\\sum{i=1}^{\\infty}$\n\\(\\sum{i=1}^{\\infty}\\)\n\n\n$\\prod_{i=1}^n$\n\\(\\prod_{i=1}^n\\)\n\n\n$\\cup_{i=1}^n$\n\\(\\cup_{i=1}^n\\)\n\n\n$\\cap_{i=1}^n$\n\\(\\cap_{i=1}^n\\)\n\n\n$\\oint_{i=1}^n$\n\\(\\oint_{i=1}^n\\)\n\n\n$\\coprod_{i=1}^n$\n\\(\\coprod_{i=1}^n\\)",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Язык разметки LaTeX</span>"
    ]
  },
  {
    "objectID": "enviroment/latex.html#sec-latex-examples",
    "href": "enviroment/latex.html#sec-latex-examples",
    "title": "5  Язык разметки LaTeX",
    "section": "5.9 Примеры",
    "text": "5.9 Примеры\n\n\n\nТаблица 5.9: Примеры\n\n\n\n\n\n\n\n\n\nLaTeX\nРезультат\n\n\n\n\n$$\nx^{2 \\alpha} - 1 = y_{ij} + y_{ij}\n$$\n\\[\nx^{2 \\alpha} - 1 = y_{ij} + y_{ij}\n\\]\n\n\n$$\n(a^n)^{r+s} = a^{nr+ns}\n$$\n\\[\n(a^n)^{r+s} = a^{nr+ns}\n\\]\n\n\n$$\n\\sum_{i=1}^{\\infty}\n\\frac{1}{n^s} =\n\\prod_p \\frac{1}{1 - p^{-s}}\n$$\n\\[\n\\sum_{i=1}^{\\infty}\n\\frac{1}{n^s} =\n\\prod_p \\frac{1}{1 - p^{-s}}\n\\]\n\n\n$$\nx^2  +\nx\\left( {a + b} \\right) +\nab =\n\\left( {x + a} \\right)\n\\left( {x + b} \\right)\n$$\n\\[\nx^2  +\nx\\left( {a + b} \\right) +\nab =\n\\left( {x + a} \\right)\n\\left( {x + b} \\right)\n\\]\n\n\n$$\n\\log _b \\left( x \\right) =\n\\log _b \\left( c \\right)\\log _c \\left( x \\right) =\n\\frac{{\\log _c \\left( x \\right)}}\n{{\\log _c \\left( b \\right)}}\n$$\n\\[\n\\log _b \\left( x \\right) =\n\\log _b \\left( c \\right)\\log _c \\left( x \\right) =\n\\frac{{\\log _c \\left( x \\right)}}\n{{\\log _c \\left( b \\right)}}\n\\]\n\n\n$$\n\\frac{d}{{dx}}b^x  =\nb^x \\ln \\left( b \\right)\n$$\n\\[\n\\frac{d}{{dx}}b^x  =\nb^x \\ln \\left( b \\right)\n\\]\n\n\n$$\n\\int {\\sec (ax)} dx =\n\\frac{1}{a}\\ln \\left|\n{\\tan \\left( {\\frac{{ax}}{2} +\n\\frac{\\pi }{4}} \\right)} \\right| + c\n$$\n\\[\n\\int {\\sec (ax)} dx =\n\\frac{1}{a}\\ln \\left|\n{\\tan \\left( {\\frac{{ax}}{2} +\n\\frac{\\pi }{4}} \\right)} \\right| + c\n\\]\n\n\n$$\n\\oint_S {E_n dA =\n\\frac{1}{{\\varepsilon _0 }}} Q_{inside}\n$$\n\\[\n\\oint_S {E_n dA =\n\\frac{1}{{\\varepsilon _0 }}} Q_{inside}\n\\]\n\n\n$$\ny(x,t) = \\sum\\limits_n\n{A_n \\cos (\\omega _n t + \\delta _n )\n\\sin (k_n x)}\n$$\n\\[\ny(x,t) = \\sum\\limits_n\n{A_n \\cos (\\omega _n t + \\delta _n )\n\\sin (k_n x)}\n\\]\n\n\n\n\n\n\n\n\n\n\n1. Learn LaTeX in 30 minutes [Электронный ресурс]. URL: https://www.overleaf.com/learn/latex/Learn_LaTeX_in_30_minutes (дата обращения: 20.02.2025).\n\n\n2. Equation Sheet [Электронный ресурс]. URL: http://www.equationsheet.com/ (дата обращения: 20.02.2025).",
    "crumbs": [
      "Среда разработки",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Язык разметки LaTeX</span>"
    ]
  },
  {
    "objectID": "r/overview.html",
    "href": "r/overview.html",
    "title": "Язык программирования R",
    "section": "",
    "text": "ОсторожностьСостояние разработки\n\n\n\nТребуется доработка\n\n\nR - это язык программирования и программная среда для статистического анализа, графического представления и создания отчетов. R был создан Россом Ихакой и Робертом Джентльменом в Оклендском университете (Новая Зеландия) и в настоящее время разрабатывается командой R Development Core Team.\nВ основе R лежит интерпретируемый компьютерный язык, позволяющий выполнять ветвления и циклы, а также модульное программирование с использованием функций. Для повышения эффективности R позволяет интегрировать его с процедурами, написанными на языках C, C++, .Net, Python или FORTRAN.\nR находится в свободном доступе под лицензией GNU General Public License, а предварительно скомпилированные бинарные версии предоставляются для различных операционных систем, таких как Linux, Windows и Mac.\nR - свободное программное обеспечение, распространяемое под лицензией GNU copyleft.\nОбщая характеристика языка",
    "crumbs": [
      "Язык программирования R"
    ]
  },
  {
    "objectID": "r/lang/basic.html",
    "href": "r/lang/basic.html",
    "title": "6  Основы R",
    "section": "",
    "text": "6.1 Переменные\n[1]\n[2]\nПравильное имя переменной состоит из букв, цифр и символов точки или подчеркивания. Имя переменной начинается с буквы или точки, за которыми не следует число.\nvar_1 = 'Изучаем R'           \nvar_2 &lt;- c('learn','R')   \n'Изучаем R' -&gt; var_3\nТак как R интерпретируемый язык переменные можно удалять с помощью функции base::rm(). После удаления обращение по имени var_1 генерирует предупреждение.\nrm(var_1)\nvar_1\n\nError: object 'var_1' not found",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "r/lang/basic.html#sec-r-lang-basic-variables-naming",
    "href": "r/lang/basic.html#sec-r-lang-basic-variables-naming",
    "title": "6  Основы R",
    "section": "",
    "text": "Правила именования переменных\n\n\n\n\n\n\nИмя переменной\nДопустимость\nОбъяснение\n\n\n\nvar_name2.\nда\nСостоит из букв, цифр, точки и знака подчеркивания\n\n\nvar_name%\nнет\nЕсть символ ‘%’. Допускаются только точка(.) и знак подчеркивания.\n\n\n2var_name\nнет\nНачинается с цифры\n\n\n\n.var_name, var.name\n\nда\nМожет начинаться с точки(.), но за точкой(.) не должна следовать цифра.\n\n\n.2var_name\nнет\nЗа начальной точкой следует цифра\n\n\n_var_name\nнет\nНачинается с _, что недопустимо\n\n\n\n\n\n\n\n\n\nВажное уведомление\n\n\n\nРекомендуется не использовать точку в имени переменной\n\n\n\n\n\n\n\n\n\nВажное уведомление\n\n\n\nРекомендуется использовать оператор &lt;-.",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "r/lang/basic.html#sec-r-lang-basic-data-types",
    "href": "r/lang/basic.html#sec-r-lang-basic-data-types",
    "title": "6  Основы R",
    "section": "\n6.2 Типы данных",
    "text": "6.2 Типы данных\nВ отличие от других языков программирования, таких как C и java, в R переменные не объявляются как некоторый тип данных. Переменным присваиваются R-объекты, и тип данных R-объекта становится типом данных переменной. Существует множество типов R-объектов. Наиболее часто используемые из них:\n\nВектор 6.3\nСписок 6.4\nМатрица 6.5\nМассивы 6.6\nТаблицы 6.7\n\nВсе объекты в R строятся на основе интерфейса вектор. Два основных типа которые реализуют этот интерфейс: base::list() и base::vector() остальные R-объекты строятся на основе этих типов. Существует шесть типов base::typeof() данных атомарных векторов.\n\n\nТаблица 6.1: Базовые типы данных\n\n\n\n\n\n\n\n\nТип данных\nПример\nПроверка\n\n\n\nЛогический\n\nTRUE, FALSE\n\n\ntypeof(TRUE)\nlogical\n\n\n\nДействительный\n\n12.3, 5, 999\n\n\ntypeof(7.5)\ndouble\n\n\n\nЦелочисленный\n\n2L, 34L, 0L\n\n\ntypeof(2L)\ninteger\n\n\n\nКомплексный\n3+2i\n\ntypeof(2+5i)\ncomplex\n\n\n\nСимвольный\n\n'a', 'good','TRUE'\n\n\ntypeof('TRUE')\ncharacter\n\n\n\nRaw\n\n'Hello' is stored as 48 65 6c 6c 6f\n\n\ntypeof(charToRaw('Hello'))\nraw",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "r/lang/basic.html#sec-r-lang-basic-vector",
    "href": "r/lang/basic.html#sec-r-lang-basic-vector",
    "title": "6  Основы R",
    "section": "\n6.3 Вектор",
    "text": "6.3 Вектор\nВсе данные в языке R векторные. Даже если определить численный литерал его внутреннее представление будет вектором.\n\nis.vector(1)\n\n[1] TRUE\n\n\n\n6.3.1 Последовательности\nДля объединения элементов в вектор используется функция base::c() – combine. При комбинации элементов различных типов общий тип выводится по правилам (ссылка).\n\na &lt;- c(1,2,3)\na\n\n[1] 1 2 3\n\n\nДля задания целочисленных последовательностей могут использоваться например оператор двоеточия 1:5,\n\nnumbers &lt;- 1:10\nnumbers\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nили функции base::seq()\n\nseq(5, 9, by = 0.4)\n\n [1] 5.0 5.4 5.8 6.2 6.6 7.0 7.4 7.8 8.2 8.6 9.0\n\n\nПовторить элементы вектора можно с помощью функции base::rep()\n\nrep(c(1,2,3), each = 3)\n\n[1] 1 1 1 2 2 2 3 3 3\n\nrep(c(1,2,3), times = 3)\n\n[1] 1 2 3 1 2 3 1 2 3\n\n\nДлина вектора получается функцией base::length()\n\nv &lt;- 1:5\nlength(v)\n\n[1] 5\n\n\n\n6.3.2 Доступ к элементам\nОператор [\n\nОператор объект того же класса что и объект-оригинал. Может быть выделено более 1 элемента!\n\nx &lt;- 1:5\nx[1]\n\n[1] 1\n\nx[2:5]\n\n[1] 2 3 4 5\n\n\nЛогическая индексация\n\nx[x &gt; 2]\n\n[1] 3 4 5\n\n\nТакже можно изменять элементы вектора таким же образом\n\nx[1:2] &lt;- c(6,7)\nx\n\n[1] 6 7 3 4 5\n\n\nОператор [[\n\nМожет быть выделен только 1 элемент!\n\nx &lt;- 1:5\nx[[2]]\n\n[1] 2\n\nx[[3:5]]\n\nError in x[[3:5]]: attempt to select more than one element in vectorIndex",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "r/lang/basic.html#sec-r-lang-basic-list",
    "href": "r/lang/basic.html#sec-r-lang-basic-list",
    "title": "6  Основы R",
    "section": "\n6.4 Список",
    "text": "6.4 Список\nСписки - это объекты R, которые содержат элементы различных типов, такие как числа, строки, векторы и другие списки внутри них. Список также может содержать матрицу или функцию в качестве своих элементов. Список создается с помощью функции base::list(). Ниже приведен пример создания списка, содержащего строки, числа, векторы и логические значения.\n\nlist_data &lt;- list('Red', 'Green', c(21,32,11), TRUE, 51.23, 119.1)\nlist_data\n\n[[1]]\n[1] \"Red\"\n\n[[2]]\n[1] \"Green\"\n\n[[3]]\n[1] 21 32 11\n\n[[4]]\n[1] TRUE\n\n[[5]]\n[1] 51.23\n\n[[6]]\n[1] 119.1\n\n\nСписок совмещает в себе свойства списка и словаря из других языков программирования. Поэтому элементам мы можем задавать имена.\n\n6.4.1 Доступ к элементам\nОператор [\n\nПозволяет выбрать один или несколько элементов по индексу. Всегда возвращает тип списка\n\nx &lt;- list(foo = 1:4, bar = 0.6)\nx[1]\n\n$foo\n[1] 1 2 3 4\n\n\nОператор [[\n\nПозволяет выбрать один элемент по индексу. Возвращает тип содержащегося элемента.\n\nx &lt;- list(foo = 1:4, bar = 0.6)\nx[[1]]\n\n[1] 1 2 3 4\n\n\nили по имени\n\nx &lt;- list(foo = 1:4, bar = 0.6)\nx[['bar']]\n\n[1] 0.6\n\n\nОператор [[ может принимать последовательность целых чисел и рекурсивно извлекать элементы из вложенного списка\n\nx &lt;- list(a = list(10, 12, 14), b = c(3.14, 2.81))\nx[[c(1, 3)]]\n\n[1] 14\n\nx[[1]][[3]]\n\n[1] 14\n\nx[[c(2, 1)]]\n\n[1] 3.14\n\n\nОператор $\n\n$ работает только с именами объектов.\n\nx &lt;- list(foo = 1:4, bar = 0.6)\nx$foo\n\n[1] 1 2 3 4",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "r/lang/basic.html#sec-r-lang-basic-matrix",
    "href": "r/lang/basic.html#sec-r-lang-basic-matrix",
    "title": "6  Основы R",
    "section": "\n6.5 Матрицы",
    "text": "6.5 Матрицы\nМатрица – это специальный тип вектора в R, который имеет атрибут dim. dim – это вектор типа integer, состоящий из 2 элементов ( nrow - число строк и ncol - число столбцов). Матрицы заполняются по правилу: сверху вниз слева направо.\n\nm &lt;- matrix(c(1, 2, 3, 4), ncol = 2, nrow = 2)\nm\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\ndim(m)\n\n[1] 2 2\n\nattributes(m)\n\n$dim\n[1] 2 2\n\n\nМатрицы можно создавать с помощью функций cbind и rbind.\n\nx &lt;- 1:3\ny &lt;- 10:12\ncbind(x, y)\n\n     x  y\n[1,] 1 10\n[2,] 2 11\n[3,] 3 12\n\n\narray(data,dim) – функция для создания матрицы заданного размера.\n\narray(1:8,c(2,2,2))\n\n, , 1\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n, , 2\n\n     [,1] [,2]\n[1,]    5    7\n[2,]    6    8\n\n\n\n6.5.1 Доступ к элементам\nДоступ к элементам матриц осуществляется с использованием индексов в квадратных скобках – ‘[’. Первый индекс – номер строки, второй индекс – номер столбца.\n\nx &lt;- matrix(1:6, 2, 3)\nx[1, 2]\n\n[1] 3\n\nx[2, 1]\n\n[1] 2\n\n\nПервый или второй индекс может отсутствовать. Тогда будет возвращена строка или столбец матрицы.\n\nx[1, ]\n\n[1] 1 3 5\n\nx[, 2]\n\n[1] 3 4\n\n\nПо умолчанию возвращается вектор единичной длины того же класса что и исходный объект. Для получения объекта в виде матрицы необходимо установить параметр drop. Учет размерности данных – drop = FALSE.\n\nx &lt;- matrix(1:6, 2, 3)\nx[1, 2, drop = FALSE]\n\n     [,1]\n[1,]    3\n\nx &lt;- matrix(1:6, 2, 3)\nx[1, ]\n\n[1] 1 3 5\n\nx[1, , drop = FALSE]\n\n     [,1] [,2] [,3]\n[1,]    1    3    5",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "r/lang/basic.html#sec-r-lang-basic-array",
    "href": "r/lang/basic.html#sec-r-lang-basic-array",
    "title": "6  Основы R",
    "section": "\n6.6 Массивы",
    "text": "6.6 Массивы\n\n6.6.1 Доступ к элементам",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "r/lang/basic.html#sec-r-lang-basic-table",
    "href": "r/lang/basic.html#sec-r-lang-basic-table",
    "title": "6  Основы R",
    "section": "\n6.7 Таблицы",
    "text": "6.7 Таблицы\nТаблица (Data Frame)– специальный тип списка, в котором каждый элемент имеет фиксированную длину. Используется для хранения табулированных данных. Каждая колонка может представлять различные типы данных, включая факторы. Data Frame имеют специализированный атрибут row.names, указывающий имена строк. Это помогает упростить аннотацию данных. Для создания Data Frame из табулированных данных используются функции read.table и read.csv. Для создания матрицы из Data Frame используется функция data.matrix. data.frame – функция для создания Data Frame.\n\nx &lt;- data.frame(foo = 1:4, bar = c(T, T, F, F))\nnrow(x)\n\n[1] 4\n\nncol(x)\n\n[1] 2",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "r/lang/basic.html#sec-r-lang-basic-cast",
    "href": "r/lang/basic.html#sec-r-lang-basic-cast",
    "title": "6  Основы R",
    "section": "\n6.8 Преобразование объектов",
    "text": "6.8 Преобразование объектов\nДля преобразования объекта к другому типу используются функции семейства as.*\n\nas.logical(c(-1, 0, 1))\n\n[1]  TRUE FALSE  TRUE\n\nas.numeric(c(TRUE, FALSE))\n\n[1] 1 0\n\nas.character(c(TRUE, FALSE))\n\n[1] \"TRUE\"  \"FALSE\"",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "r/lang/basic.html#sec-r-lang-basic-vectorization",
    "href": "r/lang/basic.html#sec-r-lang-basic-vectorization",
    "title": "6  Основы R",
    "section": "\n6.9 Векторные операции",
    "text": "6.9 Векторные операции\nВ R можно осуществлять операции над векторами. Это позволяет значительно упростить программный код, не программировать циклы, ускорить процесс написания программ.\n\n6.9.1 Арифметические операторы\n\n\nТаблица 6.2: Векторные арифметические операции\n\n\n\n\n\n\n\n\nОператор\nОписание\nПример\n\n\n\n+\nПоэлементное сложение двух векторов\n\nv &lt;- c(2, 5.5,6)\nt &lt;- c(8, 3, 4)\nv+t\n[1] 10.0  8.5  10.0\n\n\n\n-\nПоэлементное вычитание второго вектора из первого\n\nv &lt;- c( 2,5.5,6)\nt &lt;- c(8, 3, 4)\nv - t\n[1] -6.0  2.5  2.0\n\n\n\n*\nПоэлементное умножение двух векторов\n\nv &lt;- c( 2,5.5,6)\nt &lt;- c(8, 3, 4)\nv * t\n[1] 16.0 16.5 24.0\n\n\n\n/\nПоэлементно делит второй вектор на первый\n\nv &lt;- c( 2,5.5,6)\nt &lt;- c(8, 3, 4)\nv / t\n[1] 0.250000 1.833333 1.500000\n\n\n\n%%\nОстаток от поэлементного деления\n\nv &lt;- c(2, 5.5,6)\nt &lt;- c(8, 3, 4)\nv %% t\n[1] 2.0 2.5 2.0\n\n\n\n%/%\nЦелочисленное поэлементное деление\n\nv &lt;- c( 2,5.5,6)\nt &lt;- c(8, 3, 4)\nv %/% t\n[1] 0 1 1\n\n\n\n^\nПоэлементное возведение в степень\n\nv &lt;- c( 2,5.5,6)\nt &lt;- c(8, 3, 4)\nv ^ t\n[1]  256.000  166.375 1296.000\n\n\n\n\n\n\n\nАналогично векторные операции осуществляются над матрицами.\n\nx &lt;- matrix(1:4, 2, 2);\ny &lt;- matrix(rep(10, 4), 2, 2)\nx * y # поэлементно\n\n     [,1] [,2]\n[1,]   10   30\n[2,]   20   40\n\nx / y\n\n     [,1] [,2]\n[1,]  0.1  0.3\n[2,]  0.2  0.4\n\n\nОператор %*% используется для матричное перемножение по правилам линейной алгебры.\n\nx %*% y\n\n     [,1] [,2]\n[1,]   40   40\n[2,]   60   60\n\n\n\n6.9.2 Операторы сравнения\nВ следующей таблице приведены операторы сравнения, поддерживаемые языком R. Каждый элемент первого вектора сравнивается с соответствующим элементом второго вектора. Результатом сравнения является булево значение.\n\n\nТаблица 6.3: Векторные операторы сравнения\n\n\n\n\n\n\n\n\nОператор\nОписание\nПример\n\n\n\n&gt;\nПроверяет, что каждый элемент первого вектора больше соответствующего элемента второго вектора.\n\nv &lt;- c(2,5.5,6,9)\nt &lt;- c(8,2.5,14,9)\nv &gt; t\n[1] FALSE  TRUE FALSE FALSE\n\n\n\n&lt;\nПроверяет, не меньше ли каждый элемент первого вектора соответствующего элемента второго вектора.\n\nv &lt;- c(2,5.5,6,9)\nt &lt;- c(8,2.5,14,9)\nv &lt; t\n[1]  TRUE FALSE  TRUE FALSE\n\n\n\n==\nПроверяет, равен ли каждый элемент первого вектора соответствующему элементу второго вектора.\n\nv &lt;- c(2,5.5,6,9)\nt &lt;- c(8,2.5,14,9)\nv == t\n[1] FALSE FALSE FALSE  TRUE\n\n\n\n&lt;=\nПроверяет, меньше или равен ли каждый элемент первого вектора соответствующему элементу второго вектора.\n\nv &lt;- c(2,5.5,6,9)\nt &lt;- c(8,2.5,14,9)\nv &lt;= t\n[1]  TRUE FALSE  TRUE  TRUE\n\n\n\n&gt;=\nПроверяет, больше или равен ли каждый элемент первого вектора соответствующему элементу второго вектора.\n\nv &lt;- c(2,5.5,6,9)\nt &lt;- c(8,2.5,14,9)\nv &gt;= t\n[1] FALSE  TRUE FALSE  TRUE\n\n\n\n!=\nПроверяет, не равен ли каждый элемент первого вектора соответствующему элементу второго вектора.\n\nv &lt;- c(2,5.5,6,9)\nt &lt;- c(8,2.5,14,9)\nv != t\n[1]  TRUE  TRUE  TRUE FALSE\n\n\n\n\n\n\n\n\n6.9.3 Логические\nВ следующей таблице приведены логические операторы, поддерживаемые языком R. Они применимы только к векторам типа base::logical(), base::numeric() или complex(). Все числа больше 1 считаются логическим значением TRUE.\nКаждый элемент первого вектора сравнивается с соответствующим элементом второго вектора. Результатом сравнения является булево значение.\n\n\nТаблица 6.4: Векторные логические операторы\n\n\n\n\n\n\n\n\nОператор\nОписание\nПример\n\n\n\n&\n\nЛогический оператор И (Element-wise Logical AND).\nОн объединяет каждый элемент первого вектора с соответствующим элементом второго вектора и выдает на выходе TRUE, если оба элемента TRUE.\n\n\nv &lt;- c(3,1,TRUE,2+3i)\nt &lt;- c(4,1,FALSE,2+3i)\nv&t\n[1]  TRUE  TRUE FALSE  TRUE\n\n\n\n|\n\nЛогическое ИЛИ по элементам.\nОн объединяет каждый элемент первого вектора с соответствующим элементом второго вектора и выдает на выходе TRUE, если один из элементов равен TRUE.\n\n\nv &lt;- c(3,0,TRUE,2+2i)\nt &lt;- c(4,0,FALSE,2+3i)\nv|t\n[1]  TRUE FALSE  TRUE  TRUE\n\n\n\n!\nЛогический оператор NOT. Берет каждый элемент вектора и выдает противоположное логическое значение.\n\nv &lt;- c(3,0,TRUE,2+2i)\n!v\n[1] FALSE  TRUE FALSE FALSE\n\n\n\n\n\n\n\nЛогические операторы && и || учитывают только первый элемент векторов и выдают на выходе вектор из одного элемента.\n\n\nТаблица 6.5: Скалярные векторные операторы\n\n\n\n\n\n\n\n\nОператор\nОписание\nПример\n\n\n\n&&\nОператор логического И. Берет первый элемент обоих векторов и выдает значение TRUE, только если оба элемента TRUE.\n\nv &lt;- c(3,0,TRUE,2+2i)\nt &lt;- c(1,3,TRUE,2+3i)\nv&&t\n[1] TRUE\n\n\n\n||\nОператор логического ИЛИ. Берет первый элемент обоих векторов и выдает TRUE, если один из них TRUE.\n\nv &lt;- c(0,0,TRUE,2+2i)\nt &lt;- c(0,3,TRUE,2+3i)\nv||t\nT[1] FALSE",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "r/lang/basic.html#sec-r-lang-basic-branching",
    "href": "r/lang/basic.html#sec-r-lang-basic-branching",
    "title": "6  Основы R",
    "section": "\n6.10 Ветвление",
    "text": "6.10 Ветвление\n\n6.10.1 Оператор if\n\nОператор if состоит из булева выражения, за которым следует один или несколько операторов. Синтаксис оператора выглядит следующим образом\nif(boolean_expression) {\n   # Инструкции будут выполненны, если значение выражения TRUE\n}\nЕсли булево выражение равно true, то будет выполнен блок кода внутри оператора if. Если булево выражение равно false, то будет выполнен первый набор кода после конца оператора if (после закрывающей фигурной скобки).\n\n6.10.2 Оператор else\n\nif(boolean_expression) {\n   # Инструкции будут выполненны, если значение выражения TRUE\n} else {\n   # Инструкции будут выполненны, если значение выражения FALSE\n}\nЕсли булево выражение оценивается как истина, то будет выполнен блок кода if, в противном случае будет выполнен блок кода else.\n\nx &lt;- c('what','is','truth')\n\nif('Truth' %in% x) {\n   'Truth is found'\n} else {\n   'Truth is not found'\n}\n\n[1] \"Truth is not found\"\n\n\nЗа оператором if может следовать необязательный оператор else if...else, что очень удобно для проверки различных условий с помощью одного оператора if...else if\nif(boolean_expression_1) {\n   # Выполняется, если выражение 1 TRUE\n} else if( boolean_expression_2) {\n   # Выполняется, если выражение 2 TRUE\n} else if( boolean_expression_3) {\n   # Выполняется, если выражение 3 TRUE\n} else {\n   # Выполняется если все выражения FALSE\n}\nНапример\n\nx &lt;- c('what','is','truth')\n\nif('Truth' %in% x) {\n   'Truth is found the first time'\n} else if ('truth' %in% x) {\n   'truth is found the second time'\n} else {\n   'No truth found'\n}\n\n[1] \"truth is found the second time\"\n\n\n\n6.10.3 Функция switch\n\nОператор base::switch() позволяет проверить переменную на равенство со списком значений. Каждое значение называется случаем, и переменная, которая включается, проверяется для каждого случая. Оператор записывается следующим образом:\nswitch(expression, case1, case2, case3, ....)\nК оператору switch применяются следующие правила.\n\nЕсли значение выражения не является символьной строкой, оно приводится к целому числу.\nВнутри switch может быть любое количество операторов case. За каждым case следует значение, с которым нужно сравнить, и двоеточие.\nЕсли значение целого числа находится между 1 и nargs()-1 (максимальное количество аргументов), то соответствующий элемент условия case оценивается и возвращается результат.\nЕсли выражение оценивается как символьная строка, то эта строка сопоставляется (в точности) с именами элементов.\nЕсли имеется более одного совпадения, возвращается первый совпавший элемент.\nАргумент Default недоступен.\nВ случае отсутствия совпадения, если существует неименованный элемент …, возвращается его значение. (Если таких аргументов более одного, возвращается ошибка).\n\nПример индексации\n\nswitch(1, 'one', 'two')\n\n[1] \"one\"\n\n\nИндексация с составными именованными выражениями\n\nswitch(1, foo={'one'}, bar={'two'}) \n\n[1] \"one\"\n\n\nПо имени с составными именованными выражениями\n\nswitch('bar', foo={'one'}, bar={'two'})\n\n[1] \"two\"",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "r/lang/basic.html#sec-r-lang-basic-cylce",
    "href": "r/lang/basic.html#sec-r-lang-basic-cylce",
    "title": "6  Основы R",
    "section": "\n6.11 Циклы",
    "text": "6.11 Циклы\nОператор цикла позволяет выполнить оператор или группу операторов несколько раз.\n\n6.11.1 Типы циклов\nЦикл for\n\nЦикл for используется когда количество итераций известно до начала цикла.\nfor (value in vector) {\n   statements\n}\nЦиклы for в R особенно гибки, поскольку не ограничиваются целыми числами или даже числами на входе. Цикл может быть применен к символьным векторам, логическим векторам, спискам или выражениям.\n\nv &lt;- LETTERS[1:4]\nfor ( i in v) {\n   print(i)\n}\n\n[1] \"A\"\n[1] \"B\"\n[1] \"C\"\n[1] \"D\"\n\n\nЦикл while\n\nЦикл while выполняет один и тот же код снова и снова, пока не будет выполнено условие остановки.\nwhile (test_expression) {\n   statement\n}\nКлючевым моментом цикла while является то, что цикл может никогда не выполняться. Когда условие будет проверено и результат окажется ложным, тело цикла будет пропущено, и будет выполнен первый оператор после цикла while.\n\nv &lt;- c('Hello','while loop')\ncnt &lt;- 2\n\nwhile (cnt &lt; 7) {\n   print(v)\n   cnt &lt;- cnt + 1\n}\n\n[1] \"Hello\"      \"while loop\"\n[1] \"Hello\"      \"while loop\"\n[1] \"Hello\"      \"while loop\"\n[1] \"Hello\"      \"while loop\"\n[1] \"Hello\"      \"while loop\"\n\n\nЦикл repeat\n\nЦикл repeat выполняет один и тот же код снова и снова, пока не будет выполнено условие остановки.\nrepeat { \n   commands \n   if(condition) {\n      break\n   }\n}\nПример\n\nv &lt;- c('Hello','loop')\ncnt &lt;- 2\n\nrepeat {\n   print(v)\n   cnt &lt;- cnt+1\n   if(cnt &gt; 5) {\n      break\n   }\n}\n\n[1] \"Hello\" \"loop\" \n[1] \"Hello\" \"loop\" \n[1] \"Hello\" \"loop\" \n[1] \"Hello\" \"loop\" \n\n\n\n6.11.2 Операторы управления\nОператоры управления циклом изменяют обычную последовательность выполнения. Когда выполнение покидает область видимости, все автоматические объекты, которые были созданы в этой области, уничтожаются.\nКлючевое слово next\n\nОператор next в языке полезен, когда требуется пропустить текущую итерацию цикла, не завершая его. При встрече с next синтаксический анализатор R пропускает дальнейшие вычисления и начинает следующую итерацию цикла.\nnext\n\nv &lt;- LETTERS[1:6]\nfor ( i in v) {\n   \n   if (i == \"D\") {\n      next\n   }\n   print(i)\n}\n\n[1] \"A\"\n[1] \"B\"\n[1] \"C\"\n[1] \"E\"\n[1] \"F\"\n\n\nКлючевое слово break\n\nОператор break в языке программирования R используется следующим образом.\n\nКогда оператор break встречается внутри цикла, цикл немедленно завершается, и управление программой возобновляется в следующем операторе, следующем за циклом.\nОн может быть использован для завершения случая в операторе switch.\n\nbreak\nПример\n\nv &lt;- c(\"Hello\",\"loop\")\ncnt &lt;- 2\n\nrepeat {\n   print(v)\n   cnt &lt;- cnt + 1\n    \n   if(cnt &gt; 5) {\n      break\n   }\n}\n\n[1] \"Hello\" \"loop\" \n[1] \"Hello\" \"loop\" \n[1] \"Hello\" \"loop\" \n[1] \"Hello\" \"loop\"",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "r/lang/basic.html#sec-r-lang-basic-function",
    "href": "r/lang/basic.html#sec-r-lang-basic-function",
    "title": "6  Основы R",
    "section": "\n6.12 Функции",
    "text": "6.12 Функции\nФункция - это набор операторов, организованных вместе для выполнения определенной задачи. В R имеется большое количество встроенных функций, и пользователь может создавать свои собственные функции.\nВ R функция - это объект, поэтому интерпретатор R может передавать функции управление, а также аргументы, которые могут потребоваться функции для выполнения действий.\nФункция, в свою очередь, выполняет свою задачу и возвращает управление интерпретатору, а также любой результат, который может быть сохранен в других объектах.\nЧасто используемые функции\n\n6.12.1 Определение функции\nФункция R создается с помощью ключевого слова function. Основной синтаксис определения функции R выглядит следующим образом\nfunction_name &lt;- function(arg_1, arg_2, ...) {\n   # Инструкции\n   # Инструкции\n}\n\n6.12.2 Элементы объекта функции\nФункция состоит из\n\nИмени – Функция хранится в среде R как объект с этим именем.\nАргументов – Когда функция вызывается, в неё передаетются значения аргументов. Аргументы необязательны, то есть функция может не содержать аргументов. Также аргументы могут иметь значения по умолчанию.\nТела функции – тело функции содержит набор выражений, которые определяют, что делает функция.\nВозвращаемого значения – это последнее выражение в теле функции, которое должно быть вычислено.\n\nВ R есть множество встроенных функций, которые можно вызывать непосредственно в программе, не определяя их предварительно. Также можно создавать и использовать собственные функции, называемые функциями, определяемыми пользователем.\n\n6.12.3 Встроенные функции\nПростыми примерами встроенных функций являются base::seq(), base::mean(), base::sum(), base::paste() и т. д. Они напрямую вызываются программами, написанными пользователем.\n\nseq(32,44)\n\n [1] 32 33 34 35 36 37 38 39 40 41 42 43 44\n\nmean(25:82)\n\n[1] 53.5\n\nsum(41:68)\n\n[1] 1526\n\n\n\n6.12.4 Пользовательские функции\nОни определяют, что нужно пользователю, и после создания могут использоваться так же, как и встроенные функции. Ниже приведен пример создания и использования функции.\n\nf &lt;- function(a) {\n   for(i in 1:a) {\n      b &lt;- i^2\n      print(b)\n   }\n}\n\n\n6.12.5 Вызов функции\n\nf &lt;- function(a) {\n   for(i in 1:a) {\n      b &lt;- i^2\n      print(b)\n   }\n}\n\nf(6)\n\n[1] 1\n[1] 4\n[1] 9\n[1] 16\n[1] 25\n[1] 36\n\n\nБез аргументов\n\nf &lt;- function() {\n   for(i in 1:5) {\n      print(i^2)\n   }\n}   \n\nf()\n\n[1] 1\n[1] 4\n[1] 9\n[1] 16\n[1] 25\n\n\nПозиционные и именованные аргументы\nАргументы вызова функции могут быть представлены в той же последовательности, что и определены в функции, или же они могут быть представлены в другой последовательности, но приписаны к именам аргументов.\n\nf &lt;- function(a,b,c) {\n   a * b + c\n}\n\nf(5,3,11)\n\n[1] 26\n\nf(a = 11, b = 5, c = 3)\n\n[1] 58\n\n\nАргументы по умолчанию\nМожно задать значения аргументов в определении функции и вызвать функцию без указания аргументов, чтобы получить результат по умолчанию.\n\nf &lt;- function(a = 3, b = 6) {\n   a * b\n}\n\nf()\n\n[1] 18\n\nf(9,5)\n\n[1] 45\n\n\n\n\n\n\n1. \nR Tutorial [Электронный ресурс]. URL: https://www.tutorialspoint.com/r/index.htm (дата обращения: 20.02.2025).\n\n\n2. \nR Tutorial [Электронный ресурс]. URL: https://www.w3schools.com/r/ (дата обращения: 20.02.2025).",
    "crumbs": [
      "Язык программирования R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "linear/overview.html",
    "href": "linear/overview.html",
    "title": "Линейное программирование",
    "section": "",
    "text": "Общая формулировка задачи\nТребуется минимизировать (\\(\\max\\)) или минимизировать (\\(\\min\\)) линейную целевую функцию \\(\\mathrm{F}=c_1x_1+c_2x_2+...c_nx_n=\\mathbf{cx}\\) от \\(n\\) переменных при соблюдении \\(m\\) линейных ограничений вида\n\\[\n\\begin{cases}\na_{11}x_1+a_{12}x_2+a_{13}x_3+\\dots+a_{1n}x_n \\leq b_1 \\\\\n\\vdots \\\\\na_{l1}x_1+a_{l2}x_2+a_{l3}x_3+\\dots+a_{ln}x_n \\geq b_l \\\\\n\\vdots \\\\\na_{m1}x_1+a_{m2}x_2+a_{m3}x_3+\\dots+a_{mn}x_n \\geq b_m \\\\\n\\end{cases}\n\\]\nПри условии, что задача приведена с стандартную форму можно записать формулировку в матрично-векторном виде \\(z=\\mathbf{cx}\\) при ограничениях \\(\\mathbf{Ax}=\\mathbf{b}\\), \\(\\mathbf{x} \\geq \\mathbf{0}\\)",
    "crumbs": [
      "Линейное программирование"
    ]
  },
  {
    "objectID": "linear/overview.html#sec-linear-overview-standart-problem",
    "href": "linear/overview.html#sec-linear-overview-standart-problem",
    "title": "Линейное программирование",
    "section": "Стандартная форма задачи",
    "text": "Стандартная форма задачи\n[1]\n\nВсе ограничения (включая ограничения неотрицательности переменных) преобразуются в равенства с неотрицательной правой частью.\nВсе переменные неотрицательные.\n\n\nПреобразование неравенств в равенства с неотрицательной правой частью\nНеравенства любого типа (со знаками неравенств \\(\\leq\\) и \\(\\geq\\)) можно преобразовать в равенства путём добавления в левую часть неравенств дополнительных переменных – остаточных и избыточных, которые связаны с неравенствами типа \\(\\leq\\) и \\(\\geq\\) соответственно.\nДля неравенств типа \\(\\leq\\) в левую часть неравенства вводится неотрицательная остаточная переменная. Например неравенство переходит в равенство добавлением остаточной переменной \\(s_1\\).\n\\[\n6x_1+4x_2\\ \\leq 24 \\quad \\longrightarrow \\quad 6x_1+4x_2+s_1=24, s_1\\geq0\n\\]\nНеравенства типа \\(\\geq\\) обычно устанавливают нижнюю границу чего либо. Избыточная переменная определяет превышение значения левой части неравенства над этой границей. Например:\n\\[\nx_1+x_2\\ \\geq 800 \\quad \\longrightarrow \\quad x_1+x_2-S_1=800, s_1\\geq0\n\\]\nПоследнее требование – правая часть полученных равенств должна быть неотрицательная. Правую часть равенства можно сделать неотрицательными просто умножив все равенство на \\(-1\\). Например\n\\[\n-x_1+x_2\\ \\leq -3 \\quad \\longrightarrow \\quad -x_1+x_2+s_1=-3, s_1\\geq0\n\\]\nТеперь, умножая обе части равенства на \\(-1\\), получим равенство с неотрицательной правой частью: \\(x_1-x_2-s_1=3\\)\n\n\nПреобразование свободных переменных\nВозможны такие ситуации, когда переменные в задаче ЛП могут принимать любые действительные значения, как положительные, так и отрицательные. В таком случае свободная переменная может быть замещена двумя неотрицательными переменными с использованием следующей подстановки\n\\[\n\\begin{aligned}\n&S_i=S_i^- - S_i^+,\\\\\n&\\begin{cases}\nS_i^-\\geq 0\\\\\nS_i^+\\geq0\n\\end{cases}\n\\end{aligned}\n\\]\n\n\n\n\n1. А. Т.Х. Исследование операций. 10-е изд. / под ред. Слепцова А.В. Санкт-Петербург: ООО \"Диалектика\", 2019. С. 1056.",
    "crumbs": [
      "Линейное программирование"
    ]
  },
  {
    "objectID": "linear/algebra.html",
    "href": "linear/algebra.html",
    "title": "7  Элементы линейной алгебры",
    "section": "",
    "text": "7.1 Вектор\n[1] [2]\n[3]",
    "crumbs": [
      "Линейное программирование",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Элементы линейной алгебры</span>"
    ]
  },
  {
    "objectID": "linear/algebra.html#sec-linear-algebra-vector",
    "href": "linear/algebra.html#sec-linear-algebra-vector",
    "title": "7  Элементы линейной алгебры",
    "section": "",
    "text": "Определение 7.1  \n\nВектор\n\n\\(\\mathbf{P}=(p_1,p_2,\\dots,p_n)\\) упорядоченная система \\(n\\) действительных чисел\n\n\n\n\n7.1.1 Операции\n\nРавенство\nДва \\(n\\)-мерных вектора \\(\\mathbf{X}=(x_1,x_2,\\dots,x_n)\\) и \\(\\mathbf{Y}=(y_1,y_2,\\dots,y_n)\\) считаются равными, если их соответствующие компоненты совпадают, т.е. если\n\\[\nx_i=y_i,\\quad для \\quad i=1,2,\\dots,n\n\\]\n\n\nСложение и вычитание\nПусть \\(\\mathbf{P}=(p_1,p_2,\\dots,p_n)\\) и \\(\\mathbf{Q}=(q_1,q_2,\\dots,q_n\\) – два \\(n\\)-мерных вектора. Тогда элементы вектора \\(\\mathbf{R}=(r_1,r_2,\\dots,r_n)\\), равного \\(\\mathbf{R}=\\mathbf{P}\\pm\\mathbf{Q}\\) определяются следующими соотношениями \\(r_i=p_i \\pm q_i\\).\nВ общем случае для любых векторов \\(\\mathbf{P}\\), \\(\\mathbf{Q}\\) и \\(\\mathbf{S}\\), имеющих одинаковую размерность, выполняются следующие соотношения\n\\[\n\\begin{aligned}\n& \\mathbf{P} \\pm \\mathbf{Q} = \\mathbf{Q} \\pm \\mathbf{P} \\quad \\\\\n& (\\mathbf{P} + \\mathbf{Q}) + \\mathbf{S} = \\mathbf{P} + (\\mathbf{Q}+\\mathbf{S})\\\\\n& \\mathbf{P} + (-\\mathbf{P}) = \\mathbf{0}\n\\end{aligned}\n\\]\n\n\nУмножения на скаляр\nДля произвольного вектора \\(\\mathbf{P}\\) и скаляра \\(\\theta\\) (произвольного действительного числа) произведение вектора \\(\\mathbf{P}\\) на скаляр \\(\\theta\\) определяет новый вектор \\(\\mathbf{Q}\\), задаваемый соотношением\n\\[\n\\mathbf{Q}=\\theta \\mathbf{P}=(\\theta p_1,\\theta p_2,\\dots ,\\theta p_n)\n\\]\nВ общем случае для любых векторов \\(\\mathbf{P}\\) и \\(\\mathbf{S}\\) имеющих одинаковую размерность, произвольных скалярных величин \\(\\theta\\) и \\(\\gamma\\) выполняются следющие соотношения\n\\[\n\\begin{aligned}\n&\\theta(\\mathbf{P}+\\mathbf{S})=\\theta \\mathbf{P} + \\theta \\mathbf{S}\\\\\n&\\theta(\\gamma \\mathbf{P})=(\\theta \\gamma)\\mathbf{P}\n\\end{aligned}\n\\]\n\n\nСкалярное произведение\nКаждой паре векторов \\(\\mathbf{A}=(a_1,a_2,\\dots,a_n)\\) и \\(\\mathbf{B}=(b_1,b_2,\\dots,b_n)\\) может быть сопоставлено число\n\\[\n(\\mathbf{A},\\mathbf{B})=\\sum_{i=1}^n{a_i b_i}\n\\]\nназываемое их скалярным произведением. Скалярное произведение обладает следующими свойствами\n\\[\n\\begin{aligned}\n&(\\mathbf{A},\\mathbf{B})=(\\mathbf{B},\\mathbf{A})\\\\\n&(\\mathbf{A}_1 + \\mathbf{A}_2,\\mathbf{B}) = (\\mathbf{A}_1,\\mathbf{B}) + (\\mathbf{A}_2,\\mathbf{B})\\\\\n&(\\lambda \\mathbf{A},\\mathbf{B})=\\lambda(\\mathbf{A},\\mathbf{B})\\\\\n&(\\mathbf{A},\\mathbf{A})\\ge0\\\\\n\\end{aligned}\n\\]\n\n\nНормирование и норма\nДлиной или нормой вектора \\(A=(a_1,a_2,\\dots,a_n)\\) называется число\n\\[\n|\\mathbf{A}|=\\sqrt{(\\mathbf{A},\\mathbf{A})}=\\sqrt{\\sum_{i=1}^n{a_i^2}}\n\\]\n\n\n\n7.1.2 Линейная независимость векторов\nВекторы \\(\\mathbf{P}_1,\\mathbf{P}_2,\\dots,\\mathbf{P}_n\\) называются линейно независимыми, если равенство\n\\[\n\\sum_{j=1}^n{\\theta_j \\mathbf{P}_i}=0 \\quad \\implies \\quad \\theta_j=0,\\quad j=1,2,\\dots,n\n\\]\nвыполняется тогда и только тогда, когда все \\(\\theta_j\\) равны нулю (\\(\\theta_j\\) – произвольные действительные числа). Если равенство \\(\\sum_{j=1}^n{\\theta_j \\mathbf{P}_j}=\\mathbf{0}\\) выполняются при некоторых \\(\\theta_j \\ne 0\\), то векторы \\(\\mathbf{P}_1,\\mathbf{P}_2,\\dots,\\mathbf{P}_n\\) называются линейно зависимыми.\nНапример, векторы \\(\\mathbf{P}_1=(1,2)\\) и \\(\\mathbf{P}_2=(2,4)\\) линейно зависимы, поскольку существуют ненулевые числа \\(\\theta_1=2\\) и \\(\\theta_2=-1\\) при которых выполняется равенство \\(\\theta_1 \\mathbf{P}_1 + \\theta_2 \\mathbf{P}_2=\\mathbf{0}\\)\n\nТеорема 7.1 Для линейной независимости системы векторов \\(\\mathbf{A}_i=(a_{i1},a_{i2},\\dots,a_{in})\\) для \\(i=1,2,\\dots,s\\), необходимо и достаточно существование квадратной матрицы порядка \\(s\\)\n\\[\n\\begin{pmatrix}\na_{1j_1} & a_{1j_2} & \\dots & a_{1j_s} \\\\\na_{1j_1} & a_{1j_2} & \\dots & a_{1j_s} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{sj_1} & a_{sj_2} & \\dots & a_{sj_s}\n\\end{pmatrix}\n\\]\nсоставленной из координат векторов \\(\\mathbf{A}_i\\), с определителем, отличным от нуля. Если в частности, \\(s=n\\), то для линейной независимости данной системы векторов необходимо и достаточно, чтобы\n\\[\n|(\\mathbf{A}_1,\\mathbf{A}_2,\\dots,\\mathbf{A}_n)| \\ne 0\n\\]\n\n\nОпределение 7.2  \n\nРангом\n\nпроизвольной системы векторов называется максимальное число линейно независимых векторов данной системы.\n\n\n\n\nОпределение 7.3  \n\nБазисом\n\nназывает совокупность линейно независимых векторов системы, число которых равно её рангу.\n\n\n\nМножество линейно независимых векторов данной системы является её базисом в том и только в том случае, если любой вектор системы представим в виде линейной комбинации векторов рассматриваемого множества.",
    "crumbs": [
      "Линейное программирование",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Элементы линейной алгебры</span>"
    ]
  },
  {
    "objectID": "linear/algebra.html#sec-linear-algebra-matrix",
    "href": "linear/algebra.html#sec-linear-algebra-matrix",
    "title": "7  Элементы линейной алгебры",
    "section": "7.2 Матрица",
    "text": "7.2 Матрица\n\nОпределение 7.4  \n\nМатрицей\n\nназывается прямоугольный массив элементов, структурированный строками и столбцами. В матрице \\(\\mathbf{A}\\) элемент \\(a_{ij}\\) расположен на пересечении \\(i\\)-й строки и \\(j\\)-го столбца массива.\n\n\n\nГоворят, что матрица имеет порядок (размерность) \\(m \\times n\\), если она состоит из \\(m\\) строк b \\(n\\) столбцов. Например следующая матрица имеет размерность \\(4 \\times 3\\)\n\\[\n\\begin{pmatrix}\na_{11} & a_{12} & a_{13} \\\\\na_{21} & a_{22} & a_{23} \\\\\na_{31} & a_{32} & a_{33} \\\\\na_{41} & a_{42} & a_{43}\n\\end{pmatrix} = {\\|a_{ij}\\|}_{4 \\times 3}\n\\]\n\n7.2.1 Типы матриц\n\nОпределение 7.5  \n\nКвадратная матрица\n\nэто матрица, имеющая одинаковое количество строк и столбцов, т.е. у нее \\(m=n\\).\n\n\n\n\nОпределение 7.6  \n\nЕдиничная матрица\n\nэто квадратная матрица, у которой все элементы главной диагонали равны 1, а все остальные – нулю.\n\n\n\nНапример, единичная матрица порядка \\(3 \\times 3\\) имеет вид\n\\[\n\\mathbf{I_3}=\n\\begin{pmatrix}\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1\n\\end{pmatrix}\n\\]\n\nОпределение 7.7  \n\nНулевая матрица\n\nэто матрица все элементы которой равны нулю \\(\\mathbf{B}=\\mathbf{0}\\).\n\n\n\n\nОпределение 7.8  \n\nВектор-строка\n\nэто матрица, имеющая одну строку и \\(n\\) столбцов.\n\n\n\n\\[\n\\mathbf{P}=(p_1,p_2,\\dots,p_n)\n\\]\n\nОпределение 7.9  \n\nВектор-столбец\n\nэто матрица, имеющая \\(m\\) строк и один столбец.\n\n\n\n\\[\n\\mathbf{P}=\n\\begin{pmatrix}\np_1 \\\\\np_2 \\\\\n\\vdots \\\\\np_n\n\\end{pmatrix}\n\\]\n\nОпределение 7.10  \n\nДиагональная матрица\n\nквадратная матрица, все элементы которой, стоящие вне главной диагонали, равны нулю.\n\n\n\n\\[\n\\mathbf{D}=\n\\begin{pmatrix}\nd_{11} & 0 & \\cdots & 0 \\\\\n0 & d_{22} & \\cdots & 0 \\\\\n\\vdots & \\vdots  & \\ddots & \\vdots \\\\\n0 & 0 & 0 & d_{nn} \\\n\\end{pmatrix}\n\\]\nДиагональная матрица \\(\\mathbf{D}\\) с элементами \\((d_1,d_2,\\dots,d_n)\\), стоящими на главной диагонали, обозначается \\(\\mathrm{diag}\\{d_1,d_2,\\dots,d_n\\}\\)\n\nОпределение 7.11  \n\nБлочная матрица\n\nэто представление матрицы, при котором она рассекается вертикальными и горизонтальными линиями на прямоугольные части — блоки\n\n\n\n\\[\n\\mathbf{A}=\n\\begin{pmatrix}\n\\mathbf{A}_{11} & \\mathbf{A}_{12} & \\dots & \\mathbf{A}_{1t} \\\\\n\\mathbf{A}_{21} & \\mathbf{A}_{22} & \\dots & \\mathbf{A}_{2t} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n\\mathbf{A}_{s1} & \\mathbf{A}_{s2} & \\dots & \\mathbf{A}_{st}\n\\end{pmatrix}\n\\]\nгде блок \\(\\mathbf{A}_{\\alpha \\beta}\\) имеет размер \\(m_\\alpha \\times n_\\beta\\) для \\(\\alpha=1,2,\\dots,s\\) и \\(\\beta=1,2,\\dots,t\\).\nНапример матрица размером \\(4 \\times 4\\)\n\\[\n\\mathbf{P} =\n\\begin{pmatrix}\n1 & 1 & 2 & 2 \\\\\n1 & 1 & 2 & 2 \\\\\n3 & 3 & 4 & 4 \\\\\n3 & 3 & 4 & 4\n\\end{pmatrix}\n\\]\nМожет быть представлена в виде блочной матрицы из четырёх блоков размера \\(2 \\times 2\\) каждый. При следующем определении блоков\n\\[\n\\mathbf{P}_{11}=\n\\begin{pmatrix}\n1 & 1 \\\\\n1 & 1\n\\end{pmatrix},\n\\mathbf{P}_{12}=\n\\begin{pmatrix}\n2 & 2 \\\\\n2 & 2\n\\end{pmatrix},\n\\mathbf{P}_{21}=\n\\begin{pmatrix}\n3 & 3 \\\\\n3 & 3\n\\end{pmatrix},\n\\mathbf{P}_{22}=\n\\begin{pmatrix}\n4 & 4 \\\\\n4 & 4\n\\end{pmatrix}\n\\]\nблочная матрица может быть записана в таком виде:\n\\[\n\\mathbf{P}=\n\\left(\n\\begin{array}{c | c}\n\\mathbf{P}_{11} & \\mathbf{P}_{12} \\\\\n\\hline\n\\mathbf{P}_{21} & \\mathbf{P}_{22}\n\\end{array}\\right)\n\\]\n\n\n7.2.2 Операции\nДля матриц определены только операции сложения (вычитания) и умножения Операция деления матриц не определена, но в некоторых случаях её может заменить операция обращения матриц.\n\nСложение и вычитание\nСложение (вычитание) двух матриц \\(\\mathbf{A}=\\|a_{ij}\\|\\) и \\(\\mathbf{B}=\\|b_{ij}\\|\\) возможно только тогда, когда они имеют одинаковую размерность \\((m \\times n)\\). Матрица суммы \\(\\mathbf{D}=\\mathbf{A}+\\mathbf{B}\\) получается путём сложения соответствующих элементов матриц \\(A\\) и \\(B\\), т.е. \\({\\|d_{ij}\\|}_{m \\times n} = {\\|a_{ij}+b_{ij}\\|}_{m \\times n}\\).\nДля произвольных матриц \\(\\mathbf{A}\\), \\(\\mathbf{B}\\) и \\(\\mathbf{C}\\), имеющих одинаковую размерность справедливы следующие соотношения\n\\[\n\\begin{aligned}\n& \\mathbf{A} \\pm \\mathbf{B} = \\mathbf{B} \\pm \\mathbf{A} \\\\\n& \\mathbf{A} \\pm (\\mathbf{B} \\pm \\mathbf{C}) = (\\mathbf{A} \\pm \\mathbf{B}) \\pm \\mathbf{C} \\\\\n& {(\\mathbf{A} \\pm \\mathbf{B})}^T = \\mathbf{A}^T \\pm \\mathbf{B}^T\n\\end{aligned}\n\\]\n\n\nПроизведение\nПроизведение \\(\\mathbf{D}=\\mathbf{AB}\\) для двух матриц \\(\\mathbf{A}=\\|a_{ij}\\|\\) и \\(\\mathbf{B}=\\|b_{ij}\\|\\) определено тогда и только тогда, когда количество столбцов матрицы \\(\\mathbf{A}\\) равно количеству строк матрицы \\(\\mathbf{B}\\). Таким образом, если матрица \\(\\mathbf{A}\\) имеет размерность \\(m \\times r\\), матрица \\(\\mathbf{B}\\) должна иметь размерность \\(r \\times n\\), где \\(m\\) и \\(n\\) — произвольные положительные целые числа. В этом случае матрица их произведения \\(\\mathbf{D}\\) будет иметь размерность \\(m \\times n\\), а её элементы \\(d_{ij}\\) для всех \\(i\\) и \\(j\\) вычисляются по формуле\n\\[\nd_{ij}=\\sum_{k=1}^r{a_{ik}b_{kj}}\n\\]\nНапример, если\n\\[\n\\mathbf{A}=\n\\begin{pmatrix}\n1 & 3 \\\\\n2 & 4\n\\end{pmatrix}\n\\quad и \\quad\n\\mathbf{B}=\n\\begin{pmatrix}\n5 & 7 & 9 \\\\\n6 & 8 & 0\n\\end{pmatrix}\n\\]\nто\n\\[\n\\mathbf{D}=\n\\begin{pmatrix}\n1 & 3 \\\\\n2 & 4\n\\end{pmatrix}\n\\begin{pmatrix}\n5 & 7 & 9 \\\\\n6 & 8 & 0\n\\end{pmatrix} = \\\\\n=\n\\begin{pmatrix}\n1 \\cdot 5 + 3 \\cdot 6 & 1 \\cdot 7 + 3 \\cdot 8 & 1 \\cdot 9 + 3 \\cdot 0 \\\\\n2 \\cdot 5 + 4 \\cdot 6 & 2 \\cdot 7 + 4 \\cdot 8 & 2 \\cdot 9 + 4 \\cdot 0\n\\end{pmatrix} =\\\\\n=\n\\begin{pmatrix}\n23 & 31 & 9 \\\\\n34 & 46 & 18\n\\end{pmatrix}\n\\]\nВ общем случае \\(\\mathbf{AB} \\ne \\mathbf{BA}\\), даже если произведение \\(\\mathbf{BA}\\) определено. Произведение матриц обладает следующими свойствами\n\\[\n\\begin{aligned}\n& \\mathbf{I}_m \\mathbf{A} = \\mathbf{A}\\mathbf{I}_n,\\quad \\text{где} \\ \\mathbf{I}_m \\ и \\ \\mathbf{I}_n \\ - \\ \\text{единичные матрицы} \\\\\n& \\mathbf{(AB)C} = \\mathbf{A(BC)} \\\\\n& \\mathbf{C(A+B)} = \\mathbf{CA + CB} \\\\\n& \\mathbf{(A+B)C} = \\mathbf{AC + BC} \\\\\n& \\alpha \\mathbf{(AB)} = \\mathbf{A} (\\alpha \\mathbf{B}),\\quad \\text{где} \\ \\alpha \\ - \\text{скаляр}\n\\end{aligned}\n\\]\nПусть матрицы \\(\\mathbf{A}\\) и \\(\\mathbf{B}\\) имеют размерности \\(m \\times r\\) и \\(r \\times n\\) соответственно. Предположим, что эти матрицы представимы в виде совокупности блоков\n\\[\n\\mathbf{A} =\n\\left(\n\\begin{array}{c | c | c}\n\\mathbf{A}_{11} & \\mathbf{A}_{12} & \\mathbf{A}_{13}  \\\\\n\\hline\n\\mathbf{A}_{21} & \\mathbf{A}_{22} & \\mathbf{A}_{23}\n\\end{array}\n\\right)\n\\quad и \\quad\n\\mathbf{B} =\n\\left(\n\\begin{array}{c | c}\n\\mathbf{B}_{11} & \\mathbf{B}_{12} \\\\\n\\hline\n\\mathbf{B}_{21} & \\mathbf{B}_{22} \\\\\n\\hline\n\\mathbf{B}_{31} & \\mathbf{B}_{32} \\\\\n\\end{array}\n\\right)\n\\]\nпричём для всех \\(i\\) и \\(j\\) число столбцов в блоке \\(\\mathbf{A}_{ij}\\) равно числу строк в блоке \\(\\mathbf{B}_{ji}\\). Тогда\n\\[\n\\mathbf{A} \\times \\mathbf{B} =\n\\left(\n\\begin{array}{c | c}\n\\mathbf{A}_{11} \\mathbf{B}_{11} + \\mathbf{A}_{12} \\mathbf{B}_{21} + \\mathbf{A}_{13} \\mathbf{B}_{31} &\n\\mathbf{A}_{11} \\mathbf{A}_{12} + \\mathbf{A}_{12} \\mathbf{B}_{22} + \\mathbf{A}_{13} \\mathbf{B}_{32} \\\\\n\\hline\n\\mathbf{A}_{21} \\mathbf{B}_{11} + \\mathbf{A}_{22} \\mathbf{B}_{21} + \\mathbf{A}_{23} \\mathbf{B}_{31} &\n\\mathbf{A}_{21} \\mathbf{A}_{12} + \\mathbf{A}_{22} \\mathbf{B}_{22} + \\mathbf{A}_{23} \\mathbf{B}_{32} \\\\\n\\end{array}\n\\right)\n\\]\nНапример\n\\[\n\\left(\n\\begin{array}{c | c}\n1 &\n\\begin{matrix}\n2 & 3\n\\end{matrix} \\\\\n\\hline\n\\begin{matrix}\n1 \\\\ 2\n\\end{matrix} &\n\\begin{matrix}\n0 & 5 \\\\\n5 & 6\n\\end{matrix}\n\\end{array}\n\\right)\n\\begin{pmatrix}\n4\\\\\n\\hline\n1 \\\\\n8\n\\end{pmatrix} =\n\\begin{pmatrix}\n(1)(4) +\n\\begin{pmatrix}\n2 & 3\n\\end{pmatrix}\n\\begin{pmatrix}\n1 \\\\\n8\n\\end{pmatrix} \\\\\n\\hline\n\\begin{pmatrix}\n1 \\\\\n2\n\\end{pmatrix}\n(4) +\n\\begin{pmatrix}\n0 & 5 \\\\\n5 & 6\n\\end{pmatrix}\n\\begin{pmatrix}\n1 \\\\ 8\n\\end{pmatrix}\n\\end{pmatrix} =\n\\begin{pmatrix}\n4+2+24\\\\\n\\hline\n\\begin{pmatrix}\n4 \\\\ 8\n\\end{pmatrix} +\n\\begin{pmatrix}\n40 \\\\ 53\n\\end{pmatrix}\n\\end{pmatrix} =\n\\begin{pmatrix}\n30 \\\\ 44 \\\\ 61\n\\end{pmatrix}\n\\]\n\n\nТранспонирование\nМатрица \\(\\mathbf{A}^T\\) называется транспонированной к матрице \\(\\mathbf{A}\\), если элемент \\(a_{ij}\\) матрицы \\(\\mathbf{A}^T\\) равен элементу \\(a_{ji}\\) матрицы \\(\\mathbf{A}\\). Например\n\\[\n\\mathbf{A}=\n\\begin{pmatrix}\n1 & 4 \\\\\n2 & 5 \\\\\n3 & 6\n\\end{pmatrix}\n\\implies\n\\mathbf{A}^T=\n\\begin{pmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6\n\\end{pmatrix}\n\\]\n\n\n\n7.2.3 Определитель\nОпределитель матрицы обычно обозначается как \\(\\det{\\mathbf{A}}\\) или \\(|\\mathbf{A}|\\). Для квадратной матрицы \\(\\mathbf{A}\\) порядка \\(3\\)\n\\[\n\\mathbf{A}=\n\\begin{pmatrix}\na_{11} & a_{12} & a_{13} \\\\\na_{21} & a_{22} & a_{23} \\\\\na_{31} & a_{32} & a_{33}\n\\end{pmatrix}\n\\]\nто\n\\[\n|\\mathbf{A}|=\na_{11}(a_{22}a_{33} - a_{23}a_{32}) - a_{12}(a_{21}a_{33}-a_{31}a_{23}) + a_{13}(a_{21}a_{32} - a_{22}a_{31})\n\\]\nОпределитель обладает следующими свойствами\n\nЕсли все элементы какого-нибудь столбца или строки матрицы равны нулю, определитель этой матрицы равен нулю.\nОпределитель транспонированной матрицы равен определителю исходной матрицы, \\(|{\\mathbf{A}}^T|=|\\mathbf{A}|\\)\nЕсли матрица \\(\\mathbf{B}\\) получена из матрицы \\(\\mathbf{A}\\) путём перестановки двух каких либо строк (или двух столбцов), тогда \\(|\\mathbf{B}|=-|\\mathbf{A}|\\)\n\nЕсли две строки (или два столбца) в матрице одинаковы, то её определитель равен нулю.\nЗначение определителя \\(|\\mathbf{A}|\\) не изменяется, если какую-либо строку матрицы (столбец) умножить на скаляр \\(\\alpha\\) и затем прибавить её к другой строке (столбцу).\nЕсли каждый элемент какой-либо строки (столбца) умножить на скаляр \\(\\alpha\\), то значение определителя также будет умножено на это число \\(\\alpha\\).\nЕсли \\(\\mathbf{A}\\) и \\(\\mathbf{B}\\) – две квадратные матрицы порядка \\(n\\), то \\(|\\mathbf{AB}|=|\\mathbf{A}||\\mathbf{B}|\\)\n\n\n\n7.2.4 Обратная матрица\nЕсли \\(\\mathbf{B}\\) и \\(\\mathbf{C}\\) – две квадратные матрицы порядка \\(n\\), причём такие, что \\(\\mathbf{BC}=\\mathbf{CD}=I\\), тогда матрица \\(\\mathbf{B}\\) называется обратной к матрице \\(\\mathbf{C}\\), при этом матрица \\(\\mathbf{C}\\) также будет опратной к матрице \\(\\mathbf{B}\\). Обратные матрицы обозначаются как \\({\\mathbf{B}}^{-1}\\) и \\({\\mathbf{C}}^{-1}\\).\n\nТеорема 7.2 Если \\(\\mathbf{BC}=\\mathbf{I}\\) и \\(\\mathbf{B}\\) – невырожденная матрица, тогда \\(\\mathbf{C}={\\mathbf{B}}^{-1}\\), причём матрица \\(\\mathbf{C}\\) определяется единственным образом.\n\nОбратные матрицы находят применение при решении систем линейных уравнений. Рассмотрим систему из \\(т\\) линейных уравнений\n\\[\n\\begin{pmatrix}\na_{11} & a_{12} & \\cdots & a_{1n} \\\\\na_{21} & a_{22} & \\cdots & a_{2n} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{n1} & a_{n2} & \\cdots & a_{nn}\n\\end{pmatrix}\n\\begin{pmatrix}\nx_1 \\\\ x_2 \\\\ \\vdots \\\\ x_n\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nb_1 \\\\ b_2 \\\\ \\vdots \\\\ b_n\n\\end{pmatrix}\n\\]\nгде \\(x_i\\) – неизвестные, \\(a_{ij}\\) и \\(b_{i}\\) – заданные константы. Эта система и \\(n\\) уравнений в матричной форме запишется так: \\(\\mathbf{AB}=\\mathbf{b}\\). Поскольку уравнения системы линейно независимы, матрица \\(\\mathbf{A}\\) будет невырожденной, и, следовательно, будет существовать обратная к ней матрица. Таким образом,имеем\n\\[\n{\\mathbf{A}}^{-1}\\mathbf{AX}={\\mathbf{A}}^{-1}\\mathbf{b}\n\\]\nоткуда получаем решение системы: \\(\\mathbf{X}={\\mathbf{A}}^{-1}\\mathbf{b}\\).\n\nВычисление методом последовательных исключений (метод Гаусса–Жордана)\nРассмотрим блочную матрицу \\(\\mathbf{A}|\\mathbf{I}\\), где \\(\\mathbf{A}\\) – невырожденная матрица. Умножая слева эту матрицу на матрицу \\({\\mathbf{A}}^{-1}\\), получим\n\\[\n({\\mathbf{A}}^{-1}\\mathbf{A} | {\\mathbf{A}}^{-1} I) = (\\mathbf{I} | {\\mathbf{A}}^{-1})\n\\]\nТаким образом, при последовательном преобразовании строк исходной матрицы, обеспечивающем преобразование матрицы \\(\\mathbf{A}\\) в \\(\\mathbf{I}\\), одновременно матрица \\(\\mathbf{I}\\) преобразуется в матрицу \\({\\mathbf{A}}^{-1}\\). Как пример рассмотрим систему линейных уравнений\n\\[\n\\begin{pmatrix}\n1 & 2 & 3 \\\\\n2 & 3 & 2 \\\\\n3 & 3 & 4\n\\end{pmatrix}\n\\begin{pmatrix}\nx_1 \\\\ x_2 \\\\ x_3\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n3 \\\\ 4 \\\\ 5\n\\end{pmatrix}\n\\]\nВектор решений \\(\\mathbf{X}\\) и матрицу, обратную к матрице данной системы, можно получить из соотношения\n\\[\n{\\mathbf{A}}^{-1}(\\mathbf{A} | \\mathbf{I} | \\mathbf{b}) =\n(\\mathbf{I} | {\\mathbf{A}}^{-1} | {\\mathbf{A}}^{-1} \\mathbf{b} )\n\\]\nРеализация метода последовательных исключений приводит к следующей последовательности действий. Исходная матрица имеет вид\n\\[\n\\left( \\begin{array}{c | c |c}\n\\begin{matrix}\n1 & 2 & 3 \\\\\n2 & 3 & 2 \\\\\n3 & 3 & 4\n\\end{matrix}\n&\n\\begin{matrix}\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1\n\\end{matrix}\n&\n\\begin{matrix}\n3 \\\\ 4 \\\\ 5\n\\end{matrix}\n\\end{array}\\right)\n\\]\nИтерация 1\n\\[\n\\left( \\begin{array}{c | c | c}\n\\begin{matrix}\n1 & 2 & 3 \\\\\n0 & -1 & -4 \\\\\n0 & -3 & -5\n\\end{matrix}\n&\n\\begin{matrix}\n1 & 0 & 0 \\\\\n-2 & 1 & 0 \\\\\n-3 & 0 & 1\n\\end{matrix}\n&\n\\begin{matrix}\n3 \\\\ -2 \\\\ -4\n\\end{matrix}\n\\end{array}\\right)\n\\]\nИтерация 2\n\\[\n\\left( \\begin{array}{c | c | c}\n\\begin{matrix}\n1 & 0 & -5 \\\\\n0 & 1 & 4 \\\\\n0 & 0 & 7\n\\end{matrix}\n&\n\\begin{matrix}\n-3 & 2 & 0 \\\\\n2 & 1 & 0 \\\\\n3 & -3 & 1\n\\end{matrix}\n&\n\\begin{matrix}\n-1 \\\\ 2 \\\\ 2\n\\end{matrix}\n\\end{array}\\right)\n\\]\nИтерация 3\n\\[\n\\left( \\begin{array}{c | c | c}\n\\begin{matrix}\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1\n\\end{matrix}\n&\n\\begin{matrix}\n-\\frac{6}{7} & -\\frac{1}{7} & \\frac{5}{7} \\\\\n\\frac{2}{7} & \\frac{5}{7} & -\\frac{4}{7} \\\\\n\\frac{3}{7} & -\\frac{3}{7} & \\frac{1}{7}\n\\end{matrix}\n&\n\\begin{matrix}\n\\frac{3}{7} \\\\\n\\frac{6}{7} \\\\\n\\frac{2}{7}\n\\end{matrix}\n\\end{array}\\right)\n\\]\nВ результате получено решение системы: \\(x_1=\\frac{3}{7}\\), \\(x_2=\\frac{6}{7}\\), \\(x_3=\\frac{2}{7}\\). Обратная матрица \\({\\mathbf{A}}^{-1}\\) приведена справа от единичной матрицы.\n\n\nВычисление методом мультипликативного дополнения",
    "crumbs": [
      "Линейное программирование",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Элементы линейной алгебры</span>"
    ]
  },
  {
    "objectID": "linear/algebra.html#sec-linear-algebra-equation-system",
    "href": "linear/algebra.html#sec-linear-algebra-equation-system",
    "title": "7  Элементы линейной алгебры",
    "section": "7.3 Система линейных алгебраических уравнений",
    "text": "7.3 Система линейных алгебраических уравнений\n\n7.3.1 Случай двух переменных\n\nНесовместимость системы\n\\[\n\\begin{pmatrix}\n1 & -1 \\\\\n0 & 0\n\\end{pmatrix}\n\\begin{pmatrix}\nx_1 \\\\ x_2\n\\end{pmatrix} =\n\\begin{pmatrix}\n-1 \\\\ 2\n\\end{pmatrix} \\\\\n\\begin{aligned}\nx_1 - x_2 &= -1 \\\\\n0 &= 2\n\\end{aligned}\n\\]\n\n\nЕдинственное решение\n\\[\n\\begin{pmatrix}\n1 & -1 \\\\\n1 & 2\n\\end{pmatrix}\n\\begin{pmatrix}\nx_1 \\\\ x_2\n\\end{pmatrix} =\n\\begin{pmatrix}\n-1 \\\\ 2\n\\end{pmatrix} \\\\\n\\begin{aligned}\nx_1 &= 0\\\\\nx_2 &= 1\n\\end{aligned}\n\\]\n\n\n\n\n\n\n\n\nБесконечное множество решений\n\\[\n\\begin{pmatrix}\n1 & -1 \\\\\n0 & 0\n\\end{pmatrix}\n\\begin{pmatrix}\nx_1 \\\\ x_2\n\\end{pmatrix} =\n\\begin{pmatrix}\n-1 \\\\ 0\n\\end{pmatrix} \\\\\n\\begin{aligned}\nx_1 - x_2 &= -1 \\\\\n0 &= 0\n\\end{aligned}\n\\]\n\n\n\n\n\n\n\n\nОтсутствие решений\n\\[\n\\begin{pmatrix}\n1 & -1 \\\\\n1 & -1\n\\end{pmatrix}\n\\begin{pmatrix}\nx_1 \\\\ x_2\n\\end{pmatrix} =\n\\begin{pmatrix}\n-1 \\\\ 2\n\\end{pmatrix} \\\\\n\\begin{aligned}\nx_1 - x_2 &= -1 \\\\\n0 &= 3\n\\end{aligned}\n\\]\n\n\n\n7.3.2 Случай n переменных. Метод Гаусса — Жордана\n\nАлгоритм\n\n\nПример\n\n\n\n\n1. Eager E. Linear Algebra for Data Science in R [Электронный ресурс]. 2021. URL: https://rpubs.com/odenipinedo/linear-algebra-for-data-science-in-R (дата обращения: 20.02.2025).\n\n\n2. Гольштейн Евгений Григорьевич Ю.Д.Б. Математические основы и практические задачи. стереотипное. Москва: ЛЕНАНД, 2022. Т. 1. С. 320.\n\n\n3. А. Т.Х. Исследование операций. 10-е изд. / под ред. Слепцова А.В. Санкт-Петербург: ООО \"Диалектика\", 2019. С. 1056.",
    "crumbs": [
      "Линейное программирование",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Элементы линейной алгебры</span>"
    ]
  },
  {
    "objectID": "linear/graphical/solution.html",
    "href": "linear/graphical/solution.html",
    "title": "8  Графическое решение",
    "section": "",
    "text": "ОсторожностьСостояние разработки\n\n\n\nТребуется доработка\n\n\n\\[\\begin{cases}\n      \\max{F(x)=2x_1+6x_2}\\\\\n      x_1+4x_2\\leq2048\\\\\n      2x_1+x_2\\leq2048\\\\\n      x2\\leq480\\\\\n      x1,x2\\geq0\n\\end{cases}\\]\nЗадача 1 найти область удовлетворяющую ограничениям. Сразу можно сказать, что рассматривается первая четверть из-за ограничения на положительность переменных. Определим функцию для построения замкнутой области на графике используя библиотеку plotly.\n\n\n\n\n\n\nИтоговая область поиска:\n\n\n\n\n\n\nТеперь можно добавить график уровня функции и совместить его с графиком ограничений\n\n\n\n\n\n\nСледовательно наилучшее значение функции в точке \\((x=\\frac{6144}{7},y=\\frac{2048}{7})\\)",
    "crumbs": [
      "Линейное программирование",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Графическое решение</span>"
    ]
  },
  {
    "objectID": "linear/graphical/sensetivity.html",
    "href": "linear/graphical/sensetivity.html",
    "title": "9  Графический анализ чувствительности",
    "section": "",
    "text": "Важное уведомлениеСостояние разработки\n\n\n\nВ разработке",
    "crumbs": [
      "Линейное программирование",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Графический анализ чувствительности</span>"
    ]
  },
  {
    "objectID": "linear/simplex/special-cases.html",
    "href": "linear/simplex/special-cases.html",
    "title": "10  Особые случаи применения симплекс метода",
    "section": "",
    "text": "10.1 Альтернативные решения\n\\[\\begin{cases}\n      \\max{F(x)=x_1+2x_2}\\\\\n      x_1\\leq80\\\\\n      5x_1+6x_2\\leq600\\\\\n      x_1+2x_2\\leq160\\\\\n      x1,x2\\geq0\n\\end{cases}\\]\nИзобразим область поиска соответствующую ограничениям\nТеперь можно добавить график уровня функции и совместить его с графиком ограничений\nИз графика следует то, что прямая постоянного уровня целевой функции \\(F(x)=x_1+2x_2\\) совпала с прямой задающей ограничение \\(x_1+2x_2\\leq160\\). Значит все точки принадлежащие прямой проходящей через координаты \\(P(0,80)\\) и \\(Q(60,50)\\) будут соответствовать оптимальному решению.\nlibrary(lpSolve)\nFun &lt;- c(1, 2)\nA &lt;- rbind(c(0, 1), c(5, 6), c(1, 2))\nB &lt;- c(80, 600, 160)\nCD &lt;- c('&lt;=', '&lt;=', '&lt;=')\n\noptimum &lt;- lp(\n  direction = 'max',\n  objective.in = Fun,\n  const.mat = A,\n  const.dir = CD,\n  const.rhs = B,\n  compute.sens = TRUE)\n\noptimum\n\nSuccess: the objective function is 160 \n\noptimum$solution\n\n[1]  0 80\nПроцедура поиска решения находит только одну точку.\noptimum$sens.coef.from\n\n[1] -1e+30  2e+00\n\noptimum$sens.coef.to\n\n[1] 1e+00 1e+30\nАнализ чувствительности показывает, что активно только ограничение \\(x_1+2x_2\\leq160\\), а соответствующее значенеи \\(\\xi=1\\)\noptimum$duals\n\n[1] 0 0 1 0 0\n\noptimum$duals.from\n\n[1]  5.0e+01 -1.0e+30  1.6e+02 -1.0e+30 -1.0e+30\n\noptimum$duals.to\n\n[1] 8.00e+01 1.00e+30 1.84e+02 1.00e+30 1.00e+30",
    "crumbs": [
      "Линейное программирование",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Особые случаи применения симплекс метода</span>"
    ]
  },
  {
    "objectID": "linear/simplex/special-cases.html#отсутствие-допустимых-решений",
    "href": "linear/simplex/special-cases.html#отсутствие-допустимых-решений",
    "title": "10  Особые случаи применения симплекс метода",
    "section": "10.2 Отсутствие допустимых решений",
    "text": "10.2 Отсутствие допустимых решений\nВ данном случае условия ограничений не совместимы.\n\\[\\begin{cases}\n      \\max{F(x)=200x_1+300x_2}\\\\\n      2x_1+3x_2\\geq1200\\\\\n      x_1+x_2\\leq400\\\\\n      2x_1+1.5x_2\\geq900\\\\\n      x1,x2\\geq0\n\\end{cases}\\]\n\n\n\n\n\n\n\nlibrary(lpSolve)\nFun &lt;- c(200, 300)\nA &lt;- rbind(c(2, 3), c(1, 2), c(2, 1.5))\nB &lt;- c(1200, 400, 900)\nCD &lt;- c('&gt;=', '&lt;=', '&gt;=')\n\noptimum &lt;- lp(\n  direction = 'max',\n  objective.in = Fun,\n  const.mat = A,\n  const.dir = CD,\n  const.rhs = B,\n  compute.sens = TRUE)\n\noptimum\n\nError: no feasible solution found\n\noptimum$solution\n\n[1] 0 0\n\n\nПроцедура поиска решения завершается с ошибкой",
    "crumbs": [
      "Линейное программирование",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Особые случаи применения симплекс метода</span>"
    ]
  },
  {
    "objectID": "linear/simplex/special-cases.html#неограниченность-решений",
    "href": "linear/simplex/special-cases.html#неограниченность-решений",
    "title": "10  Особые случаи применения симплекс метода",
    "section": "10.3 Неограниченность решений",
    "text": "10.3 Неограниченность решений\nЕсли область поиска решения не ограничена, то одна или несколько переменных будут увеличиваться бесконечно, не нарушая ограничений, а значение целевой функции можно принимать произвольно большие значения. Рассмотрим следующую модель:\n\\[\\begin{cases}\n      \\max{F(x)=40x_1+60x_2}\\\\\n      2x_1+x_2\\geq70\\\\\n      x_1+x_2\\geq40\\\\\n      x_1+3x_2\\geq90\\\\\n      x1,x2\\geq0\n\\end{cases}\\]\n\n\n\n\n\n\nОбъединяя добавляя контурный график\n\n\n\n\n\n\nОграничения заданные в этом примере не ограничивают область поиска в направлениии \\(x\\to\\infty\\) и \\(y\\to\\infty\\). Целевая функция неограниченно возрастает в этом направлении, следовательно и решение неограниченно.\n\nlibrary(lpSolve)\nFun &lt;- c(40, 60)\nA &lt;- rbind(c(2, 1), c(1, 1), c(1, 3))\nB &lt;- c(70, 40, 90)\nCD &lt;- c('&gt;=', '&gt;=', '&gt;=')\n\noptimum &lt;- lp(\n  direction = 'max',\n  objective.in = Fun,\n  const.mat = A,\n  const.dir = CD,\n  const.rhs = B,\n  compute.sens = TRUE)\n\noptimum\n\nError: status 3 \n\noptimum$solution\n\n[1] 0 0\n\n\nПроцедура поиска решения завершается с ошибкой 3: UNBOUNDED (3) The model is unbounded.",
    "crumbs": [
      "Линейное программирование",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Особые случаи применения симплекс метода</span>"
    ]
  },
  {
    "objectID": "linear/simplex/special-cases.html#вырожденность",
    "href": "linear/simplex/special-cases.html#вырожденность",
    "title": "10  Особые случаи применения симплекс метода",
    "section": "10.4 Вырожденность",
    "text": "10.4 Вырожденность",
    "crumbs": [
      "Линейное программирование",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Особые случаи применения симплекс метода</span>"
    ]
  },
  {
    "objectID": "linear/integer.html",
    "href": "linear/integer.html",
    "title": "11  Целочисленное программирование",
    "section": "",
    "text": "11.1 Метод ветвей и границ\nРассмотрим следующую задачу оптимизации в которой наглядно показано отличие целочисленного решения и округления решения в действительных числах.\n\\[\\begin{cases}\n      \\max{F(x,y)=y}\\\\\n      -x+y\\leq1\\\\\n      3x+2y\\leq12\\\\\n      2x+3y\\leq12\\\\\n      x,y\\geq0\\\\\n      x,y\\in\\mathbb{Z}\n\\end{cases}\\,\\] Для этого зададим все условия\nТеперь рассмотрим решение в действительных числах\nSuccess: the objective function is 2.8 \n\n\n[1] 1.8 2.8\nОкругляя до ближайшего целого получаем что точка (1.8,2.8) выходит из области определения",
    "crumbs": [
      "Линейное программирование",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Целочисленное программирование</span>"
    ]
  },
  {
    "objectID": "linear/integer.html#sec-linear-integer-method-branch-and-bound",
    "href": "linear/integer.html#sec-linear-integer-method-branch-and-bound",
    "title": "11  Целочисленное программирование",
    "section": "",
    "text": "Важное уведомлениеСостояние разработки\n\n\n\nТребуется доработка",
    "crumbs": [
      "Линейное программирование",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Целочисленное программирование</span>"
    ]
  },
  {
    "objectID": "linear/integer.html#бинарная",
    "href": "linear/integer.html#бинарная",
    "title": "11  Целочисленное программирование",
    "section": "11.2 Бинарная",
    "text": "11.2 Бинарная\nТелекоммуникационная компания хочет установить радиовышки в новом регионе, который состоит из 13 областей. Области и число жителей показано на рисунке. Мощности устанавливаемого передатчика хватает, чтобы обслуживать область, в которой он установлен и граничащие с ней.\n\n\n\nОбласти с числом жителей\n\n\nЗадача 1: Разместить наименьшее число передатчиков так, чтобы компания могла оказывать услуги во всем регионе.\nЗадача 2: Имеется возможность установить один передатчик, установить его так, чтобы число клиентов было максимальным.\n\n11.2.1 Решение\nПередатчик в области может либо быть, либо отсутствовать. Это приводит к применению бинарных переменных. Для начала требуется сформировать условие присутствия в соседних областях. Т.е. передатчик должен быть установлен или в самой области, или в граничащих с ним. Так для области 1 условие формулируется так:\n\\[x_1+x_{11}+x_{10}+x_{13}\\geq1\\]\nОчевидно, что целевая функция выглядит следующим образом\n\\[\\min{\\Sigma x_i}\\]\nТогда полная формализация задачи:\n\nЗадача 1\n\\[\\begin{cases}\n      \\min{F(x)=x_1+x_2+x_3+x_4+x_5+x_6+x_7+x_8+x_9+x_{11}+x_{12}+x_{13}}\\\\\n      x_1+x_{10}+x_{11}+x_{13}\\geq1\\\\\n      x_2+x_9+x_{11}\\geq1\\\\\n      x_3+x_8+x_9+x_{13}\\geq1\\\\\n      x_4+x_5+x_6+x_{12}\\geq1\\\\\n      x_5+x_4+x_{12}\\geq1\\\\\n      x_6+x_4+x_7+x_{12}\\geq1\\\\\n      x_7+x_6+x_8+x_{10}+x_{13}\\geq1\\\\\n      x_8+x_3+x_6+x_7+x_{13}\\geq1\\\\\n      x_9+x_2+x_3+x_{11}+x_{13}\\geq1\\\\\n      x_{10}+x_1+x_7+x_{12}+x_{13}\\geq1\\\\\n      x_{11}+x_1+x_2+x_9+x_{13}\\geq1\\\\\n      x_{12}+x_4+x_5+x_6+x_{10}\\geq1\\\\\n      x_{13}+x_1+x_3+x_7+x_8+x_9+x_{10}+x_{11}\\geq1\\\\\n      \\forall{i}:x_i\\in{0,1}\n\\end{cases}\\]\nВведём эти значения используя lpSolve\n\n\nSuccess: the objective function is 3 \n\n\n [1] 0 0 0 1 0 0 0 0 0 0 1 0 1\n\n\nФилиалы необходимо открыть в следующих регионах\n\n\n[1]  4 11 13\n\n\n\n\nЗадача 2\nВ данном случае введём дополнительно набор переменных \\(y\\), которые будут означать то, что передатчик в отсутствует в текущей области и граничащих с ней. Минимизация целевой функции построенной на \\(y\\), говорит о том, что надо выбрать как можно меньше областей с отсутствующей связью.\n\\[\\begin{cases}\n      \\min{F(x)=212y_1+56y_2+132y_3+347y_4+53y_5+503y_6+785y_7+408y_8+430y_9+665y_{10}+403y_{11}+668y_{12}+295y_{13}}\\\\\n      x_1+x_{10}+x_{11}+x_{13}+y_1\\geq1\\\\\n      x_2+x_9+x_{11}+y_2\\geq1\\\\\n      x_3+x_8+x_9+x_{13}+y_3\\geq1\\\\\n      x_4+x_5+x_6+x_{12}+y_4\\geq1\\\\\n      x_5+x_4+x_{12}+y_5\\geq1\\\\\n      x_6+x_4+x_7+x_{12}+y_6\\geq1\\\\\n      x_7+x_6+x_8+x_{10}+x_{13}+y_7\\geq1\\\\\n      x_8+x_6+x_7+x_3+x_{13}+y_8\\geq1\\\\\n      x_9+x_2+x_3+x_{11}+x_{13}+y_9\\geq1\\\\\n      x_{10}+x_1+x_7+x_{12}+x_{13}+y_{10}\\geq1\\\\\n      x_{11}+x_1+x_2+x_9+x_{13}+y_{11}\\geq1\\\\\n      x_{12}+x_4+x_5+x_6+x_{10}+y_{12}\\geq1\\\\\n      x_{13}+x_1+x_3+x_7+x_8+x_9+x_{10}+x_{11}+y_{13}\\geq1\\\\\n      x_1+x_2+x_3+x_4+x_5+x_6+x_7+x_8+x_9+x_{10}+x_{11}+x_{12}+x_{13}=1\\\\\n      \\forall{i}:x_i,y_i\\in \\{0,1\\}\n\\end{cases}\\]\nОсобенность задачи в том, что ограничения по x и y будут заданы раздельно\nКонструируем и решаем задачу используя lpSolve\n\n\nSuccess: the objective function is 1627 \n\n\nВывод: если можно открыть только один филиал, то его надо открыть в регионе:\n\n\n[1] 13\n\n\n\n\n [1] 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 1 1 1 0 0 0 0 0 1 0",
    "crumbs": [
      "Линейное программирование",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Целочисленное программирование</span>"
    ]
  },
  {
    "objectID": "nonlinear/overview.html",
    "href": "nonlinear/overview.html",
    "title": "Нелинейное программирование",
    "section": "",
    "text": "Для любой конкретной задачи оптимизации рекомендуется сравнить несколько доступных алгоритмов, применимых к этой задаче — в общем, часто обнаруживается, что «лучший» алгоритм сильно зависит от решаемой задачи.\nОднако сравнение алгоритмов требует некоторой осторожности, поскольку не все тесты на толерантность к значению функции/параметру реализуются одинаково для разных алгоритмов. Так, например, один и тот же дробный допуск 10−4 на значение функции может дать гораздо более точный минимум в одном алгоритме по сравнению с другим, и их сопоставление может потребовать некоторых экспериментов с допусками.\nВместо этого более справедливый и надежный способ сравнить два разных алгоритма — запустить один до тех пор, пока значение функции не сойдется к некоторому значению fA, а затем запустить второй алгоритм с тестом завершения minf_max, установленным на minf_max=fA. То есть спросите, сколько времени потребуется двум алгоритмам, чтобы достичь одного и того же значения функции.\nА еще лучше, запустите какой-нибудь алгоритм в течение очень долгого времени, пока минимальная fM не будет найдена с высокой точностью. Затем запустите различные алгоритмы, которые вы хотите сравнить с тестом завершения: minf_max=fM+Δf. То есть спросите, сколько времени требуется различным алгоритмам, чтобы получить минимум Δf с точностью до абсолютного допуска для некоторого Δf. (Это полностью отличается от использования теста завершения ftol_abs, поскольку последний использует только приблизительную оценку ошибки в значениях функции, и, более того, эта оценка варьируется в зависимости от алгоритма.)",
    "crumbs": [
      "Нелинейное программирование"
    ]
  },
  {
    "objectID": "nonlinear/unconstrained/analytical/one/main.html",
    "href": "nonlinear/unconstrained/analytical/one/main.html",
    "title": "12  Безусловная оптимизация функции одной переменной",
    "section": "",
    "text": "12.1 Определение\n[1] [2]",
    "crumbs": [
      "Нелинейное программирование",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Безусловная оптимизация функции одной переменной</span>"
    ]
  },
  {
    "objectID": "nonlinear/unconstrained/analytical/one/main.html#sec-nonlinear-unconstrained-one-def",
    "href": "nonlinear/unconstrained/analytical/one/main.html#sec-nonlinear-unconstrained-one-def",
    "title": "12  Безусловная оптимизация функции одной переменной",
    "section": "",
    "text": "Определение 12.1  \n\nТочкой локального максимума\n\nфункции \\(f(x)\\) называется точка \\(x_0\\), если существует такая окрестность этой точки, что для всех \\(x\\) из этой окрестности выполняется неравенство: \\(f(x) &lt; f\\left(x_{0}\\right)\\).\n\n\n\n\nОпределение 12.2  \n\nТочкой локального минимума\n\nфункции \\(f(x)\\) называется точка \\(x_0\\) , если существует такая окрестность этой точки, что для всех \\(x\\) из этой окрестности выполняется неравенство: \\(f(x) &gt; f\\left(x_{0}\\right)\\).",
    "crumbs": [
      "Нелинейное программирование",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Безусловная оптимизация функции одной переменной</span>"
    ]
  },
  {
    "objectID": "nonlinear/unconstrained/analytical/one/main.html#sec-nonlinear-unconstrained-one-criteria",
    "href": "nonlinear/unconstrained/analytical/one/main.html#sec-nonlinear-unconstrained-one-criteria",
    "title": "12  Безусловная оптимизация функции одной переменной",
    "section": "12.2 Критерий",
    "text": "12.2 Критерий\n\nТеорема 12.1 (Необходимое условие) Если функция \\(y=f(x)\\) имеет экстремум в точке \\(x_{0}\\), то ее производная \\(f^{\\prime}\\left(x_{0}\\right)\\) либо равна нулю, либо не существует.\nТочки, в которых производная равна нулю: \\(f^{\\prime}(x)=0\\), называются стационарными точками функции.\nТочки, в которых выполняется необходимое условие экстремума для непрерывной функции, называются критическими точками этой функции. То есть критические точки - это либо стационарные точки (решения уравнения \\(f^{\\prime}(x)=0\\)), либо это точки, в которых производная \\(f^{\\prime}(x)\\) не существует.\n\n\n\n\n\n\nУведомление\n\n\n\nНе в каждой своей критической точке функция обязательно имеет максимум или минимум.\n\n\n\n\nТеорема 12.2 (Первое достаточное условие) Пусть для функции \\(y=f(x)\\) выполнены следующие условия:\n\nфункция непрерывна в окрестности точки \\(x_{0}\\)\n\\(f^{\\prime}\\left(x_{0}\\right)=0\\) или \\(f^{\\prime}\\left(x_{0}\\right)\\) не существует\nпроизводная \\(f^{\\prime}(x)\\) при переходе через точку \\(x_{0}\\) меняет свой знак.\n\nТогда в точке \\(x=x_{0}\\) функция \\(y=f(x)\\) имеет экстремум, причем это\n\nминимум, если при переходе через точку \\(x_{0}\\) производная меняет свой знак с минуса на плюс;\nмаксимум, если при переходе через точку \\(x_{0}\\) производная меняет свой знак с плюса на минус.\n\n\n\nПример 12.1 Исследовать функцию \\(y(x)=x^{4}-1\\) на экстремум.\n\n\nРешение 12.1. Находим производную заданной функции:\n\\[y^{\\prime}=\\left(x^{4}-1\\right)^{\\prime}=4 x^{3}\\]\nДалее ищем критические точки функции, для этого решаем уравнение \\(y^{\\prime}(x)=0\\):\n\\[y^{\\prime}=4 x^{3}=0 \\Rightarrow x=0\\]\n\n\n\n\n\n\nПервая производная определена во всех точках. Таким образом, имеем одну критическую точку \\(x=0\\). Наносим эту точку на координатную прямую и исследуем знак производной слева и справа от этой точки (для этого из каждого промежутка берем произвольное значение и находим значение производной в выбранной точке, определяем знак полученной величины):\nТак как при переходе через точку \\(x=0\\) производная сменила свой знак с \\(-\\) на \\(+\\), то в этой точке функция достигает минимума (или минимального значения), причем \\(y_{\\min }=y(0)=0^{4}-1=-1\\).\nЗамечание. Также можно определить интервалы монотонности функции: так как на интервале \\((-\\infty ; 0)\\) производная \\(y^{\\prime}(x) &lt; 0\\), то на этом интервале функция \\(y(x)=x^{4}-1\\) является убывающей; на интервале \\((0 ;+\\infty)\\) производная \\(y^{\\prime}(x)&gt;0\\), значит заданная функция возрастает на нем.\nОтвет: \\(y_{\\min }=y(0)=-1\\)\n\n\nТеорема 12.3 (Второе достаточное условие) Пусть для функции \\(y=f(x)\\) выполнены следующие условия:\n\nона непрерывна в окрестности точки \\(x_{0}\\)\nпервая производная \\(f^{\\prime}(x)=0\\) в точке \\(x_{0}\\)\n\\(f^{\\prime \\prime}(x) \\neq 0\\) в точке \\(x_{0}\\).\n\nТогда в точке \\(x_{0}\\) достигается экстремум, причем\n\nесли \\(f^{\\prime \\prime}\\left(x_{0}\\right)&gt;0\\), то в точке \\(x=x_{0}\\) функция \\(y=f(x)\\) имеет минимум;\nесли \\(f^{\\prime \\prime}\\left(x_{0}\\right) &lt; 0\\), то в точке \\(x=x_{0}\\) функция \\(y=f(x)\\) достигает максимум.\n\n\n\nПример 12.2 Исследовать функцию \\(y(x)=\\frac{x^{2}-1}{x^{2}+1}\\) на экстремум с помощью второй производной.\n\n\nРешение 12.2. Находим первую производную заданной функции:\n\\[y^{\\prime}(x)=\\left(\\frac{x^{2}-1}{x^{2}+1}\\right)^{\\prime}=\\frac{2 x\\left(x^{2}+1\\right)-\\left(x^{2}-1\\right) \\cdot 2 x}{\\left(x^{2}+1\\right)^{2}}=\\frac{4 x}{\\left(x^{2}+1\\right)^{2}}\\]\nНаходим точки, в которых первая производная равна нулю:\n\\[y^{\\prime}(x)=0 \\Rightarrow \\frac{4 x}{\\left(x^{2}+1\\right)^{2}}=0 \\Rightarrow x=0\\]\nВторая производная заданной функции:\n\\[y^{\\prime \\prime}(x)=\\left(\\frac{4 x}{\\left(x^{2}+1\\right)^{2}}\\right)^{\\prime}=\\frac{4\\left(x^{2}+1\\right)^{2}-4 x \\cdot 2\\left(x^{2}+1\\right) \\cdot 2 x}{\\left(x^{2}+1\\right)^{4}}=\\]\n\\[=-\\frac{4\\left(3 x^{2}-1\\right)}{\\left(x^{2}+1\\right)^{3}}\\]\n\n\n\n\n\n\nВ стационарной точке \\(x=0\\) вторая производная \\[y^{\\prime \\prime}(0)=-\\frac{4 \\cdot(-1)}{1^{3}}=4&gt;0\\]\nзначит, в этой точке функция достигает минимум, причем\n\\[y_{\\min }=y(0)=\\frac{0^{2}-1}{0^{2}+1}=-1\\]\nОтвет \\(y_{\\min }=y(0)=-1\\)",
    "crumbs": [
      "Нелинейное программирование",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Безусловная оптимизация функции одной переменной</span>"
    ]
  },
  {
    "objectID": "nonlinear/unconstrained/analytical/one/main.html#sec-nonlinear-unconstrained-one-derivatives",
    "href": "nonlinear/unconstrained/analytical/one/main.html#sec-nonlinear-unconstrained-one-derivatives",
    "title": "12  Безусловная оптимизация функции одной переменной",
    "section": "12.3 Таблица производных",
    "text": "12.3 Таблица производных\n\n\n\nТаблица 12.1: Таблица производных\n\n\n\n\n\n\\(F(x)\\)\n\\(F'(x)=\\frac{dF}{dx}\\)\n\n\n\n\n\\(a f(x)+b g(x)\\)\n\\(a f'(x)+b g'(x)\\)\n\n\n\\(f(x)+g(x)\\)\n\\(f'(x)+g'(x)\\)\n\n\n\\(f(x)-g(x)\\)\n\\(f'(x)-g'(x)\\)\n\n\n\\(a f(x)\\)\n\\(a f'(x)\\)\n\n\n\\(f(x) g(x)\\)\n\\(f'(x) g(x) + f(x) g'(x)\\)\n\n\n\\(f(x) g(x) h(x)\\)\n\\(f'(x)g(x)h(x)+ f(x)g'(x)h(x) + f(x)g(x)h'(x)\\)\n\n\n\\(f(g(x))\\)\n\\(f'(g(x)) g'(x)\\)\n\n\n\\(a,\\ const\\)\n\\(0\\)\n\n\n\\(x^a\\)\n\\(a x^{n-1}\\)\n\n\n\\(g(x)^a\\)\n\\(ag(x)^{a-1}g'(x)\\)\n\n\n\\(\\sin{x}\\)\n\\(\\cos{x}\\)\n\n\n\\(\\sin{g(x)}\\)\n\\(g'(x) \\cos{g(x)}\\)\n\n\n\\(\\cos{x}\\)\n\\(-\\sin{x}\\)\n\n\n\\(\\tan{x}\\)\n\\(\\frac{1}{\\cos^2{x}}\\)\n\n\n\\(e^x\\)\n\\(e^x\\)\n\n\n\\(e^{g(x)}\\)\n\\(g'(x) e^{g(x)}\\)\n\n\n\\(a^x\\)\n\\(a^x \\ln{a}\\)\n\n\n\\(\\ln{x}\\)\n\\(\\frac{1}{x}\\)\n\n\n\\(\\ln{g(x)}\\)\n\\(\\frac{g'(x)}{g(x)}\\)\n\n\n\\(\\log_a{x}\\)\n\\(\\frac{1}{x \\ln{a}}\\)\n\n\n\\(\\arcsin{x}\\)\n\\(\\frac{1}{\\sqrt{1-x^2}}\\)\n\n\n\\(\\arcsin{g(x)}\\)\n\\(\\frac{g'(x)}{\\sqrt{1-g(x)^2}}\\)\n\n\n\\(\\arccos{x}\\)\n\\(-\\frac{1}{\\sqrt{1-x^2}}\\)\n\n\n\\(\\arctan{x}\\)\n\\(\\frac{1}{1+x^2}\\)\n\n\n\\(\\arctan{g(x)}\\)\n\\(\\frac{g'(x)}{1+g(x)^2}\\)\n\n\n\n\n\n\n\n\n\n\n1. Емелин А. Возрастание, убывание и экстремумы функции [Электронный ресурс]. URL: http://mathprofi.ru/vozrastanie_ubyvanie_ekstremumy_funkcii.html (дата обращения: 20.02.2025).\n\n\n2. Понятие экстремума функции [Электронный ресурс]. URL: https://www.webmath.ru/poleznoe/formules_8_22.php (дата обращения: 20.02.2025).",
    "crumbs": [
      "Нелинейное программирование",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Безусловная оптимизация функции одной переменной</span>"
    ]
  },
  {
    "objectID": "nonlinear/unconstrained/analytical/many/main.html",
    "href": "nonlinear/unconstrained/analytical/many/main.html",
    "title": "13  Безусловная оптимизация функции многих переменных",
    "section": "",
    "text": "13.1 Определение\n[1]\nНапример для функции \\(f(x,y)=(x-1)^2 +(y+2)^2\\) точка \\(M(x_0=1,y_0=-2)\\) будет точкой локального минимума",
    "crumbs": [
      "Нелинейное программирование",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Безусловная оптимизация функции многих переменных</span>"
    ]
  },
  {
    "objectID": "nonlinear/unconstrained/analytical/many/main.html#sec-nonlinear-unconstrained-many-defenition",
    "href": "nonlinear/unconstrained/analytical/many/main.html#sec-nonlinear-unconstrained-many-defenition",
    "title": "13  Безусловная оптимизация функции многих переменных",
    "section": "",
    "text": "Определение 13.1  \n\nТочкой локального максимума\n\nназывается такая точка \\(M_0(x_0,y_0,...)\\), что в некоторой \\(\\delta\\)-окрестности этой точки выполняется неравенство \\(f(x,y,...) &lt; f(x_0,y_0,...)\\).\n\n\n\n\nОпределение 13.2  \n\nТочкой локального минимума\n\nназывается такая точка \\(M_0(x_0,y_0,...)\\), что в некоторой \\(\\delta\\)-окрестности этой точки выполняется неравенство \\(f(x,y,...) &gt; f(x_0,y_0,...)\\).",
    "crumbs": [
      "Нелинейное программирование",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Безусловная оптимизация функции многих переменных</span>"
    ]
  },
  {
    "objectID": "nonlinear/unconstrained/analytical/many/main.html#sec-nonlinear-unconstrained-many-2vars",
    "href": "nonlinear/unconstrained/analytical/many/main.html#sec-nonlinear-unconstrained-many-2vars",
    "title": "13  Безусловная оптимизация функции многих переменных",
    "section": "13.2 Экстремум функции двух переменных",
    "text": "13.2 Экстремум функции двух переменных\n\nТеорема 13.1 (Необходимое условие) Если дифференцируемая функция имеет экстремум в точке , то обе частные производные 1-го порядка в данной точке равны нулю:\n\\[\n\\frac{\\partial F(x,y)}{\\partial x}=0 \\qquad\n\\frac{\\partial F(x,y)}{\\partial y}=0\n\\]\n\n\nОпределение 13.3  \n\nСтационарной точкой\n\nназывается точка. удовлетворяющая этим условиям. Также эту точку называют критической.\n\n\n\nНо у функции с производными , равными нулю в этой же точке, не наблюдается ничего подобного. Это гиперболический параболоид или «седло» Для точки не существует окрестности, в которой поверхность располагалась бы только вверху или только внизу .\n\n\n\n\n\n\n\nОпределение 13.4  \n\nСледовой точкой\n\nназывается точку такого рода.\n\n\n\n\nПример 13.1 Исследовать на экстремум функцию\n\\[z=3x^2 + xy + 2y^2 -x -4y\\]\n\n\nРешение 13.1. на первом шаге нужно отыскать стационарные точки. Для этого найдем частные производные 1-го порядка:\n\\[\n\\begin{aligned}\n&\\frac{\\partial z}{\\partial x}=\\frac{\\partial}{\\partial x}\\bigl(3x^2+xy+2y^2-x-4y \\bigr)=6x+y-1 \\\\\n&\\frac{\\partial z}{\\partial x}=\\frac{\\partial}{\\partial x}\\bigl(3x^2+xy+2y^2-x-4y \\bigr)=x+4y-4\n\\end{aligned}\n\\]\nРешим систему уравнений\n\\[\n\\begin{cases}\n\\frac{\\partial z}{\\partial x}=0\\\\\n\\frac{\\partial z}{\\partial y}=0\n\\end{cases}\\,\n\\Rightarrow\n\\begin{cases}\n6x+y-1=0\\\\\nx+4y-1=0\n\\end{cases}\\,\n\\]\n\n\n\n\n\n\nТаким образом\n\\[\n\\begin{aligned}\ny=1\\\\\nx=0\n\\end{aligned}\n\\]\nНайдена стационарная точка \\(M_0(0,1)\\). В найденной точке может быть минимум, максимум либо перевал.\n\n\nТеорема 13.2 (Достаточное условие) Для применения достаточного условия нужно вычислить частные производные 2-го порядка в точке Для компактности обычно используют следующие обозначения\n\\[\n\\begin{aligned}\n&A=\\frac{\\partial^2 z}{\\partial x^2}\\\\\n&B=\\frac{\\partial^2 z}{\\partial x \\partial y}\\\\\n&C=\\frac{\\partial^2 z}{\\partial x^2}\\\\\n\\end{aligned}\n\\]\n\nЕсли \\(AC-B^2&gt;0\\), то функция \\(z=f(x,y)\\) имеет экстремум в точке \\(M_0\\), причём, если \\(A&gt;0\\), то это минимум, а если \\(A&lt;0\\) – то максимум.\nЕсли \\(AC-B^2&lt;0\\), то в точке \\(M_0\\) нет экстремума.\nЕсли \\(AC-B^2=0\\), то требуется дополнительное исследование.\n\n\n\nПример 13.2 Определить тип стационарной точки \\(M_0(0,1)\\) для функции \\[z=3x^2 + xy + 2y^2 -x -4y\\]\n\n\nРешение 13.2. Найдем все вторые частные производные.\n\\[\n\\begin{aligned}\n&\\frac{\\partial^2 z}{\\partial x^2}=\\frac{\\partial z}{\\partial x} \\bigl(6x+y-1\\bigr)=A=6\\\\\n&\\frac{\\partial^2 z}{\\partial x \\partial y}=\\frac{\\partial z}{\\partial y} \\bigl(6x+y-1\\bigr)=B=1\\\\\n&\\frac{\\partial^2 z}{\\partial y^2}=\\frac{\\partial z}{\\partial x} \\bigl(x+4y-4\\bigr)=C=4\n\\end{aligned}\n\\]\nТаким образом \\(AC-B^2=6\\cdot 4-1^2=23&gt;0\\), следовательно в точке \\(M_0\\) есть экстремум, и так как \\(A&gt;0\\), то это минимум. Ответ \\(\\min{z}=z(0,1)=-2\\).",
    "crumbs": [
      "Нелинейное программирование",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Безусловная оптимизация функции многих переменных</span>"
    ]
  },
  {
    "objectID": "nonlinear/unconstrained/analytical/many/main.html#sec-nonlinear-unconstrained-many-3vars",
    "href": "nonlinear/unconstrained/analytical/many/main.html#sec-nonlinear-unconstrained-many-3vars",
    "title": "13  Безусловная оптимизация функции многих переменных",
    "section": "13.3 Экстремумы трёх переменных",
    "text": "13.3 Экстремумы трёх переменных\n\nТеорема 13.3 (Необходимое условие) Как и для функции двух переменных общий вид необходимых условий сохраняется.\n\\[\n\\frac{\\partial F(x,y,z)}{\\partial x}=0 \\qquad\n\\frac{\\partial F(x,y,z)}{\\partial y}=0 \\qquad\n\\frac{\\partial F(x,y,z)}{\\partial z}=0\n\\]\n\n\nПример 13.3 Найти стационарные точки функции\n\\[\nu=-x^2-5y^2-3z^2+xy-2xz+2yz+11x+2y+18z+10\n\\]\n\nГрафик сечений\n\n\n\n\n\n\n\n\nРешение 13.3. Найдем все первые частные производные\n\\[\n\\begin{aligned}\n&\\frac{\\partial u}{\\partial x}=-2x+y-2z+11\\\\\n&\\frac{\\partial u}{\\partial y}=-10y+x+2z+2\\\\\n&\\frac{\\partial u}{\\partial z}=-6z-2x+2y+18\n\\end{aligned}\n\\]\nЧтобы найти стационарные точки, составим и решим следующую систему\n\\[\n\\begin{cases}\n\\frac{\\partial u}{\\partial x}=0\\\\\n\\frac{\\partial u}{\\partial y}=0\\\\\n\\frac{\\partial u}{\\partial z}=0\\\\\n\\end{cases}\\,\n\\Rightarrow\n\\begin{cases}\n-2x+y-2z+11=0\\\\\n-10y+x+2z+2=0\\\\\n-6z-2x+2y+18=0\n\\end{cases}\\,\n\\]\nТаким образом\n\\[\n\\begin{aligned}\n&x=4\\\\\n&y=1\\\\\n&z=2\n\\end{aligned}\n\\]\nНайдена единственная стационарная точка \\(M_0(4,1,2)\\)\n\n\nТеорема 13.4 (Достаточное условие) Для проверки достаточное условия требуется построить матрицу Гессе, состоящую из всех частных производных второго порядка\n\\[\nH =\n\\begin{pmatrix}\n\\frac{\\partial^2 u(M_0)}{\\partial x^2} & \\frac{\\partial^2 u(M_0)}{\\partial x \\partial y} & \\frac{\\partial^2 u(M_0)}{\\partial x \\partial z} \\\\\n\\frac{\\partial^2 u(M_0)}{\\partial y \\partial x} & \\frac{\\partial^2 u(M_0)}{\\partial y^2}  & \\frac{\\partial^2 u(M_0)}{\\partial y \\partial z} \\\\\n\\frac{\\partial^2 u(M_0)}{\\partial z \\partial x} &  \\frac{\\partial^2 u(M_0)}{\\partial y \\partial z} & \\frac{\\partial^2 u(M_0)}{\\partial z^2}\n\\end{pmatrix}\n\\]\nДанная матрица является симметричной (или симметрической). Это значит, что её элементы симметричны относительно главной диагонали, на которой в данном случае расположены «однобуквенные» частные производные\nДалее нужно вычислить угловые миноры. Это определители, которые «разрастаются» из левого верхнего угла:\n\\[\n\\delta_1=\\frac{\\partial^2 u(M_0)}{\\partial x^2}, \\qquad\n\\delta_2=\n\\begin{vmatrix}\n\\frac{\\partial^2 u(M_0)}{\\partial x^2} & \\frac{\\partial^2 u(M_0)}{\\partial x \\partial y} \\\\\n\\frac{\\partial^2 u(M_0)}{\\partial y \\partial x} & \\frac{\\partial^2 u(M_0)}{\\partial y^2}\n\\end{vmatrix}, \\qquad\n\\delta_3=\n\\begin{vmatrix}\n\\frac{\\partial^2 u(M_0)}{\\partial x^2} & \\frac{\\partial^2 u(M_0)}{\\partial x \\partial y} & \\frac{\\partial^2 u(M_0)}{\\partial x \\partial z} \\\\\n\\frac{\\partial^2 u(M_0)}{\\partial y \\partial x} & \\frac{\\partial^2 u(M_0)}{\\partial y^2}  & \\frac{\\partial^2 u(M_0)}{\\partial y \\partial z} \\\\\n\\frac{\\partial^2 u(M_0)}{\\partial z \\partial x} &  \\frac{\\partial^2 u(M_0)}{\\partial y \\partial z} & \\frac{\\partial^2 u(M_0)}{\\partial z^2}\n\\end{vmatrix}\n\\] 1. Если \\(\\delta_1&gt;0,\\quad \\delta_2&gt;0,\\quad \\delta_3&gt;0\\), то функция \\(u=f(x,y,z)\\) достигает минимума в точке \\(M_0\\) 2. Если \\(\\delta_1&lt;0,\\quad \\delta_2&gt;0,\\quad \\delta_3&lt;0\\) (так и только так!), то функция \\(u=f(x,y,z)\\) достигает максимума в точке \\(M_0\\). 3. Если получилось что-то другое и при этом \\(\\delta_3=|H|\\neq0\\), то \\(M_0\\) – следовая точка. Здесь это уже во многом условное название. 4. Если \\(\\delta_3=|H|=0\\), то признак не даёт ответа о характере точки \\(M_0\\).\n\n\nПример 13.4 Определить тип стационарной точки \\(M_0(4,1,2)\\) для функции\n\\[\nu=-x^2-5y^2-3z^2+xy-2xz+2yz+11x+2y+18z+10\n\\]\n\n\nРешение 13.4. В нашем примере все производные 2-го порядка равны константам\n\\[\n\\begin{aligned}\n&\\frac{\\partial^2 u}{\\partial x^2}=-2\\\\\n&\\frac{\\partial^2 u}{\\partial y^2}=-10\\\\\n&\\frac{\\partial^2 u}{\\partial z^2}=-6\\\\\n&\\frac{\\partial^2 u}{\\partial x \\partial y}=1\\\\\n&\\frac{\\partial^2 u}{\\partial x \\partial z}=-2\\\\\n&\\frac{\\partial^2 u}{\\partial y \\partial z}=2\\\\\n\\end{aligned}\n\\]\nСоставим матрицу Гессе\n\\[\nH=\n\\begin{pmatrix}\n-2 & 1 & -2\\\\\n1 & -10 & 2\\\\\n-2 & 2 & -6\n\\end{pmatrix}\n\\]\nи вычислим её угловые миноры\n\\[\n\\begin{aligned}\n&\\delta_1=2&lt;0\\\\\n&\\delta_2=\n\\begin{vmatrix}\n-2 & 1\\\\\n1 & -10\n\\end{vmatrix}=19&gt;0\\\\\n&\\delta_3=\n\\begin{vmatrix}\n-2 & 1 & -2\\\\\n1 & -10 & 2\\\\\n-2 & 2 & -6\n\\end{vmatrix}=-74&lt;0\n\\end{aligned}\n\\]\nВывод: функция достигает максимума в точке \\(M_0(4,1,2)\\)\n\\(\\max{u}=u(4,1,2)=51\\)",
    "crumbs": [
      "Нелинейное программирование",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Безусловная оптимизация функции многих переменных</span>"
    ]
  },
  {
    "objectID": "nonlinear/unconstrained/analytical/many/main.html#sec-nonlinear-unconstrained-many-4vars",
    "href": "nonlinear/unconstrained/analytical/many/main.html#sec-nonlinear-unconstrained-many-4vars",
    "title": "13  Безусловная оптимизация функции многих переменных",
    "section": "13.4 Экстремум функции четырех переменных",
    "text": "13.4 Экстремум функции четырех переменных\nРассмотренный алгоритм исследования распространяется и на функции большего количества переменных Разберём ещё случай функции 4 переменных, а дальше – будет понятно. Чтобы исследовать на экстремум дифференцируемую функцию четырёх аргументов, нужно найти частные производные 1-го порядка и решить систему:\n\\[\n\\begin{cases}\n\\frac{\\partial u}{\\partial x}=0\\\\\n\\frac{\\partial u}{\\partial y}=0\\\\\n\\frac{\\partial u}{\\partial z}=0\\\\\n\\frac{\\partial u}{\\partial v}=0\\\\\n\\end{cases}\n\\]\nПредположим, что в результате решения найдена стационарная точка \\(M_0(x_0,y_0,z_0,v_0\\). Далее нужно найти частные производные 2-го порядка, вычислить их в точке \\(M_0\\) и составить матрицу Гессе:\n\\[\nH_4=\n\\begin{pmatrix}\n\\frac{\\partial^2 u(M_0)}{\\partial x^2} & \\frac{\\partial^2 u(M_0)}{\\partial x \\partial y} & \\frac{\\partial^2 u(M_0)}{\\partial x \\partial z}  & \\frac{\\partial^2 u(M_0)}{\\partial x \\partial v}\\\\\n\\frac{\\partial^2 u(M_0)}{\\partial y \\partial x} & \\frac{\\partial^2 u(M_0)}{\\partial y^2}  & \\frac{\\partial^2 u(M_0)}{\\partial y \\partial z} & \\frac{\\partial^2 u(M_0)}{\\partial y \\partial v} \\\\\n\\frac{\\partial^2 u(M_0)}{\\partial x \\partial z} &  \\frac{\\partial^2 u(M_0)}{\\partial z \\partial y} & \\frac{\\partial^2 u(M_0)}{\\partial z^2} & \\frac{\\partial^2 u(M_0)}{\\partial z \\partial v} \\\\\n\\frac{\\partial^2 u(M_0)}{\\partial v \\partial x} &  \\frac{\\partial^2 u(M_0)}{\\partial v \\partial y} & \\frac{\\partial^2 u(M_0)}{\\partial v \\partial z} & \\frac{\\partial^2 u(M_0)}{\\partial v^2} \\\\\n\\end{pmatrix}\n\\] после чего вычислить её угловые миноры \\(\\delta_1,\\delta_2,\\delta_3,\\delta_4\\).\nЕсли все миноры положительны, то в точке \\(M_0\\) – минимум, если знакочередуются в следующем порядке: \\(\\delta_1&lt;0,\\quad \\delta_2&gt;0,\\quad \\delta_3&lt;0, \\quad \\delta_4&gt;0\\) (и именно в таком!), то в точке \\(M_0\\) – максимум. Если имеет место другой случай, но \\(\\delta_4=|H_4|\\neq0\\) , то \\(M_0\\) – седловая точка; если же \\(\\delta_4=|H_4|=0\\), то признак не даёт ответа о характере точки \\(M_0\\). Этот алгоритм известен как проверка квадратичной формы полного дифференциала 2-го порядка на знакоопределённость методом Сильвестра (для функций 2, 3, 4 и большего количества переменных).\n\n\n\n\n1. Емелин А. Экстремумы функций двух и трёх переменных [Электронный ресурс]. URL: http://mathprofi.ru/extremumy_funkcij_dvuh_i_treh_peremennyh.html (дата обращения: 20.02.2025).",
    "crumbs": [
      "Нелинейное программирование",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Безусловная оптимизация функции многих переменных</span>"
    ]
  },
  {
    "objectID": "nonlinear/constrained/analytical/main.html",
    "href": "nonlinear/constrained/analytical/main.html",
    "title": "14  Условная оптимизация функции многих переменных",
    "section": "",
    "text": "14.1 Прямоугольные ограничения неравенства\n\\[\n\\begin{cases}\n\\min{F(\\vec{x})}=x_1^2+x_2^2+x_1x_2+2x_1+4x_2+5\\\\\n-4 \\leq x_1 \\leq 4 \\\\\n2 \\leq x_2 \\leq 3\n\\end{cases}\n\\]\nПреобразуем ограничения\n\\[\n\\begin{cases}\ng_1:x_1 + 4 \\geq 0\\\\\ng_2:4 - x_1 \\geq 0\\\\\ng_3:x_2 - 2 \\geq 0\\\\\ng_4:3 - x_2 \\geq 0\n\\end{cases}\n\\]\nЗапишем функцию лагранжа нашей системы\n\\[\n\\begin{cases}\nL(\\vec{x},\\vec{\\mu}) = F(x) - \\sum_{i=1}^4{\\mu_i g_i} \\\\\nL(\\vec{x},\\vec{\\mu}) = x_1^2+x_2^2+x_1 x_2+2 x_1+4 x_2+5 - \\mu_1(x_1+4) - \\mu_2(4-x_1) - \\mu_3(x_2-2) - \\mu_4 (3-x_2)\\\\\n\\frac{\\partial L(\\vec{x},\\vec{\\mu})}{\\partial x_1}=2x_1 + x_2 + 2 - \\mu_1 + \\mu_2 = 0\\\\\n\\frac{\\partial L(\\vec{x},\\vec{\\mu})}{\\partial x_2}=2x_2 + x_1 + 4 - \\mu_3 + \\mu_4 = 0\\\\\ng_1:\\mu_1(x_1+4)=0\\\\\ng_2:\\mu_2(4-x_1)=0\\\\\ng_3:\\mu_3(3-x_2)=0\\\\\ng_4:\\mu_4(3-x_2)=0\\\\\n\\mu_1,\\mu_2,\\mu_3,\\mu_4\\geq0\n\\end{cases}\n\\]\nНеобходимо найти решение этой системы. Подход заключается в следующем: будем рассматривать для каждого \\(\\mu_i&gt;0\\) и \\(\\mu_i=0\\) . Предположим, что \\(\\mu_1&gt;0\\), следовательно из уравнения для \\(g_1 \\implies x_1=-4, \\mu_2=0\\). Запишем полученную систему\n\\[\n\\begin{cases}\nx_2-6-\\mu_1=0\\\\\n2x_2-\\mu_3+\\mu_4=0\\\\\n\\mu_3(x_2-2)=0\\\\\n\\mu_4(3-x_2)=0\\\\\n\\mu_1,\\mu_3,\\mu_4\\geq0\n\\end{cases}\n\\]\nДалее опять предположим, что \\(\\mu_3&gt;0\\). Из этого следует, что \\(x_2=2\\) и \\(\\mu_1=-4\\), что является противоречием. Рассмотрим случай, когда \\(\\mu_3=0\\). Предположим, что \\(\\mu_4&gt;0\\). Из этого следует, что \\(x_2=3\\) и \\(\\mu_1=-3\\), что является противоречием. Далее проверим \\(\\mu_4=0\\), получаем \\(x_2=0\\) и \\(\\mu_1=-6\\), что опять приводит к противоречию. Следовательно \\(\\mu_3=0\\).\nТаким образом перебрав все ‘ветви’ системы приходим к решению:\n\\[\n\\begin{cases}\nx_1 = -2\\\\\nx_2 = 2\\\\\n\\mu_1 = 0\\\\\n\\mu_2 = 0\\\\\n\\mu3 = 6\\\\\n\\mu_4 = 0\n\\end{cases}\n\\]\nПолучаем, что минимум в точке \\((-2,2,13)\\). Докажем, это это минимум. Матрица Гессе функции \\(F(x_1,x_2)\\) выглядит следующим образом\n\\[\n\\begin{bmatrix}2 & 1\\\\1 & 2\\end{bmatrix}\n\\]",
    "crumbs": [
      "Нелинейное программирование",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Условная оптимизация функции многих переменных</span>"
    ]
  },
  {
    "objectID": "nonlinear/constrained/analytical/main.html#sec-nonlinear-constrained-analytical-inequality",
    "href": "nonlinear/constrained/analytical/main.html#sec-nonlinear-constrained-analytical-inequality",
    "title": "14  Условная оптимизация функции многих переменных",
    "section": "14.2 Ограничения неравенства",
    "text": "14.2 Ограничения неравенства\nЯвляются частным случаем нелинейных, большинство алгоритмов работает с ними, как с нелинейными.\n\\[\n\\begin{cases}\n      \\min{F(\\vec{x})}=x_1^2+x_2^2+x_1x_2+2x_1+4x_2+5\\\\\n      2 x_1 + x_2 \\geq 0\\\\\n      x_1 + 2 x_2 \\leq 1\n\\end{cases}\n\\]\n\n\n\n\n\n\nПреобразуем ограничения\n\\[\n\\begin{cases}\ng_1:(2 x_1 + x_2) \\geq 0\\\\\ng_2:(-x_1-2x_2+1) \\geq 0\n\\end{cases}\n\\]\nСформируем функцию Лагранжа\n\\[\n\\begin{cases}\nL(\\vec{x},\\vec{\\mu})=x_1^2+x_2^2+x_1x_2+2x_1+4x_2+5-\\mu_1(2x_1+x_2)-\\mu_2(-x_1-2x_2+1)\\\\\n\\frac{\\partial L(\\vec{x},\\vec{\\mu})}{\\partial x_1}=2x_1 + x_2 + 2 - 2\\mu_1 + \\mu_2 = 0\\\\\n\\frac{\\partial L(\\vec{x},\\vec{\\mu})}{\\partial x_2}=2x_2 + x_1 + 4 - \\mu_1 + 2\\mu_2 = 0\\\\\ng_1:\\mu_1(2x_1+x_2)=0\\\\\ng_2:\\mu_2(-x_1-2x_2+1)=0\\\\\n\\mu_1,\\mu_2 \\geq 0\n\\end{cases}\n\\]\nДопустим, что \\(\\mu_1&gt;0\\), тогда \\((2x_1+x_2)=0\\), \\(x_2=-2x_1\\), откуда система:\n\\[\n\\begin{cases}\n2-2\\mu_1+\\mu_2=0\\\\\n4-3x_1-\\mu_1+2\\mu_2=0\\\\\n\\mu_2(3x_1+1)=0\\\\\n\\mu_1,\\mu_2&gt;0\n\\end{cases}\n\\]\nПредположим, что \\(\\mu_2&gt;0\\), следовательно \\(x_1=-\\frac{1}{3}\\) и система преобразуется в:\n\\[\n\\begin{cases}\n2-2\\mu_1+\\mu_2=0\\\\\n7-\\mu_1+2\\mu_2=0\\\\\n\\mu_1,\\mu_2&gt;0\n\\end{cases}\n\\]\nОткуда следует, что \\(\\mu_2=-4\\), что является противоречием. Рассмотрим случай, когда \\(\\mu_2=0\\). Тогда\n\\[\n\\begin{cases}\n2-2\\mu_1=0\\\\\n4-3x_1-\\mu_1=0\\\\\n\\mu_1&gt;0\n\\end{cases}\n\\]\nЛегко получить решение:\n\\[\n\\begin{cases}\nx_1 = 1\\\\\nx_2 = -2\\\\\n\\mu_1 = 1\\\\\n\\mu_2 = 0\n\\end{cases}\n\\]",
    "crumbs": [
      "Нелинейное программирование",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Условная оптимизация функции многих переменных</span>"
    ]
  },
  {
    "objectID": "nonlinear/constrained/analytical/main.html#sec-nonlinear-constrained-analytical-equality",
    "href": "nonlinear/constrained/analytical/main.html#sec-nonlinear-constrained-analytical-equality",
    "title": "14  Условная оптимизация функции многих переменных",
    "section": "14.3 Нелинейные ограничения равенства",
    "text": "14.3 Нелинейные ограничения равенства\n\\[\n\\begin{cases}\n\\min{F(\\vec{x})}=x_1^2+x_2^2+x_1x_2+2x_1+4x_2+5\\\\\ng1:x_1^2 - x_1 x_2 = -2\n\\end{cases}\n\\]\n\n\n\n\n\n\nПереформулируем ограничения\n\\[x_1^2 - x_1 x_2 + 2 = 0\\]\nСформируем функцию Лагранжа\n\\[\n\\begin{cases}\nL(\\vec{x},\\vec{\\mu})=x_1^2+x_2^2+x_1x_2+2x_1+4x_2+5-\\mu_1(x_1^2-x_1x_2+2)\\\\\n\\frac{\\partial L(\\vec{x},\\vec{\\mu})}{\\partial x_1}=2x_1 + x_2 + 2 - \\mu_1(2x_1-x_2)= 0\\\\\n\\frac{\\partial L(\\vec{x},\\vec{\\mu})}{\\partial x_2}=2x_2 + x_1 + 4 + \\mu_1 x_1 = 0\\\\\ng_1:\\mu_1(x_1^2-x_1x_2+2)=0\\\\\n\\mu_1 \\geq 0\n\\end{cases}\n\\]\nПусть \\(\\mu_1&gt;0\\), тогда \\(x_1^2-x_1x_2+2=0\\). Рассмотрим случай, когда \\(x_1=x_2\\). Система представляется так:\n\\[\n\\begin{cases}\n2x_1+x_2+2-\\mu_1(2x_1-x_2)=0\\\\\n2x_2+x_1+4+\\mu_1x_1=0\\\\\n\\mu_1(x_1^2-x_1x_2+2)=0\\\\\n\\mu_1\\geq 0\n\\end{cases}\n\\]\nПусть \\(\\mu_1&gt;0\\), следовательно \\(x_1^2-x_1x_2+2=0\\). Выразим \\(x_2=\\frac{2+x_1^2}{x_1}\\), тогда система после подстановки и преобразования:\n\\[\n\\begin{cases}\nx_1^2(3-\\mu_1)+2x_1+\\mu_1+2=0\\\\\n(3+\\mu_1)x_1^2+4x_1+4=0\\\\\n\\end{cases}\n\\]\nВыразим из второго уравнения\n\\[\n\\mu_1=-\\frac{3x_1^2+4x_1+4}{x_1^2}\n\\]\nИ подставим в первое\n\\[\n6x_1^4+6x_1^3-8x_1-8=0\n\\]\nОтсюда подбором получается корень \\(x_1=-1\\). Общее решение:\n\\[\n\\begin{cases}\nx_1=-3\\\\\nx_2=-3\\\\\n\\mu_1=1\n\\end{cases}\n\\]",
    "crumbs": [
      "Нелинейное программирование",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Условная оптимизация функции многих переменных</span>"
    ]
  },
  {
    "objectID": "nonlinear/constrained/numerical/conversion-to-unconstrained.html",
    "href": "nonlinear/constrained/numerical/conversion-to-unconstrained.html",
    "title": "15  Сведение к задаче неограниченной оптимизации",
    "section": "",
    "text": "15.1 Штрафные функции\nhttps://en.wikipedia.org/wiki/Penalty_method\n\\[\n\\begin{aligned}\n&\\min f(\\mathbf{x})\\\\\n&c_i(\\mathbf{x}) \\le 0 \\, \\forall i \\in I\n\\end{aligned}\n\\] можно свести к задаче\n\\[\n\\begin{aligned}\n&\\min f_p(\\mathbf{x}) = f(\\mathbf{x})+p\\sum_{i\\in I}{g(c_i(\\mathbf{x}))} \\\\\n&g(c_i(\\mathbf{x})) = \\max{(0,c_i(\\mathbf{x})}^2\n\\end{aligned}\n\\]\nВ каждой итерации метода мы увеличиваем коэффициент штрафа \\(p\\) (например, в 10 раз), решаем задачу без ограничений и используем решение в качестве начального предположения для следующей итерации. Решения последовательных задач без ограничений будут асимптотически сходиться к решению исходной задачи с ограничениями.",
    "crumbs": [
      "Нелинейное программирование",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Сведение к задаче неограниченной оптимизации</span>"
    ]
  },
  {
    "objectID": "nonlinear/constrained/numerical/conversion-to-unconstrained.html#sec-nonlinear-constrained-numerical-convert-to-unconstrained-barier",
    "href": "nonlinear/constrained/numerical/conversion-to-unconstrained.html#sec-nonlinear-constrained-numerical-convert-to-unconstrained-barier",
    "title": "15  Сведение к задаче неограниченной оптимизации",
    "section": "15.2 Барьерные функции",
    "text": "15.2 Барьерные функции\nhttps://en.wikipedia.org/wiki/Barrier_function",
    "crumbs": [
      "Нелинейное программирование",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Сведение к задаче неограниченной оптимизации</span>"
    ]
  },
  {
    "objectID": "evolutionary/overview.html",
    "href": "evolutionary/overview.html",
    "title": "Эволюционная оптимизация",
    "section": "",
    "text": "Важное уведомлениеСостояние разработки\n\n\n\nВ разработке",
    "crumbs": [
      "Эволюционная оптимизация"
    ]
  },
  {
    "objectID": "evolutionary/stats.html",
    "href": "evolutionary/stats.html",
    "title": "16  Статистика анализ",
    "section": "",
    "text": "16.1 T-стратистика\n[1] c 859.\nЕсть два эволюционных (с обязательной случайностью) алгоритма \\(A\\) и \\(B\\). В результате их выполнения были получены значения целевой функции\n\\[\n\\begin{aligned}\nA:\\{f_{A,1},f_{A,1},\\dots,f_{A,n}\\}\\\\\nB:\\{f_{B,1},f_{B,1},\\dots,f_{B,n}\\}\\\\\n\\end{aligned}\n\\] Надо ответить на вопрос: объясняется ли различие этих выборок принципиальным различием в эффективности алгоритмов или различие обусловено случайными враициями.\nДвухсторонний t-test",
    "crumbs": [
      "Эволюционная оптимизация",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Статистика анализ</span>"
    ]
  },
  {
    "objectID": "evolutionary/stats.html#sec-evolutionary-stats-f-test",
    "href": "evolutionary/stats.html#sec-evolutionary-stats-f-test",
    "title": "16  Статистика анализ",
    "section": "16.2 F-статистика",
    "text": "16.2 F-статистика\nЕсли надо сравнить 3 и более алгоритмов\n\n\n\n\n1. Ден С. Алгоритмы эволюционной оптимизации Биологически обусловленные и популяционно-ориентированные подходы к компьютерному интеллекту / под ред. Логунова А.В. Москва: ДМК Пресс, 2020. С. 940.",
    "crumbs": [
      "Эволюционная оптимизация",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Статистика анализ</span>"
    ]
  },
  {
    "objectID": "lab/alghorithm/programming/r/main.html",
    "href": "lab/alghorithm/programming/r/main.html",
    "title": "17  R",
    "section": "",
    "text": "17.1 Установка",
    "crumbs": [
      "Задания. Алгоритмы",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>R</span>"
    ]
  },
  {
    "objectID": "lab/alghorithm/programming/r/main.html#установка",
    "href": "lab/alghorithm/programming/r/main.html#установка",
    "title": "17  R",
    "section": "",
    "text": "Установить R Глава 1.1\n\nУстановить RTools Глава 1.2\n\nУстановить IDE для работы: RStudio Глава 1.3 или другу IDE, которую поддерживает Quarto.\nСоздать интерактивный блокнот Quarto Глава 2.1.1 и сохранить его в отдельном каталоге (например lab1 ).\nИзучить возможности визуального редактора RStudio IDE Глава 2.1.2\n\nСкопировать код из примера Глава 3.1, вставить в редакторе Глава 2.1.3 и запустить рендер (Глава 2.2.3 или Глава 3.3).\nСкопировать в рабочий каталог файлы окружения renv и восстановить пакеты Глава A.2.3\n\nОтрендерить пример Глава 3.3 или Глава 2.2.3",
    "crumbs": [
      "Задания. Алгоритмы",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>R</span>"
    ]
  },
  {
    "objectID": "lab/alghorithm/programming/r/main.html#теория",
    "href": "lab/alghorithm/programming/r/main.html#теория",
    "title": "17  R",
    "section": "\n17.2 Теория",
    "text": "17.2 Теория\n\nИзучить язык разметки Quarto Markdown Глава 4\n\nИзучить основы языка R Глава 6",
    "crumbs": [
      "Задания. Алгоритмы",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>R</span>"
    ]
  },
  {
    "objectID": "lab/alghorithm/programming/r/main.html#задачи",
    "href": "lab/alghorithm/programming/r/main.html#задачи",
    "title": "17  R",
    "section": "\n17.3 Задачи",
    "text": "17.3 Задачи\n\nУпражнение 17.1 (Что может быть проще?) Упростите выражение (Глава 6.3.1):\nc(sqrt(1), sqrt(2), sqrt(3))\nСоздайте последовательность 2 способами (-1, -0.75, -0.5, …, 0.75, 1).\n\n\n\n\n\n\nУровень 1\n\n\n\n\n\nУпражнение 17.2 (Вершины и овраги) Построить график (Глава E.2) кусочно-гладкой функции (Глава 6.12.1) используя функцию base::ifelse()\n\\[\nf(x)=\\begin{cases}\n      x^2,\\qquad x \\leq -3\\\\\n      x^3, \\qquad -3 &lt; x &lt; 3\\\\\n      2x+1, 3\\leq x\n\\end{cases}\\,\n\\]\n\n\n\n\n\n\nУровень 1\n\n\n\n\n\nУпражнение 17.3 (По порядку) С помощью ряда Лейбница можно получить значение числа \\(\\pi\\) . Данный ряд сходится очень медленно.\n\\[\n\\pi = 4 \\sum_{i=0}^n{\\frac{(-1)^i}{2i+1}}\n\\]\nИспользовав по максимуму векторные операции (Глава 6.9) рассчитайте для различных \\(n\\) от \\(n=10\\) до \\(n=10^{8}\\)\n\nчисло \\(\\pi\\) и его ошибку\nпостройте график (Глава E.2) ошибки от \\(n\\)\n\n\n\n\n\n\n\n\nУровень 2\n\n\n\n\n\nУпражнение 17.4 (Список) Создать список (Глава 6.4) содержащий буквы от ‘a' до’z'. Продемонстрировать использование операторов индексации (Глава 6.4.1).\n\n\n\n\n\n\nУровень 1\n\n\n\n\n\nУпражнение 17.5 (Матрица) Создать список (Глава 6.4) матриц (Глава 6.5) размером 2x2 заполненных случайными целыми числами. Используя циклы (Глава 6.11) получите:\n\nсписок с элементов (2,2) каждой матрицы (Глава 6.4.1 , Глава 6.5.1).\nвектор состоящий из элементов (1,1), (1,2) этих матриц.\n\n\n\n\n\n\n\nУровень 1\n\n\n\n\n\nУпражнение 17.6 (Массив)  \n\nсоздайте пятимерный массив и заполните его целыми числами.\nпреобразуйте его как список массивов размерности 4.\nпреобразуйте его как список списков массивов размерности 3.\n\n\n\n\n\n\n\nУровень 2",
    "crumbs": [
      "Задания. Алгоритмы",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>R</span>"
    ]
  },
  {
    "objectID": "lab/alghorithm/linear/algebra/main.html",
    "href": "lab/alghorithm/linear/algebra/main.html",
    "title": "18  Линейная алгебра",
    "section": "",
    "text": "18.1 Теория",
    "crumbs": [
      "Задания. Алгоритмы",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Линейная алгебра</span>"
    ]
  },
  {
    "objectID": "lab/alghorithm/linear/algebra/main.html#теория",
    "href": "lab/alghorithm/linear/algebra/main.html#теория",
    "title": "18  Линейная алгебра",
    "section": "",
    "text": "Повторить отдельные элементы из линейной алгебры Глава 7",
    "crumbs": [
      "Задания. Алгоритмы",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Линейная алгебра</span>"
    ]
  },
  {
    "objectID": "lab/alghorithm/linear/algebra/main.html#sec-lab-alghorithm-linear-algebra-task",
    "href": "lab/alghorithm/linear/algebra/main.html#sec-lab-alghorithm-linear-algebra-task",
    "title": "18  Линейная алгебра",
    "section": "\n18.2 Задания",
    "text": "18.2 Задания\n\nУпражнение 18.1 (СЛАУ) Решить СЛАУ (Глава 7.3) \\(AX=b\\) встроенным методом. Элементы матриц сгенерировать произвольно.\n\n\nR\nPython\n\n\n\nbase::solve() ?sec-r-tools-basic-solve\n\n\nnumpy\n\n\n\n\n\n\n\n\n\nУровень 1\n\n\n\n\n\nУпражнение 18.2 (Ого, формулки!) Для произвольных матриц \\(A\\) и \\(B\\) заполненных случайными числами проверить следующие свойства:\n\n\n\\((A+B)^T=A^T+B^T\\) Глава 7.2.2.3\n\n\\((AB)^T=B^TA^T\\)\n\n\\(\\det{A}=\\det{A^T}\\) Глава 7.2.3\n\n\\(\\det{AB}=\\det{A}\\det{B}\\)\n\\(\\det{A^{-1}}=(\\det{A})^{-1}\\)\n\n\\((AB)^{-1}=B^{-1}A^{-1}\\) Глава 7.2.4\n\n\\((A-B)^{-1}=A^{-1}+A^{-1}B(A-B)^{-1}\\)\n\n\n\nR\nPython\n\n\n\nРассмотрите функции base::solve() ?sec-r-tools-basic-inverse, base::det() ?sec-r-tools-basic-det\n\n\nnumpy\n\n\n\n\n\n\n\n\n\nУровень 1\n\n\n\n\n\nУпражнение 18.3 (Всё решено) Реализовать решение системы линейных уравнений методом гаусса Глава 7.3.2.1 используя векторные операции.\n\n\n\n\n\n\nУровень 3",
    "crumbs": [
      "Задания. Алгоритмы",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Линейная алгебра</span>"
    ]
  },
  {
    "objectID": "lab/alghorithm/nonlinear/main.html",
    "href": "lab/alghorithm/nonlinear/main.html",
    "title": "19  Нелинейное программирование",
    "section": "",
    "text": "19.1 Теория\nИзучить из лекций\nИз методички",
    "crumbs": [
      "Задания. Алгоритмы",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Нелинейное программирование</span>"
    ]
  },
  {
    "objectID": "lab/alghorithm/nonlinear/main.html#теория",
    "href": "lab/alghorithm/nonlinear/main.html#теория",
    "title": "19  Нелинейное программирование",
    "section": "",
    "text": "Метод Нелдера-Мида\nМетод локальной вариации\nМетоды градиентного спуска\n\n\n\n?sec-nonlinear-unconstrained-numerical-direct\n?sec-nonlinear-unconstrained-numerical-gradient\nГлава 15\n?sec-nonlinear-constrained-numerical-one\n?sec-nonlinear-constrained-numerical-many-direct\n?sec-nonlinear-constrained-numerical-many-gradient",
    "crumbs": [
      "Задания. Алгоритмы",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Нелинейное программирование</span>"
    ]
  },
  {
    "objectID": "lab/alghorithm/nonlinear/main.html#задачи",
    "href": "lab/alghorithm/nonlinear/main.html#задачи",
    "title": "19  Нелинейное программирование",
    "section": "19.2 Задачи",
    "text": "19.2 Задачи\nИспользуя несколько методов для решения одной задачи провести сравнение их эффективности используя процедуру анализа, предложенную в Приложение I.\n\n\n\n\n\n\nСовет\n\n\n\nДля вычисления производных можно воспользоваться пакетами символьных вычислений. Например Глава D.2\n\n\n\nУпражнение 19.1 (Одномерная минимизация) \\[\n\\frac{11}{1+\\mathrm{e}^{-x}}+7 \\cos{(3x)} + x^2 - 1\n\\]\nПрименить Глава D.1\n\nНайти минимум функции\nПостроить график, отобразив на нём точки вычисления функции и точки минимума\nОбъяснить основную идею метода обратных парабол (метода Пауэлла).\n\n\n\n\n\n\n\nУровень 1\n\n\n\n\n\nУпражнение 19.2 (Неограниченная) Найти минимум функции\n\\[\n7x^2+3xy+9y^2+8\\exp{\\bigg[-\\bigg(\\frac{x^2}{3}-\\frac{(y+3)^2}{5}\\bigg)\\bigg]}+9\\exp{\\bigg[-\\bigg(\\frac{(x-1)^2}{5}+\\frac{(y-2)^2}{2}\\bigg)\\bigg]}\n\\]\n\nПрименить Глава J.1.1 и Глава J.1.2\nПрименить Глава J.2.1 и Глава J.2.2\n\n\n\n\n\n\n\nУровень 1\n\n\n\n\n\nУпражнение 19.3 (С ограничениями) Решить предыдущий пример с помощью при ограничениях. Изобразить область ограничений линиями поверх контурного графика\n\\[\n\\begin{aligned}\n\\frac{x^2}{10}+\\frac{y^2}{3}-\\frac{xy}{5} \\le 6 \\\\\n\\frac{x^2}{3}+\\frac{y^2}{104}+\\frac{xy}{5} \\le 3\n\\end{aligned}\n\\]\nПрименить Глава K.1.1 и Глава K.2.1\n\n\n\n\n\n\nУровень 1\n\n\n\n\n\nУпражнение 19.4 (Овраг) Найти минимум функции\n\\[\n(9x+8y-5)^4 + (5x+2y-1)^4\n\\]\nПрименить Глава J.1.1 и Глава J.2.2\n\n\n\n\n\n\nУровень 1\n\n\n\n\n\nУпражнение 19.5 (Много переменных) Найти минимум ряда целевых функций для \\(N=20,50,200\\). Вектор коэффициентов \\(L_i\\) и \\(b_i\\) генерировать случайным образом\n\\[F=(\\sum_{i=1}^N{L_ix_i}-b)^2\\]\nПрименить Глава J.1.1 и Глава J.2.1\n\n\n\n\n\n\nУровень 2\n\n\n\n\n\nУпражнение 19.6 (Штраф) Решить задачу Упражнение 19.3 используя штрафные функции Глава 15.1.\n\n\n\n\n\n\nУровень 3\n\n\n\n\n\nУпражнение 19.7 (Барьер) Решить задачу Упражнение 19.3 используя барьерные функции. Глава 15.2\n\n\n\n\n\n\nУровень 3\n\n\n\n\n\nУпражнение 19.8 (Итог)  \n\n\n\n\n\n\nВажное уведомление\n\n\n\nОтветить на вопросы письменно в конспекте, на листике или в отчёте.\n\n\n\nДать общую характеристику градиентных методов и методов прямого поиска.\nОбъяснить основную идею методов:\n\nНелдера-Мида\nЛокальной вариации\nСемейства градиентных спусков\nНьютона\n\nОбъяснить различие в эффективности градиентных методов и методов прямого поиска:\n\nНа функции вытянутого оврага\nНа функции высокой \\(n\\geq 10\\) размерности\n\nОбъяснить различие методов штрафных и барьерных функций.",
    "crumbs": [
      "Задания. Алгоритмы",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Нелинейное программирование</span>"
    ]
  },
  {
    "objectID": "lab/alghorithm/evolutionary/main.html",
    "href": "lab/alghorithm/evolutionary/main.html",
    "title": "20  Эволюционная оптимизация",
    "section": "",
    "text": "20.1 Теория\nИзучить из лекций\nИз методички",
    "crumbs": [
      "Задания. Алгоритмы",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Эволюционная оптимизация</span>"
    ]
  },
  {
    "objectID": "lab/alghorithm/evolutionary/main.html#sec-lab-alghorithm-evolutionary-theory",
    "href": "lab/alghorithm/evolutionary/main.html#sec-lab-alghorithm-evolutionary-theory",
    "title": "20  Эволюционная оптимизация",
    "section": "",
    "text": "Алгоритм имитации отжига\nАлгоритм роя частиц\nГенетические алгоритмы\n\n\n\nПриложение N\nПриложение O\nПриложение P",
    "crumbs": [
      "Задания. Алгоритмы",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Эволюционная оптимизация</span>"
    ]
  },
  {
    "objectID": "lab/alghorithm/evolutionary/main.html#sec-lab-alghorithm-evolutionary-task",
    "href": "lab/alghorithm/evolutionary/main.html#sec-lab-alghorithm-evolutionary-task",
    "title": "20  Эволюционная оптимизация",
    "section": "\n20.2 Задания",
    "text": "20.2 Задания\nИзучить процедуру анализа алгоритмов эволюционной оптимизации Приложение M.\n\nУпражнение 20.1 (Из ямы на дно) Переходим от методов локальной оптимизации к глобальной. Требуется найти минимум функции Экли второго порядка:\n\nИспользуя один из методов нелинейного программирования используя случайное начальное приближение.\nИспользуя один из методов эволюционного программирования перечисленных выше.\n\nСравните число вычислений функции, использованное для нахождения минимума. Постройте график целевой функции и нанесите на него путь оптимизации.\n\n\n\n\n\n\nСовет\n\n\n\nВ качестве реализации функции использовать smoof::makeAckleyFunction() . Для передачи её в библиотеку nloptr используйте Глава C.4\n\n\n\n\n\n\n\n\nУровень 1\n\n\n\n\n\nУпражнение 20.2 (Дорабатываем напильником) Исследовать функцию Растрыгина 3 порядка. Для одного алгоритма на выбор для фиксированных параметров seed-random и начальной точки изменять параметры алгоритма, для получения глобального минимума с наименьшим числом итераций. Построить таблицу со значениями параметров и количества вычислений функции для достижения глобального оптимума.\n\n\nМетод имитации отжига\nМетод роя частиц\nГенетический алгоритм\n\n\n\n\n\ntemperature Initial value for temperature.\n\nvisiting.param Parameter for visiting distribution.\n\nacceptance.param Parameter for acceptance distribution.\n\n\n\n\n\ns The swarm size.\n\nk The exponent for calculating number of informants.\n\np The average percentage of informants for each particle. A value of 1 implies that all particles are fully informed.\n\nw The exploitation constant.\n\nc.p The local exploration constant.\n\nc.g The global exploration constant.\n\nd The diameter of the search space.\n\nv.max The maximal (euclidean) length of the velocity vector.\n\n\n\n\n\npopSize The population size.\n\npcrossover The probability of crossover between pairs of chromosomes.\n\npmutation The probability of mutation in a parent chromosome. Usually mutation occurs with a small probability.\n\nelitism The number of best fitness individuals to survive at each generation.\n\n\n\n\n\n\n\n\n\n\nСовет\n\n\n\nВ качестве реализации функции использовать smoof::makeRastriginFunction().\n\n\n\n\n\n\n\n\nУровень 2\n\n\n\n\n\nУпражнение 20.3 (Неслучайная случайность) Сравнить результативность методов для фиксированного seed-random и различных начальных приближений. С помощью T-статистики Стьюдента Глава 16.1 и Глава D.3 сделать заключение о том, чем обусловлено различие выборок: принципиальным отличием в эффективности алгоритмов или случайными отклонениями. В качестве выборки использовать вектор полученных значений целевой функции. Определить факторы влияющие на решение. Изменяя факторы получить правильное решение с наименьшим числом итераций\n\n\nВариант 1\nВариант 2\nВариант 3\n\n\n\nПриложение N и Приложение O\n\n\nПриложение N и Приложение P\n\n\nПриложение P и Приложение O\n\n\n\n\n\n\n\n\n\nСовет\n\n\n\nВ качестве реализации функции использовать smoof::makeSchwefelFunction().\n\n\n\n\n\n\n\n\nУровень 3\n\n\n\n\n\nУпражнение 20.4 (Вращайте барабан!) Для функции Шафера N2 для одного алгоритма на выбор (Упражнение 20.2) сравнить 3 набора параметров. С помощью F статистики Фишера сделать вывод о статистической значимости различий эффективности алгоритмов Глава 16.2 и Глава D.4.\n\n\n\n\n\n\nСовет\n\n\n\nВ качестве реализации функции использовать smoof::makeSchafferN2Function().\n\n\n\n\n\n\n\n\nУровень 3",
    "crumbs": [
      "Задания. Алгоритмы",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Эволюционная оптимизация</span>"
    ]
  },
  {
    "objectID": "lab/model/basic/main.html",
    "href": "lab/model/basic/main.html",
    "title": "21  Введение",
    "section": "",
    "text": "21.1 Теория",
    "crumbs": [
      "Задания. Моделирование",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Введение</span>"
    ]
  },
  {
    "objectID": "lab/model/basic/main.html#теория",
    "href": "lab/model/basic/main.html#теория",
    "title": "21  Введение",
    "section": "",
    "text": "Изучить язык разметки LaTeX Глава 5\n\nПовторить теорию определения экстремумов функций Глава 12 и Глава 13\n\n\n\nПример 21.1 Чтобы попасть из пункта А (остановка автобуса) в пункт В (лодочная станция) человек должен пройти сначала по асфальтовой дороге шириной \\(S\\), а затем по песчаному пляжу шириной \\(s\\). Скорость передвижения по асфальту \\(V\\) , скорость передвижения по песку \\(v\\). Спрашивается, в каком месте нужно свернуть с асфальтовой дороги, чтобы затратить меньше времени на путь.\n\n\nРешение 21.1. Решим задачу с конкретными значениями, в виду сложности аналитического решения (сводится к уравнению 4 степени): \\(D = 100\\), \\(S = 40\\), \\(V = 5\\), \\(s = 60\\), \\(v = 3\\)\n\n\n\n\n\n\nКритерий оптимальности задается функцией \\(t(x)\\), которую надо минимизировать, изменяя варьируемый параметр \\(х\\). Остальные параметры задачи \\((v,V,D,s,S)\\) являются фиксированными. \\[t(x) = \\frac{\\sqrt{x^2+S^2}}{V} + \\frac{\\sqrt{(D-x)^2+s^2}}{v}\\] \\[\\begin{cases}\n      \\min{t(x)} - ?\\\\\n      \\frac{dt}{dx}=0\\\\\n      \\frac{d^2t}{dx^2}&gt;0\n\\end{cases}\\,\\] \\[t'(x)=\\frac{x}{V \\sqrt{S^2+x^2}}-\\frac{d-x}{v \\sqrt{(d-x)^2+s^2}}\\]\nГрафик целевой функции \\(t(x)\\)\n\n\n\n\n\n\nГрафик производной целевой функции \\(t'(x)\\)\n\n\n\n\n\n\nСледовательно оптимальное значение пути, пройденного по дороге \\(x = 65.64\\)",
    "crumbs": [
      "Задания. Моделирование",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Введение</span>"
    ]
  },
  {
    "objectID": "lab/model/basic/main.html#задания",
    "href": "lab/model/basic/main.html#задания",
    "title": "21  Введение",
    "section": "\n21.2 Задания",
    "text": "21.2 Задания\n\nУпражнение 21.1 (Вспоминая АГИЛу)  \n\nПостроить объемный и контурный графики функций \\(z = x^2 - y^2\\) и \\(z = x^2 + y^2\\).\nГрафически определить минимум.\nК какому типу относятся кривые, изображенные на контурном графике.\n\n\n\nR\nPython\n\n\n\nобъемный (Глава E.3), контурный (Глава E.4)\n\n\nсвои пакеты\n\n\n\n\n\n\n\n\n\nУровень 1\n\n\n\n\n\nУпражнение 21.2 (Брось!) Найти максимальную скорость тела движущегося по закону [1]\n\\[\ns = 18t + 9t^2 - t^3\n\\]\n\nПостроить график функции и её производной (Пример E.4).\nАналитически определить максимум функции (Глава 12).\nДоказать, что данная точка является максимумом (Теорема 12.2) или (Теорема 12.3) .\n\n\n\n\n\n\n\nУровень 2\n\n\n\n\n\nУпражнение 21.3 (Корабли уходят на закат) Суточные расходы при плавании судна состоят из двух частей: постоянной, равной \\(а\\), и переменной, возрастающий пропорционально кубу скорости. При какой скорости \\(v\\) плавание судна окажется наиболее экономичным? [1]\n\nопределите целевую функцию\nаналитически определите максимум целевой функции (Глава 12)\nпостройте график целевой функции (Глава E.2)\n\n\n\n\n\n\n\nУровень 2\n\n\n\n\n\nУпражнение 21.4 (Да, это жёстко) Имеется квадратный лист жести, сторона которого \\(а=60\\ см\\). Вырезая по всем его углам равные квадраты и загибая оставшуюся часть, нужно изготовить коробку без крышки. Каковы должны быть размеры вырезаемых квадратов, чтобы коробка имела наибольший объем? [1]\n\n\nРаскройка листа жести\n\n\nопределите целевую функцию\nаналитически определите максимум целевой функции (Глава 12)\nпостройте график целевой функции (Глава E.2)\n\n\n\n\n\n\n\nУровень 3\n\n\n\n\n\n\n\n\n1. \nВ. П.Г. Применение производной при решении задач на оптимизацию: методические указания по выполнению практических работ. Оренбург: Оренбургский гос. ун-т., 2012. С. 26.",
    "crumbs": [
      "Задания. Моделирование",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Введение</span>"
    ]
  },
  {
    "objectID": "lab/model/linear/standard/main.html",
    "href": "lab/model/linear/standard/main.html",
    "title": "22  Линейное программирование",
    "section": "",
    "text": "22.0.1 Теория",
    "crumbs": [
      "Задания. Моделирование",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Линейное программирование</span>"
    ]
  },
  {
    "objectID": "lab/model/linear/standard/main.html#задания",
    "href": "lab/model/linear/standard/main.html#задания",
    "title": "22  Линейное программирование",
    "section": "22.1 Задания",
    "text": "22.1 Задания\n\nУпражнение 22.1 (Простота и наглядность) \\[\n\\begin{aligned}\n&\\mathrm{F}=5x_1+4x_2 \\rightarrow \\max \\\\\n&\\begin{cases}\n6x_1+4x_2\\leq24\\\\\nx_1+2x_2\\leq6\\\\\n-x_1+x_2\\leq1\\\\\nx_1,x_2\\geq0\n\\end{cases}\n\\end{aligned}\n\\]\n\nПостроить целевую функцию\nПостроить прямые, определяющие ограничения\nОпределить точки пересечения прямых\nОпределить решение графически.\n\n\n\n\n\n\n\nСовет\n\n\n\nМожно добавлять элементы на график последовательно отображая их Глава E.6.\n\n\n\n\n\n\n\n\nУровень 1\n\n\n\n\n\nУпражнение 22.2 (Пакет с пакетами) С помощью пакета Приложение G получить решение задачи. Используйте, Глава G.1 или Глава G.2 на своё усмотрение.\n\\[\n\\begin{aligned}\n&\\mathrm{F}=3x_1+4x_2+2x_3+5x_4+6x_5+7x_6+8x_7+9x_8+10x_9+11x_{10} \\rightarrow \\max \\\\\n&\\begin{cases}\nx_1+2x_2+3x_3+x_4+4x_5+6x_6+7x_8+8x_9+9x_{10} \\leq 30\\\\\n2x_1+x_2+2x_3+3x_4+2x_5+3x_6+4x_7+5x_8+x_9+3x_{10}\\leq 20\\\\\n3x_1+4x_2+x_3+4x_4+5x_5+2x_6+x_7+3x_8+2x_9+x_{10} \\leq 25\\\\\n4x_1+2x_2+5x_3+x_4+2x_5+3x_6+5x_7+6x_8+2x_9+4x_{10} \\leq 25\\\\\nx_1+2x_2+5x_3+x_4+2x_5+4x_6+5x_7+x_8+x_9+3x_{10} \\leq 18 \\\\\n5x_1+6x_2+x_3+3x_4+4x_5+5x_6+6x_7+7x_8+x_9+2x_{10} \\leq 22 \\\\\n2x_1+3x_2+4x_3+x_4+4x_5+3x_6+2x_7+5x_8+7x_9+8x_{10} \\leq 19 \\\\\nx_i\\geq0,\\forall x_i\n\\end{cases}\n\\end{aligned}\n\\]\n\n\n\n\n\n\nУровень 1\n\n\n\n\n\nУпражнение 22.3 (Учебный план) Для новых специальностей на факультете радиофизики запланировано 3500 учебных часов. Основные разделы подготовки студентов и затраты на разработку приведены ниже.\n\n\n\nРаздел\nЗатраты\n\n\n\n\nАэрокосмос\n3\n\n\nФизика\n1\n\n\nМикроэлектроника\n2\n\n\nМатематика\n1\n\n\nКомпьютерная безопасность\n3\n\n\nПрограммирование\n1\n\n\nРадиофизика\n2\n\n\nСтатистика\n1\n\n\nМашинное обучение\n2\n\n\n\nСоотношение между часами учебных дисциплин должно быть не меньше, чем указано в диаграмме\n\n\n\n\n\ngraph LR\n    AeroSpace(Аэрокосмос)\n    Physics(Физика)\n    MicroEl(Микроэлектроника)\n    Math(Математика)\n    CyberSecurity(Инфобез)\n    Programming(Программирование)\n    RadioPhysics(Радиофизика)\n    Statistics(Статистика)\n    MachineLearning(Машинное обучение)\n\n    RadioPhysics --&gt;|2| Math\n    RadioPhysics --&gt;|2| Physics\n    MachineLearning --&gt;|1| Math\n    MachineLearning --&gt;|1| Statistics\n    MachineLearning --&gt;|1| Programming\n    AeroSpace --&gt;|1| RadioPhysics\n    AeroSpace --&gt;|1| Programming\n    CyberSecurity --&gt;|2| Programming\n    CyberSecurity --&gt;|1| Math\n    CyberSecurity --&gt;|1| Physics\n    MicroEl --&gt;|2| Programming\n    MicroEl --&gt;|1| Physics\n\n\n\n\n\n\nСогласно положению за период обучения должно быть прочитано часов не менее\n\n\n\nРаздел\nЧасы\n\n\n\n\nКомпьютерная безопасность\n400\n\n\nАэрокосмос\n300\n\n\nРадиофизика\n300\n\n\nМашинное обучение\n400\n\n\nМикроэлетроника\n300\n\n\n\nОпределите наиболее выгодное распределение часов (стоимость) для студента и для факультета.\n\n\n\n\n\n\nУровень 2\n\n\n\n\n\nУпражнение 22.4 (Работа не волк, а work) Лишенный стипендии студент для поддержания своего финансового уровня должен подрабатывать и получить не менее 700 руб в месяц. У него есть следующие альтернативы\n\n\n\n\n\n\n\n\n\n\nРабота\nЧасов, не менее\nЧасов, не более\nНапряженность\nДоход/час\n\n\n\n\nКурьер\n10\n20\n12\n10\n\n\nПовар\n20\n40\n8\n11\n\n\nГрузчик\n5\n60\n15\n8\n\n\nПродавец\n25\n70\n10\n12\n\n\nФриланс разработчик\n20\n50\n20\n30\n\n\n\nПонятно, что общая напряженность в месяц пропорциональна количеству отработанных часов. Найдите оптимальную занятость студента.\n\n\n\n\n\n\nУровень 2\n\n\n\n\n\nУпражнение 22.5 (На всю котлету) Столовая № 8 готовит блюда из картошки, овощей, курицы, свинины, крупы. Возможные ежедневные поставки ограничены. Стоимость кг сырья составляет. Минимальный дневной спрос.\n\nБазовые продукты\n\n\nПродукт\nОгр. поставок кг\nСтоимость/кг\n\n\n\n\nОвощи\n50\n3\n\n\nКрупа\n30\n1\n\n\nМясо\n10\n12\n\n\nМакароны\n20\n5\n\n\n\n\nГотовые блюда\n\n\nБлюдо\nСостав\nПропорция\nДневное потребление\n\n\n\n\nСупы\nОвощи, Крупа, Мясо\n2:3:1\n15\n\n\nГарнир\nОвощи, Крупа\n1:1\n20\n\n\nГорячее\nМясо, Макароны\n3:2\n10\n\n\nСалаты\nМясо, Овощи\n1:8\n5\n\n\n\nРазработайте модель ЛП оптимального производственного плана и потребности в ингредиентах. Как изменится решение, если стоимость блюда, а если измениться ограничение. При какой наименьшей стоимости будет иметь смысл производить. Как существенно повысить прибыль, если есть всего одна возможность.\n\n\n\n\n\n\nУровень 3\n\n\n\n\n\nУпражнение 22.6 (Враг в отражении) Решите двойственную к следующей задачу ЛП, а затем найдите оптимальное решение прямой задачи. Даёт ли в этом случае вычислительное преимущество по сравнению с решением прямой задачи ЛП? // 4.11 с 190 Таха\n\\[\n\\begin{aligned}\n&\\mathrm{F}=5x_1+6x_2+3x_3 \\rightarrow \\min \\\\\n&\\begin{cases}\n5x_1+5x_2+3x_3 \\geq 50,\\\\\nx_1+x_2-x_3 \\geq 20, \\\\\n7x_1+6x_2-9x_3 \\geq 30, \\\\\n5x_1+5x_2+5x_3 \\geq 35, \\\\\n2x_1+4x_2-15x_3 \\geq 10, \\\\\n12x_1+10x_2 \\geq 90, \\\\\nx_2-10x_3 \\geq 20, \\\\\nx_1,x_2,x_3 \\geq 0\n\\end{cases}\n\\end{aligned}\n\\]\n\n\n\n\n\n\nУровень 3",
    "crumbs": [
      "Задания. Моделирование",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Линейное программирование</span>"
    ]
  },
  {
    "objectID": "lab/model/linear/transport/main.html",
    "href": "lab/model/linear/transport/main.html",
    "title": "23  Транспортные модели",
    "section": "",
    "text": "23.1 Задачи",
    "crumbs": [
      "Задания. Моделирование",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Транспортные модели</span>"
    ]
  },
  {
    "objectID": "lab/model/linear/transport/main.html#задачи",
    "href": "lab/model/linear/transport/main.html#задачи",
    "title": "23  Транспортные модели",
    "section": "",
    "text": "Упражнение 23.1 (Несчастливая сессия) Каждый год после весенней сессии министерство обороны решает задачу о распределении бывших студентов по родам войск. Стоимость транспортировки пропорциональная расстоянию до части. Определите план с наименьшей стоимостью.\n\n\n\n\n\nГород\nОтчислено\n\n\n\nГомель\n90\n\n\nГродно\n70\n\n\nБрест\n90\n\n\nМинск\n120\n\n\n\n\n\n\n\nВойска\nРасположение\nНабор\n\n\n\nПВО\nБарановичи\n100\n\n\nССО\nСлоним\n120\n\n\nАртилерия\nБоровка\n150\n\n\n\n\n\n\nСправочно приводится таблица расстояний\n\n\n\nБарановичи\nСлоним\nБоровка\n\n\n\nГомель\n408\n477\n380\n\n\nГродно\n189\n134\n435\n\n\nБрест\n209\n199\n528\n\n\nМинск\n147\n197\n167\n\n\n\n\n\n\n\n\n\nУровень 1\n\n\n\n\n\n\n\n\n\nСовет\n\n\n\nИспользуйте функцию transport::transport()\n\n\n\n\nУпражнение 23.2 (Распределение на практику) В конце обучения факультет распределяет студентов для прохождения практики. Информация о студентах и заказчиках приведена в таблицах ниже. Специальности приведены в порядке приоритета предприятия. Если организация в которую распределяется студент не соответствует специальности, то растут издержки. Постройте схему распределения минимизирующую издержки.\n\n\n\n\n\nСпециальность\nВыпуск\n\n\n\nРадиофизика\n50\n\n\nФизическая элетроника\n30\n\n\nАэрокосмос\n20\n\n\nКомпьютерная безопасность\n45\n\n\nПрикладная информатика\n50\n\n\n\n\n\n\n\nПредприятие\nЗаказ\nСпецаильности\n\n\n\nАГАТ\n20\nКБ, РФ, ПИ, АРиСТ, ФЭ\n\n\nЛЭТЦ\n30\nРФ, ФЭ, КБ, ПИ, АРиСТ\n\n\nПеленг\n40\nРФ, ФЭ, ПИ, КБ, АРиСТ\n\n\nБелинтерсат\n10\nАРиСТ, РФ, ПИ, КБ, ФЭ\n\n\nИнтеграл\n40\nФЭ, РФ, ПИ, КБ, АРиСТ\n\n\nIBA\n15\nПИ, КБ, РФ, ФЭ, АРиСТ\n\n\n\n\n\n\n\n\n\n\n\n\nУровень 2\n\n\n\n\n\n\n\n\n\nСовет\n\n\n\nИспользуйте функцию lpSolve::lp.transport()\n\n\n\n\nУпражнение 23.3 (Задача Янукович) При составлении плана идеологическо-воспитательной работы возникла следующая задача. Назначить ответственными за мероприятия (Комната, Мистер, Капустник, Дни РФиКТ, Рафждество) одну из 4 студенческих организаций: студ. совет, творческое объединение ArtWave, БРСМ, профком. Основываясь на собственном опыте Татьяна Петровна пришла к следующей экспертной оценке возможностей организаций (больше лучше). Составьте оптимальный план работы\n\n\n\nКомната\nМистер\nКапустник\nДни РФиКТ\n\n\n\nстуд. совет\n2\n7\n16\n14\n\n\nArtWave\n10\n11\n9\n4\n\n\nБРСМ\n8\n3\n13\n15\n\n\nПрофком\n6\n5\n1\n12\n\n\n\n\n\n\n\n\n\nУровень 1\n\n\n\n\n\n\n\n\n\nСовет\n\n\n\nИспользуйте функцию lpSolve::lp.assign()\n\n\n\n\nУпражнение 23.4 (Задача Людчика) В таблице приведены результаты анкетирования студентов записавшихся в студотряд на лето. В таблице приводится запрос от организаций.\n\n\n\n\nОрганизация\nВакансии\n\n\n\nМТЗ\n100\n\n\nМАЗ\n150\n\n\nАтлант\n200\n\n\nБЖД\n300\n\n\nСтройка Островец\n170\n\n\nСтройка Хатынь\n220\n\n\n\n\n\n\n\n\n\n\n\n⤓ organizations.csv\n\n\n\nВ таблице приводится анкета, значениями являются приоритеты, где 1 наивысший.\n\n\n\n\nМТЗ\nМАЗ\nАтлант\nБЖД\nСтройка Островец\n\n\n\n14\n7\n8\n17\n5\n\n\n15\n5\n10\n9\n17\n\n\n5\n6\n1\n16\n18\n\n\n7\n14\n9\n1\n18\n\n\n18\n4\n3\n2\n12\n\n\n17\n8\n9\n14\n12\n\n\n\n\n\n\n\n\n\n\n\n⤓ questionnaire.csv\n\n\n\nТребуется распределить студентов по отрядом максимально учитывая их пожелания. Сравните производительность и объясните различие методов\n\nlpSolve::lp.assign(m)\nclue::solve_LSAP(m)\n\n\n\n\n\n\n\nСовет\n\n\n\nДля измерения производительности используйте base::system.time()\n\n\n\n\n\n\n\n\nУровень 3",
    "crumbs": [
      "Задания. Моделирование",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Транспортные модели</span>"
    ]
  },
  {
    "objectID": "lab/model/linear/integer/main.html",
    "href": "lab/model/linear/integer/main.html",
    "title": "24  Целочисленное линейное программирование",
    "section": "",
    "text": "24.1 Задачи",
    "crumbs": [
      "Задания. Моделирование",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Целочисленное линейное программирование</span>"
    ]
  },
  {
    "objectID": "lab/model/linear/integer/main.html#задачи",
    "href": "lab/model/linear/integer/main.html#задачи",
    "title": "24  Целочисленное линейное программирование",
    "section": "",
    "text": "Упражнение 24.1 Решить в целых числах с помощь пакета lpSolve применяя метод ветвей и границ интерактивно.\n\\[\n\\begin{aligned}\n&\\mathrm{F}=2x_1+5x_2 \\rightarrow \\max \\\\\n&\\begin{cases}\n3x_1+2x_2 \\leq 8 \\\\\nx_1+4x_2 \\leq 9 \\\\\n3x_1+x_2 \\leq 7 \\\\\nx1,x2 \\geq 0\n\\end{cases}\n\\end{aligned}\n\\]\n\n\n\n\n\n\nУровень 1",
    "crumbs": [
      "Задания. Моделирование",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Целочисленное линейное программирование</span>"
    ]
  },
  {
    "objectID": "lab/model/network/main.html",
    "href": "lab/model/network/main.html",
    "title": "25  Сетевые модели",
    "section": "",
    "text": "25.1 Задачи",
    "crumbs": [
      "Задания. Моделирование",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Сетевые модели</span>"
    ]
  },
  {
    "objectID": "lab/model/network/main.html#задачи",
    "href": "lab/model/network/main.html#задачи",
    "title": "25  Сетевые модели",
    "section": "",
    "text": "Упражнение 25.1 (Надёжный маршрут) М-р Умник ездит на работу на автомобиле. Закончив в своё время полный курс исследования операций, он легко определил самый короткий путь от дома до работы. К сожалению на данном маршруте находится достаточно много камер, и Умнику часто приходят штрафы за превышение скорости (как ему кажется, необоснованно). Таким образом самый короткий путь оказался не самым лучшим. Схема сети дорог, по которой м-р Умник может добраться от дома до работы, приведена ниже. На этой схеме приведены вероятности попасться в объектив камеры. Требуется определить такой маршрут, вероятность проскочить на котором будет максимальной. (Подсказка: удобней складывать логарифмы вероятностей, чем перемножать исходные значения) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nУровень 1\n\n\n\n\n\nУпражнение 25.2 (Cуета) Схема переходов между учебными корпусами изображена на рисунке. Расстояние между ними изображены на рёбрах. (Параметр E(g)$weight)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n⤓ buildings.graphml\n\n\n\nВо время перерыва студенты переходят между корпусами на дальнейшие занятия. В таблице указано сколько человек направляется из корпуса \\(i\\) в корпус \\(j\\) на следующую пару. Студент выбирает свой путь рационально (наименьшее расстояние).\n\n\n\n\n\n1\n2\n3\n4\n5\n\n\n\n1\n0\n48\n23\n42\n45\n\n\n2\n27\n0\n41\n32\n39\n\n\n3\n30\n31\n0\n43\n47\n\n\n4\n28\n33\n20\n0\n44\n\n\n5\n50\n29\n36\n25\n0\n\n\n\n\n\nПостройте граф транспортных потоков (вес ребра – число человек, которые идут между корпусами) и определите, где выгоднее всего установить кофейню.\n\n\n\n\n\n\n\nУровень 2\n\n\n\n\n\n\n\n\n\nСовет\n\n\n\n\nМатрицу можно индексировать матрицей (полезно при работе с путями).\nОбратите внимание на параметр path в функции получению рёбер графа E(g, path = )\n\nИспользуйте функцию igraph::shortest_paths()\n\n\n\n\n\n\nУпражнение 25.3 (Соображая на троих) Собираясь на тусовку три товарища с ФСК собрали все деньги, которые у них были (10,40,10) рублей соответственно. На следующее утро возник нетривиальный вопрос о должниках. Считая, что все должны были вложиться поровну определите, кто, кому и сколько должен передать.\n\n\n\n\n\n\n\n\nДанную задачу можно сформулировать как задачу поиска максимального потока в сети, если ввести два фиктивных узла: исток (который распределяет всем поровну) и сток (который показывает сколько кто потратил) и тем самым ограничить вместимость (capacity) денежных потоков.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nУровень 2\n\n\n\n\n\nУпражнение 25.4 (Построить в срок) В следующей таблице вприведены работы (процессы), выполняемые при строительстве нового спорткомплекаса в Роще. Разработайте сеть выполнения этих работ. Найдите критический путь в этой сети.\n\n\n\n\n\n\n\nПроцесс\n\nПредшествующий\nпроцесс\n\n\nДлительность\n(дни)\n\n\n\n\n\nA: Очистка строительного участка\n—\n1\n\n\n\nB: Завоз оборудования\n—\n2\n\n\n\nC: Земляные работы\nA\n1\n\n\n\nD: Заливка фундамента\nC\n2\n\n\n\nE: Наружные сантехнические работы\nB,C\n6\n\n\n\nF: Возведение каркаса дома\nD\n10\n\n\n\nG: Прокладка электропроводки\nF\n3\n\n\n\nH: Создание перекрытий\nG\n1\n\n\n\nI: Создание каркаса крыши\nF\n1\n\n\n\nJ: Внутренние сантехнические работы\nE, H\n5\n\n\n\nK: Покрытие крыши\nI\n2\n\n\n\nL: Наружные изоляционные работы\nF, J\n1\n\n\n\nM: Вставка окон и наружных дверей\nF\n2\n\n\n\nN: Обкладка комплекса кирпичом\nL, M\n4\n\n\n\nO: Штукатурка стен и потолков\nG, J\n2\n\n\n\nP: Облицовка стен и потолков\nO\n2\n\n\n\nQ: Изоляция крыши\nI, P\n1\n\n\n\nR: Окончание внутренних отделочных работ\nP\n7\n\n\n\nS: Окончание наружных отделочных работ\nI, N\n7\n\n\n\nT: Ландшафтные работы\nS\n3\n\n\n\n\n\n\n\n\n\nУровень 3\n\n\n\n\n\n\n\n\n\nСовет\n\n\n\nИспользуйте пакет criticalpath",
    "crumbs": [
      "Задания. Моделирование",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Сетевые модели</span>"
    ]
  },
  {
    "objectID": "lab/model/nonlinear/main.html",
    "href": "lab/model/nonlinear/main.html",
    "title": "26  Нелинейная оптимизация",
    "section": "",
    "text": "26.1 Задачи",
    "crumbs": [
      "Задания. Моделирование",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Нелинейная оптимизация</span>"
    ]
  },
  {
    "objectID": "lab/model/nonlinear/main.html#sec-lab-model-nonlinear-task",
    "href": "lab/model/nonlinear/main.html#sec-lab-model-nonlinear-task",
    "title": "26  Нелинейная оптимизация",
    "section": "",
    "text": "Упражнение 26.1 (В соляного) Характеристики героя Morphling из игры DotA 2 (сила \\(\\mathrm{Сил}\\) и ловкость \\(\\mathrm{Лов}\\)) рассчитываются в зависимости от уровня \\(\\mathrm{ур}\\) как:\n\\[\n\\begin{aligned}\n&\\mathrm{Cил} = 23 + 3.2\\cdot \\mathrm{ур} \\\\\n&\\mathrm{Лов} = 24 + 3.9\\cdot \\mathrm{ур}\n\\end{aligned}\n\\]\nБроня рассчитывается как\n\\[\n\\mathrm{Б} ={\\mathrm{Б}}_{\\mathrm{баз}} + \\frac{1}{6} \\mathrm{Лов}\n\\]\nгде \\(\\mathrm{Б}\\) – суммарная броня. \\({\\mathrm{Б}}_{\\mathrm{баз}} = -2\\) базовая броня. Для любого значения брони, множитель урона определяется как:\n\\[\n{\\mathrm{У}}_{\\mathrm{Мн}}=1-\\frac {f\\cdot {\\mathrm{Б}}}{b+f\\cdot \\vert {\\mathrm{Б}}\\vert}\n\\]\nгде \\({\\mathrm{У}}_{\\mathrm{Мн}}\\) – множитель урона и \\({\\mathrm{Б}}\\) – значение брони. База формулы брони \\(b=1\\), фактор формулы брони \\(f=0.06\\).\nЭффективное здоровье против физического урона определяется как:\n\\[\n{\\mathrm{Э}}_{\\mathrm{Зд}}= \\frac {{\\mathrm{Т}}_{\\mathrm{Зд}}} {{\\mathrm{У}}_{\\mathrm{Мн}}}\n\\]\nгде \\({\\mathrm{Т}}_{\\mathrm{Зд}}\\) — текущее здоровье и \\({\\mathrm{У}}_{\\mathrm{Мн}}\\) — множитель урона. Текущее здоровье зависит от показателя силы персонажа:\n\\[\n{\\mathrm{Т}}_{\\mathrm{Зд}} = 120 + 22 \\cdot \\mathrm{Сил}\n\\] Особенностью героя Morphling является то, что он может перекачивать все свои очки силы в ловкость и наоборот в соотношении 1 к 1. Регенерация здоровья зависит от силы. Одно очко силы увеличивает восстановление здоровья на 0.1 единицу в секунду. Число атак в секунду зависит определяется как\n\\[\n\\mathrm{Атк}/\\mathrm{c}=\\frac{100+\\mathrm{Лов}}{100\\cdotБВА}\n\\]\nгде БВА – базовое время атаки \\(\\mathrm{БВА}=1.5\\mathrm{с}\\). Наносимый урон за одну атаку зависит от ловкости\n\\[\n\\mathrm{У}=18+\\mathrm{Лов}\n\\]\n\nПостроить график максимального эффективного здоровья и соответствующего ему количества перекаченных очков в зависимости от уровня.\nВы сражаетесь 1 на 1 с персонажем, у которого 1500 эффективного здоровья и 100 урона. Определите количество перекаченных очков для минимизации времени победы, при условии, что ваш персонаж должен выжить.\n\n\n\n\n\n\n\nУровень 1\n\n\n\n\n\nУпражнение 26.2 (Задача о назначении целей. Максимальный урон) Задача состоит в том, чтобы максисизировать ожидаемый урон множеству целей. Пусть \\(x_{ij}\\) обозначается количество вооружений типа \\(i\\) назначенных цели \\(j\\) (\\(i=1,\\dots,p\\) и \\(j=1,\\dots,q\\)). Вводятся следующие ограничения на число вооружений\n\n\n\\(a_i\\) общее число доступных вооружений типа \\(i\\).\n\n\\(b_j\\) минимальное число вооружений всех типов назначенных цели \\(j\\)\n\n\nЭти ограничения записываются следующим образом\n\\[\n\\begin{aligned}\n&\\sum_{j=1}^q{x_{ij}} \\leq a_i, \\quad i=1,\\dots,p;\\\\\n&\\sum_{i=1}^p{x_{ij}} \\geq b_j, \\quad j=1,\\dots,q.\n\\end{aligned}\n\\] Целевая функция определяется через вероятность нанести урон цели, имеющей определённую боевую ценность.\n\n\\(\\alpha_{ij}\\) вероятность того, что цель \\(j\\) не будет повреждена при атаке одной единицы вооружения \\(i\\)\n\\(u_j\\) боевая ценность цели \\(j\\)\n\nЕсли ожидаемый урон цели \\(j\\) при атаке её количеством \\(x_{ij}\\) вооружений типа \\(j\\) равняется \\(1-\\alpha_{ij}^{x_{ij}}\\), то общий ожидаемый урон вооружениями всех типов \\(1-\\prod_{i=1}^p{\\alpha_{ij}^{x_{ij}}}\\). Тогда общий ожидаемый урон по всем целям в соответствии и их боевой ценностью\n\\[\n\\sum_{j=1}^q{u_j\\biggl[1-\\prod_{i=1}^p{\\alpha_{ij}^{x_{ij}}} \\biggr]}\n\\]\nРешить следующую задачу:\nВооружение 5 типов назначается 20 разным целям. На рисунке показана гипотетическая область, которая содержит 20 целей и отображает область применимости вооружений. Например:\n\nМежконтинентальные баллистические ракеты\nРакеты средней дальности базирующиеся в первой области\nСтратегические бомбардировщики\nШтурмовая авиация\nРакеты средней дальности базирующиеся во второй области\n\n\n\n\n\nВ файле target.csv находятся сведения о вооружении, максимальном доступном количестве и вероятности не нанести урон для 20 целей.\n\n\n\n\nWeapon\nMaxWeapon\nCost\nT1\nT2\n\n\n\n1\n200\n500\n1.00\n0.95\n\n\n2\n100\n200\n0.84\n83.00\n\n\n3\n300\n150\n0.96\n0.95\n\n\n4\n150\n100\n1.00\n1.00\n\n\n5\n250\n200\n0.92\n0.94\n\n\n\n\n\nБоевая ценность и минимальное число вооружений находятся в файле value.csv\n\n\n\n\nTarget\nMinWeapon\nValue\n\n\n\nT1\n30\n60\n\n\nT2\nNA\n50\n\n\nT3\nNA\n50\n\n\nT4\nNA\n75\n\n\nT5\nNA\n40\n\n\n\n\n\n\n\n\n\n\n\n⤓ target.csv\n\n\n\n\n\n\n\n\n\n⤓ value.csv\n\n\n\n\n\n\n\n\n\nУровень 2\n\n\n\n\n\nУпражнение 26.3 (Задача о назначении целей. Минимальная стоимость) Гарантированно уничтожить цели (T1, T15, T19) используя вооружения наименьшей стоимости.\nОграничения на урон наносимый целям определяются через \\(d_j\\) – минимальный ожидаемый урон по цели \\(j\\).\n\\[\n1-\\prod_{i=1}^p{\\alpha_{ij}^{x_{ij}}} \\geq d_j,\\quad \\forall j\n\\]\nесли \\(c_i\\) – стоимость одной единицы вооружения типа \\(i\\), то целевая функция\n\\[\n\\sum_{i=1}^p{c_i\\sum_{j=1}^q{x_{ij}}}\n\\]\n\n\n\n\n\n\nУровень 2\n\n\n\n\n\nУпражнение 26.4 (Госзакупка) Необходимо закупить 239’600’480 деталей по минимальной цене, при условии, что ни одни поставщик не может выполнить заказ полностью. Цена участия определяет дополнительную стоимость покупки у данного поставщика вне зависимости от количества деталей.\n\n\n\n\n\n\n\n\n\nПоставщик\nЦена участия\nЦена изделия\nПоставка от (штук)\nПоставка до (штук)\n\n\n\nA\n$3855.84\n$0.0061150\n0\n33’000’000\n\n\nB\n125’804.84\n0.068099\n22’000’000\n70’000’000\n\n\n~\n~\n0.066049\n70’000’001\n100’000’000\n\n\n~\n~\n0.064099\n100’000’001\n150’000’000\n\n\n~\n~\n0.062119\n150’000’001\n160’000’000\n\n\nC\n13’456.00\n0.06219\n0\n165’600’000\n\n\nD\n6’583.98\n0.072488\n0\n12’000’000\n\n\nE\n0\n0.070150\n0\n42’000’000\n\n\n~\n~\n0.068150\n42’000’001\n77’000’000\n\n\n\n\n\n\n\n\n\nУровень 2\n\n\n\n\n\nУпражнение 26.5 (Нелинейная регрессия) Рассмотрим задачу нелинейной регрессии в простейшей формулировке. Пусть есть набор данных вида\n\\[\n\\begin{pmatrix}\n\\begin{array}{c c c | c}\nx_{11} & \\dots & x_{1n} & f_1 \\\\\n\\vdots & \\ddots & \\vdots  & \\vdots \\\\\nx_{m1} & \\dots & x_{mn} & f_m\n\\end{array}\n\\end{pmatrix}\n\\]\nкоторые необходимо аппроксимировать функцией \\(f\\) наилучшим образом\n\\[\nf=f(x_1,\\dots,x_n,p_1,\\dots,p_k)\n\\]\nгде \\(p_i\\) обозначают параметры, от которых зависит функция. Задача сводится к задаче минимизации следующего выражения\n\\[\nN_f(\\{f(x_{11},\\dots,x_{1n},p_1,\\dots,p_k) - f_1,\\dots, f(x_{m1},\\dots,x_{mn},p_1,\\dots,p_k) - f_m\\}) \\rightarrow \\min\n\\]\nили простыми словами минимизировать норму \\(N_f\\) всех отклонений данных от аппроксимирующей функции. В качестве нормы можно выбрать обычное квадратичное отклонение\n\\[\nN_2(x_1,\\dots,x_n) = \\sqrt{x_1^2+\\dots+x_n^2}\n\\]\nили функция потерь Хубера, которая менее чувствительна к выбросам, чем квадратичная ошибка\n\\[\nN_{Hub}(x_1,\\dots,x_n) = \\sum\n\\begin{cases}\n\\frac{1}{2}x_i^2& \\text{если } |x_i| \\leq \\delta\\\\\n\\delta |x_i| - \\frac{1}{2}\\delta^2 & \\text{иначе}\n\\end{cases}\n\\]\nгде \\(\\delta\\) произвольное положительное число.\nОдномерная\nОпределить параметры \\(p_i\\) функции\n\\[\nf(x) = \\tan^{-1}{(p_1x)}\\exp{\\bigl(-(x-p_2)\\bigr)}+\\cos^2{(x)}\\sin{\\frac{1}{1+\\exp(-p_3x)}}\n\\] для данных из файла\n\n\n\n\n\n\n⤓ fit-one.csv\n\n\n\nПостроить график функции и аппроксимации\nМногомерная\nОпределить параметры \\(p_i\\) функции\n\\[\nf(x,y)=\\sin{(p_1 x^2y)}\\exp{(p_2 {(x-y)}^2)}\n\\] для данных из файла\n\n\n\n\n\n\n⤓ fit-one.csv\n\n\n\nПостроить график функции и аппроксимации\n\n\n\n\n\n\nУровень 2\n\n\n\n\n\n\nУпражнение 26.6 (Оценка параметров распределения) Метод максимального правдоподобия из наиболее распространённых методов оценки неизвестных параметров распределения по известной выборке. Его идея заключается в максимизации функции правдоподобия\n\\[\nL = \\prod_i{f(x_i, \\theta)}\n\\]\nгде \\(f\\) функция плотности распределения, вероятность получить вектор \\(x_i\\) при параметрах распределения \\(\\theta\\) (вектор). Для упрощения вычисления функцию правдоподобия \\(L\\) можно прологарифмировать.\n\\[\nL = \\sum_i {\\log{\\bigl(f(x_i,\\theta) \\bigr)}}\n\\]\nОпределить параметры средних \\(\\mu_1\\), \\(\\mu_2\\) и матрицы ковариации \\(\\Sigma=\\big(\\begin{smallmatrix} \\sigma_1 & \\sigma_2 \\\\ \\sigma_2 & \\sigma_3 \\end{smallmatrix}\\big)\\) для многомерного нормального распределения, плотность которого выражается следующим образом\n\\[\nf(x,y) = \\exp{\\bigl(-\\frac{1}{2} (X-\\mu).\\Sigma^{-1}.(X-\\mu) \\bigr)}\n\\]\nгде \\(x\\) и \\(\\mu\\) векторные переменные. Данные для оценки взять из файла\n\n\n\n\n\n\n⤓ multivariate.csv\n\n\n\n\n\n\n\n\n\nУровень 3",
    "crumbs": [
      "Задания. Моделирование",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Нелинейная оптимизация</span>"
    ]
  },
  {
    "objectID": "lab/model/evolutionary/main.html",
    "href": "lab/model/evolutionary/main.html",
    "title": "27  Эволюционная оптимизация",
    "section": "",
    "text": "Упражнение 27.1 (Alma Meter) Эвристические алгоритмы часто применяются для решения вычислительно трудных задач, для которых доказано, что не существует алгоритма, получающего решение за полиномиальное время (NP полнотоа). Наиболее известные из них это Задачакоммивояжёра, Задача о рюкзаке, Задача поиска изоморфного подграфа. Примечательной особенностью таких задач является их эквивалентность. Любую из этих задач можно конвертировать в другую за полиномиальное время. Таким образом можно применить весь накопленный объём подходов и эвристик для решения хорошо известной задачи в решении более специализированной.\nРассмотрим Задачу планирования производства (JSP). В ней \\(N\\) заготовок (работ) должны быть обработаны на \\(M\\) различных машинах в произвольном порядке. Ограничениями является то, что одна заготовка не может обрабатываться параллельно двумя машинами и одна машина обрабатывает только одну заготовку за раз. В условии задачи дано время обработки заготовки на машине \\(C_{ij}\\), и требуется определить план, при котором суммарное время обработки будет минимальным.\nУ JSP задачи есть несколько популярных методов решения. Например её можно сформулировать как задачу смешано-линейного программирования, задачу поиска потока минимальной стоимости. В данном мы рассмотрим способ сведения JSP к задаче коммивояжера для применения высоко-оптимизированных методов решения.\n\n27.0.1 Пример\nВ файле со вспомогательными функциями определяются три функции для визуализации решения: TSP_to_JSP, make_task_data и plot_jsp_schedule. Их применение продемонстрировано ниже\n\n\n\n\n\n\n⤓ JSP.R\n\n\n\nРассмотрим для примера рассмотрим следующую задачу с 3 машинами и 3 работами. Таблице \\(o\\) – это имя “города” задачи коммивояжера. Также номер работы, номер машины и время выполнения этой работы на заданной машине.\n\n\n\n\nname\njob\nmachine\ncost\n\n\n\no1\n1\n1\n2\n\n\no2\n1\n3\n3\n\n\no3\n1\n2\n4\n\n\no4\n2\n2\n1\n\n\no5\n2\n1\n5\n\n\no6\n2\n3\n2\n\n\no7\n3\n3\n4\n\n\no8\n3\n1\n6\n\n\no9\n3\n2\n4\n\n\n\n\n\nКаждая работа должна быть выполнена на каждой машине за определённое время, указанное в таблице. Для поиска оптимального порядка операций преобразуем пары работа-машина в города задачи коммивояжера. Например: 3 город это комбинация работы-1 на машине-2.\nДля начала сохраним структура задачи, основываясь на матрице стоимости в переменную jsp_data.\n\nsource('../../../r/helper/JSP.R')\njsp_data &lt;- make_task_data(3,3,t$cost)\n\nРасстояния между “городами” \\(i\\) и \\(j\\) вычисляются следующим образом. Если совместно используется одна работа или она машина, общее время выполнения рассчитываемый как суммарное. В таком случае обработка производится последовательно. Иначе работы могу выполнятся параллельно, тогда стоимость пути это максимальная из стоимостей обработки. Таким образом строится матрица задачи коммивояжера D\n\n\n\n\n\no1\no2\no3\no4\no5\no6\no7\no8\no9\n\n\n\no1\n0\n5\n6\n3\n5\n2\n6\n6\n4\n\n\no2\n5\n0\n7\n3\n8\n3\n4\n9\n4\n\n\no3\n6\n7\n0\n4\n5\n6\n4\n6\n8\n\n\no4\n3\n3\n4\n0\n6\n3\n5\n6\n4\n\n\no5\n5\n8\n5\n6\n0\n7\n5\n11\n5\n\n\no6\n2\n3\n6\n3\n7\n0\n4\n6\n6\n\n\no7\n6\n4\n4\n5\n5\n4\n0\n10\n8\n\n\no8\n6\n9\n6\n6\n11\n6\n10\n0\n10\n\n\no9\n4\n4\n8\n4\n5\n6\n8\n10\n0\n\n\n\n\n\nРешим задачу получив путь Приложение Q\n\npath &lt;- D |&gt; \n  TSP::as.TSP() |&gt; \n  TSP::solve_TSP(control = list(rep = 10))\npath\n\nobject of class 'TOUR' \nresult of method 'arbitrary_insertion+two_opt_rep_10' for 9 cities\ntour length: 38 \n\n\nПосле решением задачи полученный вектор, представляющий собой путь, очерёдность посещения городов и следовательно порядок выполнения работ на машинах.\n\nas.integer(path)\n\n[1] 6 1 4 8 3 7 5 9 2\n\n\nДалее из пути получим расписание работ в привычном формате. Для этого полученную ранее структуру jsp_data и найденный путь передаём в функцию TSP_to_JSP. Таблица с расписанием хранится по ключу $schedule. Столбцы from и to определяют время старта и завершения работы.\n\nsh &lt;- TSP_to_JSP(jsp_data, path)\nsh$schedule\n\n\nknitr::kable(sh$schedule)\n\n\n\njob\nmachine\nfrom\nto\n\n\n\n2\n3\n0\n2\n\n\n1\n1\n0\n2\n\n\n2\n1\n2\n3\n\n\n3\n2\n0\n6\n\n\n1\n3\n2\n6\n\n\n3\n1\n6\n10\n\n\n2\n2\n6\n11\n\n\n3\n3\n10\n14\n\n\n1\n2\n11\n14\n\n\n\n\n\nПо ключу $cost получаем общую продолжительност выполнения всех работ\n\nsh$cost\n\n[1] 14\n\n\nИ с помощью функции plot_jsp_schedule Изобразим результат на графике\n\nplot_jsp_schedule(sh$schedule)\n\n\n\n\n\n\n\n\n\n\n\n\n\nПредупреждение\n\n\n\nФункция TSP_to_JSP написана через костыль и копирует весь data.frame при добавлении нового элемента. Рекомендуется вызывать её только один раз, при уже полученном оптимальном решении задачи коммивояжера.\n\n\n\n27.0.2 Задача\nВ основном ходит мнение, что студенты провалившие сессию попадают в армию. Но особо отличившихся может ждать ещё более незавидная судьба. Они попадут в подвал 4 кафедры, где организована сборочная линия производства измерительных приборов — Альма метров. Теперь у них есть вечность, чтобы осознать свою ошибку. Узнав про бедственное положение своих бывших коллег и стремясь их поддержать, вы решаете помочь кафедре извлечь больше прибыли. Преобразовав JSP к задаче коммивояжера получите с помощью эвристических алгоритмов близкие к оптимальному расписания технологического процесса.\nВ таблице приведен один из этапов сборки альма метра третьего поколения, который сможет заменить умную колонку в свободное от работы время.\n\n\n\n\n\n\nЭлемент\nЗона на плате\nВремя, минут\n\n\n\nУстановка микроконтроллера (ESP32-WROOM-32D/E)\nЦентр платы\n5\n\n\nПайка датчика температуры/влажности (SHT20 или DHT22)\nСенсоры\n3\n\n\nПодключение реле (SRD-12VDC-SL)\nСиловая часть\n2\n\n\nМонтаж разъема питания (DC Jack)\n\n3\n\n\nУстановка светодиодов\nИндикация\n2\n\n\nДобавление кнопки Reset\nВнешние элементы\n1\n\n\nУстановка аудио разъема 3.5 мм\n\n2\n\n\n\nОпределите оптимальное расписание для сборки:\n\nодного изделия\n10\n20\n\n\n\n\n\n\n\nУровень 3",
    "crumbs": [
      "Задания. Моделирование",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Эволюционная оптимизация</span>"
    ]
  },
  {
    "objectID": "lab/extra/programming/r/main.html",
    "href": "lab/extra/programming/r/main.html",
    "title": "28  R",
    "section": "",
    "text": "28.0.1 Прикладная магия\nПусть дана функция общего вида \\(f(x,y)\\) и система уравнений \\(Ax=b\\) для двух переменных. Постройте контурный график функции, на котором изобразите точки пересечения прямых. Обработать случаи параллельных прямых, совпадающих прямых Глава 7.3.1.\n\n\n\n\n\n\nУровень 4\n\n\n\nДополнительно попробуйте использовать встроенный интерфейса формулы используя переменно число аргументов для функции. Считайте символ ~ эквивалентом символу =. ?sec-r-lang-advanced-formula\n```{r}\nf(2*x+3*y~0, 2*x~3y+1~0)\n```",
    "crumbs": [
      "Задания. Дополнительно",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>R</span>"
    ]
  },
  {
    "objectID": "lab/extra/network/main.html",
    "href": "lab/extra/network/main.html",
    "title": "29  Cетевые модели",
    "section": "",
    "text": "Упражнение 29.1 (Ничего лишнего) Для того, чтобы подключить к сети компьютеры в 505 аудитории Иван Алексеевич заготовил 30м ethernet кабеля категории 6e. Схема приводится на рисунке.\n\n\n\n\n\n\n⤓ room505.graphml\n\n\n\n\n\n\n\n\n\n\n\nВ таблице приведены свойства, которые можно получить после импорта графа из файла.\n\n\nСвойство\nКод\n\n\n\nДлина кабеля между устройствами\nE(g)$weight\n\n\nТип устройства\nV(g)$type\n\n\nИмя устройства\nV(g)$name\n\n\nКоордината X в кабинете\nV(g)$posX\n\n\nКоордината Y в кабинете\nV(g)$posY\n\n\nГруппа устройства\nV(g)$group\n\n\n\nИнформация об устройствах приведена в таблице ниже.\n\n\n\n\nУстройство\nТип\nГруппа\nX\nY\n\n\n\nРз13\nрозетка\nРозетки 5\n600\n-550\n\n\nРз7\nрозетка\nРозетки 2\n600\n200\n\n\nПК6\nкомпьютер\nКомпьютеры 2\n500\n200\n\n\nРз16\nрозетка\nРозетки 5\n500\n-700\n\n\nРз14\nрозетка\nРозетки 5\n600\n-500\n\n\n\n\n\n\n\n\n\n\n\n⤓ vertex.csv\n\n\n\nА в следующей таблице показаны длины обязательных сегментов.\n\n\n\n\nfrom\nto\nweight\n\n\n\nКоммутатор\nРз1\n100\n\n\nУг3\nРз13\n150\n\n\nУг2\nРз6\n100\n\n\nУг1\nРз3\n150\n\n\nУг3\nРз15\n50\n\n\n\n\n\n\n\n\n\n\n\n⤓ edge.csv\n\n\n\nДля группы устройств есть возможность подключения к группе розеток. Вам необходимо рассчитать длину кабеля для соединения любого устройства с любой розеткой внутри группы (евклидово расстояние, гипотенуза в декартовых координатах) и добавить эти рёбра к графу.\n\n\nУстройства\nРозетки\n\n\n\nКомпьютеры 1\nРозетки 1\n\n\nКомпьютеры 2\nРозетки 2\n\n\nКомпьютеры 3\nРозетки 3\n\n\nСтенды 1\nРозетки 4\n\n\nСтенды 2\nРозетки 5\n\n\n\nПомогите Ивану Алексеевичу использовать как можно больше сэкономленного кабеля для датчиков цифрового факультета. Для этого требуется определить минимальное остовное дерево составленного графа.\n\n\n\n\n\n\nУровень 4\n\n\n\n\n\n\n\n\n\nСовет\n\n\n\nИдея представить граф как набор рёбер.\n\ng &lt;- igraph::sample_gnp(12,0.4)\nplot(g)\n\n\n\n\n\n\n\nИспользуя join мы добавляем цвет рёбрам, которые встретились во втором графе. Значения тех, которые не встретились во втором наборе заполняются через replace_na\n\ng_mst &lt;- igraph::mst(g)\n\nhg &lt;- dplyr::left_join(\n  igraph::as_data_frame(g),\n  cbind(igraph::as_data_frame(g_mst), color = 'red'),\n  by = dplyr::join_by(from, to)) |&gt;\n  dplyr::mutate(color = tidyr::replace_na(color, 'black')) |&gt;\n  igraph::graph_from_data_frame(directed = FALSE)\n\nplot(\n  hg,\n  edge.label = igraph::E(hg)$weight,\n  edge.color = igraph::E(hg)$color)",
    "crumbs": [
      "Задания. Дополнительно",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Cетевые модели</span>"
    ]
  },
  {
    "objectID": "lab/extra/evolutionary/main.html",
    "href": "lab/extra/evolutionary/main.html",
    "title": "30  Эволюционная оптимизация",
    "section": "",
    "text": "Упражнение 30.1 (Телекомания) Телекомпания хочет разместить свои вышки в городе с населением 302 тыс. человек. Схема районов города вместе с пригородом представлена на рисунке Рисунок 30.1. Плотность населения в городе задаётся функцией \\(P(x,y)\\) и представлена на рисунке Рисунок 30.2. Топографическая карта города задаётся функцией \\(A(x,y)\\) и представлена на рисунке Рисунок 30.2. Цель компании разместить свои вышки таким образом, чтобы обслуживать максимальное количество абонентов. Возможность подключения абонента зависит от качества сигнала, которое определяется взаимным расположением его и передатчика.\n\n\n\n\n\nРисунок 30.1: Схема районов\n\n\n\n\n\n\n\n\n\n\n\nРисунок 30.2: Плотность населения\n\n\n\n\n\n\n\n\n\n\nРисунок 30.3: Карта высот\n\n\n\n\n\n\n30.0.1 Задача\n\nЧасть 1. Одна вышка\nУстановив одну вышку\nЧасть 2. Две вышки\nУстановив две вышки. Абонент может подключаться только к одной вышке (при перекрытии число абонентов не суммируется). Необходимо разместить вышки таким образом, чтобы максимизировать количество подключенных абонентов \\(M\\).\nЧасть 3. Ограничения\nВышки нельзя размещать территории на школ, больниц и других учреждений (красные области на Рисунок 30.4).\n\n\n\n\n\nРисунок 30.4: Схема с ограничениями\n\n\nЗапрещённые области заданы координатами углов прямоугольника\n\n\n\n\nx1\ny1\nx2\ny2\n\n\n\n79\n-49\n73\n-51\n\n\n-35\n-49\n-32\n-52\n\n\n-42\n60\n-45\n57\n\n\n-5\n67\n2\n63\n\n\n74\n-1\n71\n-4\n\n\n-8\n26\n-4\n25\n\n\n\n\n\n```{r}\ntele &lt;- hdf5r::H5File$new('tele.h5', mode = 'r')\npop_mat &lt;- tele[['Population']]$read()\nalt_mat &lt;- tele[['Altitude']]$read()\n```\n\n\n\n\n\n\n⤓ tele.h5\n⤓ ban.csv\n\n\n\n\n30.0.2 Формализация\nЕвклидово расстояние \\(D\\) между точками \\(p_1(x,y)\\) и \\(p_2(x,y)\\)\n\\[\nD(p_1,p_2)=D(\\{x_1,y_1\\},\\{x_2,y_2\\})=\\sqrt{{(x_2-x_1)}^2+{(y_2-y_1)}^2}\n\\]\nПространство\n\n\nНепрерывный\nДискретный\n\n\n\nОпределим непрерывные координатные переменные переменные:\n\\[\n\\begin{aligned}\n-100 \\leq x \\leq 100 \\\\\n-100 \\leq y \\leq 100\n\\end{aligned}\n\\]\nТогда точки, в которых находится передатчик (трансмиттер) \\(t\\) и приёмник (ресивер) \\(r\\) принадлежат пространству\n\\[\nt,r \\in (-100,100)\\times(-100,100)\n\\]\n\n\nОпределим индексные координатные переменные:\n\\[\n\\begin{aligned}\nx = 1..201\\\\\ny = 1..201\n\\end{aligned}\n\\] Тогда точки, в которых находится передатчик (трансмиттер) \\(t\\) и приёмник (ресивер) \\(r\\) принадлежат пространству\n\\[\nt,r \\in \\{1..201 \\}\\times \\{1..201 \\}\n\\]\n\n\n\nСигнал\nМощность сигнала от вышки в точке \\(r(x,y)\\) обозначается функцией \\(S(t,r)\\) и падает обратно пропорционально квадрату расстояния \\(D(t,r)\\) от передатчика (\\(t\\)) до абонента (\\(r\\)) и зависит от экранирования сигнала. Абонент может смотреть телевизор, если мощность его сигнала \\(S(t,r) \\geq 5\\cdot10^{-4}\\). И в случае дискретного, и в случае непрерывного сигнала его мощность в точке \\(r\\) можно записать используя коэффициент экранирования и расстояние:\n\\[\nS(t,r) = \\frac{Scr(t,r)}{D(t,r)^2}\n\\]\nКоэффициент экранирования\nПусть передатчик (трансмиттер) установлен в точке \\(t(80,90)\\), а абонент (ресивер) находится в точке \\(r(5,5)\\). Рассмотрим путь, который должен преодолеть сигнал. Передатчик установлен на высоте \\(126\\) (справа), а абонент \\(35\\) (слева), если провести прямую между ними, то вся земля, которая находится выше этой прямой будет экранировать (ослаблять) сигнал:\n\n\n\n\n\n\nЭкранирование обознается функцией \\(Scr(t,r)\\) экспоненциально зависит от длины экранирования \\(L_{Scr}\\) — суммарного расстояния, которое сигнал проходит “под землей”.\n\\[\nScr(t,r) = \\exp{\\biggl(- \\frac{ L_{Scr}}{40} \\biggr)}\n\\]\nУравнение прямой \\(f\\) соединяющей приёмник с передатчиком можно записать в параметрическом виде (параметр \\(p \\in (0,1)\\)): \n\\[\n\\begin{cases}\nx(p) = (t_x-r_x)\\cdot p + r_x\\\\\ny(p) = (t_y-r_y)\\cdot p + r_y\n\\end{cases}\n\\]\nИ значение высоты вдоль прямой высоты:\n\\[\nAL(p) = \\bigl( A(t_x,t_y) - A(r_x,r_y) \\bigr)\\cdot p + A(r_x,r_y)\n\\]\n\n\nНепрерывный\nДискретный\n\n\n\nДлину экранирования можно вычислить с помощью формулы длины дуги кривой\n\\[\nL=\\int{\\sqrt{1+{(f'(x))}^2}dx}\n\\]\nсоответственно\n\\[\nL_{Scr} = \\int_0^1\n\\sqrt{1+{\\bigl(AL'(p)\\bigr)}^2}\\cdot\n{\\begin{cases}\n1,\\text{ если }AL(p) \\leq A(x(p),y(p))\\\\\n0,\\text{ инчае }\n\\end{cases}}dp\n\\]\n\n\nМы можем построить дискретную прямую из точки \\(t\\) в точку \\(r\\) (например с помощью алгоритма Брезенхэма) получив множество точек \\(L_i=\\{x_i,y_i\\}, \\, \\forall i\\) вдоль которых распространяется сигнал от передатчика к абоненту.\n\n\n\n\nx\ny\n\n\n\n80\n90\n\n\n79\n89\n\n\n78\n88\n\n\n77\n87\n\n\n76\n86\n\n\n76\n85\n\n\n\n\n\nТогда путь на матрице выделен красной прямой\n\n\n\n\n\n\n\n\n\nТеперь для каждой точки мы можем проверить находится ли она под землёй: получим множество подземных точек.\n\\[\nU_i = \\{x_i,y_i\\},\\, \\text{если} \\, AL(x_i,y_i) \\leq A(x_i,y_i) \\, \\forall i\n\\]\nТогда итоговую длину экранирования вычислим как отношение помеченных точек к всем умноженное на евклидово расстояние между приёмником и передатчиком\n\\[\nL_{Scr} = \\frac{|U_i|}{|L_i|} D(r,t)\n\\]\nгде \\(|\\cdot|\\) обознается мощность (число элементов) множества.\n\n\n\nПодключенные абоненты\nАбонент считается подключенным, если мощность сигнала от вышки превышает заданный порог.\n\\[\nM(t,r) =\n\\begin{cases}\nP(r), &если \\, S(t,r) \\geq 5\\cdot10^{-4}\\\\\n0, & инчае\n\\end{cases}\n\\]\nВ случае двух вышек функция \\(M(t_1,t_2,r)\\) запишется следующим образом\n\\[\nM(t,r) =\n\\begin{cases}\nP(r), &если \\, S(t_1,r) \\geq 5\\cdot10^{-4}\\\\\nP(r), &если \\, S(t_2,r) \\geq 5\\cdot10^{-4}\\\\\n0, & инчае\n\\end{cases}\n\\]\nФункция \\(M(t,r)\\) – плотность населения в точке \\(r\\) принимающих сигнал от передатчика из точки \\(t\\). Итоговое число абонентов, подключенных к передатчику, установленному в точке \\(t\\) определяется суммированием по всем положениям абонентов \\(r(x,y)\\) из области определения определяется следующим образом\n\n\nНепрерывный\nДискретный\n\n\n\n\\[\nM(t) = \\iint M(t,r=\\{x,y\\}) dxdy\n\\]\n\n\n\\[\nM(t) = \\sum_x \\sum_y M(t,r = \\{x,y\\})\n\\]\n\n\n\nЦелевая функция\nМаксимизировать целевую функцию – число подключенных абонентов\n\\[\n\\max{M(t)}\n\\]\nРеализация\nОсновываясь на опыте, полученном при выполнении работ по темам нелинейное и эволюционное программирование выбрать подходящий способ решения.\n\n\n\n\n\n\nСовет\n\n\n\n\n\nНепрерывный\nДискретный\n\n\n\nМогут пригодиться функции интерполяции и интегрирования (пакет pracma).\n\n\nРеализацию алгоритма Брезенхема можно взять из пакета AFM::getBresenham2DSegment()\n\n\n\n\n\n\n\n\n\n\n\nУровень 4",
    "crumbs": [
      "Задания. Дополнительно",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Эволюционная оптимизация</span>"
    ]
  },
  {
    "objectID": "practice/basic-model/main.html",
    "href": "practice/basic-model/main.html",
    "title": "31  Модели исследования операций",
    "section": "",
    "text": "31.1 Темы\nЦелевая функция, ограничения.",
    "crumbs": [
      "Практические работы",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Модели исследования операций</span>"
    ]
  },
  {
    "objectID": "practice/basic-model/main.html#sec-practice-base-model-topics",
    "href": "practice/basic-model/main.html#sec-practice-base-model-topics",
    "title": "31  Модели исследования операций",
    "section": "",
    "text": "Пример 31.1 (Примерчик) Задание\n\n\nРешение 31.1. Решение",
    "crumbs": [
      "Практические работы",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Модели исследования операций</span>"
    ]
  },
  {
    "objectID": "practice/linear/algebra/main.html",
    "href": "practice/linear/algebra/main.html",
    "title": "32  Линейная алгебра",
    "section": "",
    "text": "32.1 Темы\nОпределитель, слау",
    "crumbs": [
      "Практические работы",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Линейная алгебра</span>"
    ]
  },
  {
    "objectID": "practice/linear/algebra/main.html#sec-practice-linear-algebra-topics",
    "href": "practice/linear/algebra/main.html#sec-practice-linear-algebra-topics",
    "title": "32  Линейная алгебра",
    "section": "",
    "text": "Пример 32.1 (Примерчик) Задание\n\n\nРешение 32.1. Решение",
    "crumbs": [
      "Практические работы",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Линейная алгебра</span>"
    ]
  },
  {
    "objectID": "practice/linear/graphical/main.html",
    "href": "practice/linear/graphical/main.html",
    "title": "33  Линейное программирование. Графическое представление",
    "section": "",
    "text": "33.1 Темы\nОбласть допустимых решений (симплекс), изображение целевой функции. Решить графически задачу для двух переменных.\nГрафический анализ чувствительности оптимального решения - По коэффициентам целевой функции - По ограничениям\nОпределить, какой из особых случаев реализован - Вырожденность - Альтернативные оптимальные решения - Отсутствие допустимых решений - Неограниченность",
    "crumbs": [
      "Практические работы",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Линейное программирование. Графическое представление</span>"
    ]
  },
  {
    "objectID": "practice/linear/graphical/main.html#sec-practice-linear-graphical-topics",
    "href": "practice/linear/graphical/main.html#sec-practice-linear-graphical-topics",
    "title": "33  Линейное программирование. Графическое представление",
    "section": "",
    "text": "Пример 33.1 (Примерчик) Задание\n\n\nРешение 33.1. Решение",
    "crumbs": [
      "Практические работы",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Линейное программирование. Графическое представление</span>"
    ]
  },
  {
    "objectID": "practice/linear/model/main.html",
    "href": "practice/linear/model/main.html",
    "title": "34  Линейное программирование. Модели",
    "section": "",
    "text": "34.1 Темы\nПривести в стандартную форму. Построить модель текстовой задаче. Сформулировать двойственную задачу",
    "crumbs": [
      "Практические работы",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Линейное программирование. Модели</span>"
    ]
  },
  {
    "objectID": "practice/linear/model/main.html#sec-practice-linear-model-topics",
    "href": "practice/linear/model/main.html#sec-practice-linear-model-topics",
    "title": "34  Линейное программирование. Модели",
    "section": "",
    "text": "Пример 34.1 (Примерчик) Задание\n\n\nРешение 34.1. Решение",
    "crumbs": [
      "Практические работы",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Линейное программирование. Модели</span>"
    ]
  },
  {
    "objectID": "practice/linear/simplex/main.html",
    "href": "practice/linear/simplex/main.html",
    "title": "35  Линейное программирование. Симплекс метод",
    "section": "",
    "text": "35.1 Темы\nРешить задачу",
    "crumbs": [
      "Практические работы",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Линейное программирование. Симплекс метод</span>"
    ]
  },
  {
    "objectID": "practice/linear/simplex/main.html#sec-practice-linear-simplex-topics",
    "href": "practice/linear/simplex/main.html#sec-practice-linear-simplex-topics",
    "title": "35  Линейное программирование. Симплекс метод",
    "section": "",
    "text": "Симплекс методом\nМ-Методом\nДвухэтапным симплекс методом\n\n\nПример 35.1 (Примерчик) Задание\n\n\nРешение 35.1. Решение",
    "crumbs": [
      "Практические работы",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Линейное программирование. Симплекс метод</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Литература",
    "section": "",
    "text": "1. Ден\nС. Алгоритмы эволюционной оптимизации\nбиологически обусловленные и популяционно-ориентированные подходы к\nкомпьютерному интеллекту / ed. Логунова А.В. Москва: ДМК Пресс, 2020. P.\n940.\n\n\n2. Learn LaTeX in 30 minutes [Electronic\nresource]. URL: https://www.overleaf.com/learn/latex/Learn_LaTeX_in_30_minutes\n(accessed: 20.02.2025).\n\n\n3. Equation sheet [Electronic resource]. URL: http://www.equationsheet.com/\n(accessed: 20.02.2025).\n\n\n4. Eager E. Linear algebra for data science in r\n[Electronic resource]. 2021. URL: https://rpubs.com/odenipinedo/linear-algebra-for-data-science-in-R\n(accessed: 20.02.2025).\n\n\n5. Гольштейн Евгений Григорьевич Ю.Д.Б.\nМатематические основы и практические задачи. стереотипное. Москва:\nЛЕНАНД, 2022. Vol. 1. P. 320.\n\n\n6. R\ntutorial [Electronic resource]. URL: https://www.tutorialspoint.com/r/index.htm\n(accessed: 20.02.2025).\n\n\n7. R\ntutorial [Electronic resource]. URL: https://www.w3schools.com/r/\n(accessed: 20.02.2025).\n\n\n8. RStudio. Introduction to renv [Electronic\nresource]. 2024. URL: https://rstudio.github.io/renv/articles/renv.html\n(accessed: 20.02.2025).\n\n\n9. Емелин А. Возрастание, убывание и экстремумы\nфункции [Electronic resource]. URL: http://mathprofi.ru/vozrastanie_ubyvanie_ekstremumy_funkcii.html\n(accessed: 20.02.2025).\n\n\n10. Понятие экстремума функции [Electronic\nresource]. URL: https://www.webmath.ru/poleznoe/formules_8_22.php\n(accessed: 20.02.2025).\n\n\n11. Емелин А. Экстремумы функций двух и трёх\nпеременных [Electronic resource]. URL: http://mathprofi.ru/extremumy_funkcij_dvuh_i_treh_peremennyh.html\n(accessed: 20.02.2025).\n\n\n12. В.\nП.Г. Применение производной при решении задач на оптимизацию:\nМетодические указания по выполнению практических работ. Оренбург:\nОренбургский гос. ун-т., 2012. P. 26.\n\n\n13. А.\nТ.Х. Исследование операций. 10th ed. / ed. Слепцова А.В.\nСанкт-Петербург: ООО \"Диалектика\", 2019. P. 1056.",
    "crumbs": [
      "Литература"
    ]
  },
  {
    "objectID": "r/tools/renv.html",
    "href": "r/tools/renv.html",
    "title": "Приложение A — Система управления пакетами renv",
    "section": "",
    "text": "A.1 Терминология\nRenv расшифровывается как Reproducible Environment. Эта библиотека позволяет автоматизировать управление пакетами и их зависимостями. [1]",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Система управления пакетами renv</span>"
    ]
  },
  {
    "objectID": "r/tools/renv.html#sec-r-tools-renv-defenitions",
    "href": "r/tools/renv.html#sec-r-tools-renv-defenitions",
    "title": "Приложение A — Система управления пакетами renv",
    "section": "",
    "text": "Определение A.1  \n\nБиблиотека (library)\n\nэто каталог, содержащий установленные пакеты (packages). Следующий код загружает пакет {r} library(dplyr), из библиотеки общей для всей системы. Текущие библиотеки можно посмотреть с помощью функции .libPaths() . Доступные пакеты можно узнать с помощью команды {r} lapply(.libPaths(), list.files) или через вкладку Packeges в RStudio.\n\n\n\n\nОпределение A.2  \n\nРепозиторий\n\nэто источник пакетов; install.packages() загружает пакет из репозитория и помещает его в библиотеку (каталог компьютере). Наиболее важным репозиторием является CRAN; Другие свободно доступные репозитории включают Bioconductor, Posit Public Package Manager и R Universe. Узнать какие репозитории активны в текущем сеансе можно с помощью команды {r} getOption('repos')",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Система управления пакетами renv</span>"
    ]
  },
  {
    "objectID": "r/tools/renv.html#sec-r-tools-renv-project",
    "href": "r/tools/renv.html#sec-r-tools-renv-project",
    "title": "Приложение A — Система управления пакетами renv",
    "section": "A.2 Проект",
    "text": "A.2 Проект\n\nA.2.1 Инициализация\nПроект инициализируется с renv::init(). Эта команда добавляет в проект три новых файла и директории:\n\nБиблиотека проекта, renv/library, содержащая все пакеты, которые в данный момент используются проекте. Renv инициализирует библиотеку для кажого проекта гаранитируя изоляцию проектов друг от друга. Разные проекты могут использовать разные версии пакетов, а установка, обновление или удаление пакетов в одном проекте не влияет на другие проекты.\nФайл блокировки renv.lock в который записываются метаданные об установленных пакетах.\nПрофиль проекта R, .Rprofile. Этот файл запускается автоматически при каждом запуске интерпретатора R (в данном проекте) и позволяет renv настроить пути к пакетам .\n\n\n\nA.2.2 Сохранение состояния\nДля сохранения состояния текущего проекта выполняется команда renv::snapshot(), которая записывает метаданные пакетов в файл renv.lock.\n\n\nA.2.3 Восстановление\nДля того, чтобы восстановить пакеты из другого проекта (например размещённого на github) требуется 4 файла:\nrenv.lock\n.Rprofile\nrenv/activate.R\nrenv/settings.json\nПосле сохранения этих файлов в каталоге проекта для восстановления пакетов выполняется команда renv::restore()\n\n\nA.2.4 Установка пакетов\nУстановка пакетов возможна стандартным способом install.packages() или с помощью renv::install().\n\n\nA.2.5 Обновление пакетов\nОбновление пакетов производится вызовом renv::update(). После обновления необходимо сохранить изменения Глава A.2.2.",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Система управления пакетами renv</span>"
    ]
  },
  {
    "objectID": "r/tools/renv.html#sec-r-tools-renv-project-infrastructure",
    "href": "r/tools/renv.html#sec-r-tools-renv-project-infrastructure",
    "title": "Приложение A — Система управления пакетами renv",
    "section": "A.3 Инфраструктура",
    "text": "A.3 Инфраструктура\nФайл блокировки всегда называется renv.lock и представляет собой json-файл, в котором записана вся информация, необходимая для воссоздания проекта. Пример файла блокировки с пакетом markdown, установленным из CRAN, и пакетом mime, установленным с GitHub:\n{\n  \"R\": {\n    \"Version\": \"4.4.2\",\n    \"Repositories\": [\n      {\n        \"Name\": \"CRAN\",\n        \"URL\": \"https://cloud.r-project.org\"\n      }\n    ]\n  },\n  \"Packages\": {\n    \"markdown\": {\n      \"Package\": \"markdown\",\n      \"Version\": \"1.0\",\n      \"Source\": \"Repository\",\n      \"Repository\": \"CRAN\",\n      \"Hash\": \"4584a57f565dd7987d59dda3a02cfb41\"\n    },\n    \"mime\": {\n      \"Package\": \"mime\",\n      \"Version\": \"0.12.1\",\n      \"Source\": \"GitHub\",\n      \"RemoteType\": \"github\",\n      \"RemoteHost\": \"api.github.com\",\n      \"RemoteUsername\": \"yihui\",\n      \"RemoteRepo\": \"mime\",\n      \"RemoteRef\": \"main\",\n      \"RemoteSha\": \"1763e0dcb72fb58d97bab97bb834fc71f1e012bc\",\n      \"Requirements\": [\n        \"tools\"\n      ],\n      \"Hash\": \"c2772b6269924dad6784aaa1d99dbb86\"\n    }\n  }\n}\n\n\n\n\n1. RStudio. Introduction to renv [Электронный ресурс]. 2024. URL: https://rstudio.github.io/renv/articles/renv.html (дата обращения: 20.02.2025).",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Система управления пакетами renv</span>"
    ]
  },
  {
    "objectID": "r/tools/pracma.html",
    "href": "r/tools/pracma.html",
    "title": "Приложение B — Численные методы pracma",
    "section": "",
    "text": "Интерполяция, интегрирование",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Численные методы `pracma`</span>"
    ]
  },
  {
    "objectID": "r/tools/smoof.html",
    "href": "r/tools/smoof.html",
    "title": "Приложение C — Smoof",
    "section": "",
    "text": "C.1 Создание функции\nИнфраструктура целевых функций нелинейной и глобальной оптимизации\nobjfn &lt;-  smoof::makeSingleObjectiveFunction(\n  name = 'Example',\n  fn = function(x) x * sin(3*x),\n  par.set = ParamHelpers::makeNumericParamSet('x', len = 1L, lower = 0, upper = 2 * pi),\n  tags = c('single-objective', 'differentiable', 'continuous'),\n  vectorized = TRUE\n)\n\nggplot2::autoplot(objfn)",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Smoof</span>"
    ]
  },
  {
    "objectID": "r/tools/smoof.html#sec-r-tools-smoof-counting",
    "href": "r/tools/smoof.html#sec-r-tools-smoof-counting",
    "title": "Приложение C — Smoof",
    "section": "C.2 Простой подсчёт вызовов функции",
    "text": "C.2 Простой подсчёт вызовов функции\n\n```{r}\no1 &lt;- objfn |&gt;\n  smoof::addCountingWrapper()\n\nres &lt;- optim(par = 1, fn = o1, lower = 0, upper = pi, method = 'Brent')\n\nsmoof::getNumberOfEvaluations(o1)\n```\n\n[1] 12",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Smoof</span>"
    ]
  },
  {
    "objectID": "r/tools/smoof.html#sec-r-tools-smoof-logging",
    "href": "r/tools/smoof.html#sec-r-tools-smoof-logging",
    "title": "Приложение C — Smoof",
    "section": "C.3 Логирование промежуточных вычислений",
    "text": "C.3 Логирование промежуточных вычислений\n\no1 &lt;- objfn |&gt;\n  smoof::addLoggingWrapper(logg.x = TRUE, logg.y = TRUE)\n\nres &lt;- optim(par = 1, fn = o1, lower = 0, upper = pi, method = 'Brent')\n\nsmoof::getLoggedValues(o1, compact = TRUE)\n\n          x         y1\n1  1.199982 -0.5309570\n2  1.941611 -0.8591065\n3  2.399963  1.9046126\n4  1.611815 -1.5996267\n5  1.604694 -1.5964037\n6  1.636515 -1.6048118\n7  1.637928 -1.6048230\n8  1.637732 -1.6048233\n9  1.637727 -1.6048233\n10 1.637727 -1.6048233\n11 1.637727 -1.6048233\n12 1.637727 -1.6048233",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Smoof</span>"
    ]
  },
  {
    "objectID": "r/tools/smoof.html#sec-r-tools-smoof-wrap",
    "href": "r/tools/smoof.html#sec-r-tools-smoof-wrap",
    "title": "Приложение C — Smoof",
    "section": "C.4 Преобразование в обычную функцию",
    "text": "C.4 Преобразование в обычную функцию\nНекоторые пакеты работают только с обычными функциями R, а не с объектами smoof function. Для этого можно обернуть функцию\n\nobjfn &lt;- smoof::makeSphereFunction(2) |&gt; \n  smoof::addLoggingWrapper(logg.x = TRUE, logg.y = TRUE)\nf &lt;- \\(par) objfn(par)\n\nТеперь вызовем функцию f\n\nf(1:2)\n\n[1] 5\n\n\nИ проверим вычисления\n\nsmoof::getLoggedValues(objfn, compact = TRUE)\n\n  x1 x2 y1\n1  1  2  5",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Smoof</span>"
    ]
  },
  {
    "objectID": "r/tools/stats.html",
    "href": "r/tools/stats.html",
    "title": "Приложение D — Пакет stats",
    "section": "",
    "text": "D.1 Одномерная оптимизация\nОптимизация для одномерных смесь обратных парабол и золотого сечения. https://en.wikipedia.org/wiki/Brent%27s_method\na &lt;- optimize",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Пакет `stats`</span>"
    ]
  },
  {
    "objectID": "r/tools/stats.html#sec-r-tools-stats-deriv",
    "href": "r/tools/stats.html#sec-r-tools-stats-deriv",
    "title": "Приложение D — Пакет stats",
    "section": "D.2 Символьные производные",
    "text": "D.2 Символьные производные\nСимвольные вычисления вместе с гессианом и градиентом\n\nstats::deriv(~ -(y * (b0 + x * b1) - log(1 + exp(b0 + b1 * x))),\n             c(\"b0\", \"b1\"))\n\nexpression({\n    .expr6 &lt;- exp(b0 + b1 * x)\n    .expr7 &lt;- 1 + .expr6\n    .value &lt;- -(y * (b0 + x * b1) - log(.expr7))\n    .grad &lt;- array(0, c(length(.value), 2L), list(NULL, c(\"b0\", \n        \"b1\")))\n    .grad[, \"b0\"] &lt;- -(y - .expr6/.expr7)\n    .grad[, \"b1\"] &lt;- -(y * x - .expr6 * x/.expr7)\n    attr(.value, \"gradient\") &lt;- .grad\n    .value\n})",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Пакет `stats`</span>"
    ]
  },
  {
    "objectID": "r/tools/stats.html#sec-r-tools-stats-t-test",
    "href": "r/tools/stats.html#sec-r-tools-stats-t-test",
    "title": "Приложение D — Пакет stats",
    "section": "D.3 T-тест Стьюдента",
    "text": "D.3 T-тест Стьюдента\nГлава 16.1 Равенства средних значений двух выборок\n\na &lt;- runif(1000000)\nb &lt;- runif(1000000)\ne &lt;- runif(1000000)\n\nБольше p-value лучше\n\nt.test(a,b)\n\n\n    Welch Two Sample t-test\n\ndata:  a and b\nt = 1.4538, df = 2e+06, p-value = 0.146\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -0.0002066738  0.0013939601\nsample estimates:\nmean of x mean of y \n0.5000432 0.4994496",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Пакет `stats`</span>"
    ]
  },
  {
    "objectID": "r/tools/stats.html#sec-r-tools-stats-f-test",
    "href": "r/tools/stats.html#sec-r-tools-stats-f-test",
    "title": "Приложение D — Пакет stats",
    "section": "D.4 F-тест",
    "text": "D.4 F-тест\nГлава 16.2 Равенства средних для множества выборок\n\nd &lt;- data.frame(value = c(a,b,e), group = sample(paste0('g',1:3), length(a)*3, replace = TRUE))\n\n\nres &lt;- aov(value ~ group, data = d)\nsummary(res)\n\n               Df Sum Sq Mean Sq F value Pr(&gt;F)\ngroup       2e+00      0 0.12991   1.558   0.21\nResiduals   3e+06 250084 0.08336               \n\n\n\nres\n\nCall:\n   aov(formula = value ~ group, data = d)\n\nTerms:\n                    group Residuals\nSum of Squares       0.26 250084.18\nDeg. of Freedom         2   2999997\n\nResidual standard error: 0.2887239\nEstimated effects may be unbalanced\n\n\n\nTukeyHSD(res)\n\n  Tukey multiple comparisons of means\n    95% family-wise confidence level\n\nFit: aov(formula = value ~ group, data = d)\n\n$group\n               diff           lwr          upr     p adj\ng2-g1  6.323640e-06 -0.0009508062 0.0009634535 0.9998678\ng3-g1 -6.209978e-04 -0.0015778637 0.0003358682 0.2809772\ng3-g2 -6.273214e-04 -0.0015842458 0.0003296030 0.2738465\n\n\nhttps://statsandr.com/blog/anova-in-r/ https://www.sthda.com/english/wiki/one-way-anova-test-in-r",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Пакет `stats`</span>"
    ]
  },
  {
    "objectID": "r/tools/plot/plotly.html",
    "href": "r/tools/plot/plotly.html",
    "title": "Приложение E — Графическая библиотека plotly",
    "section": "",
    "text": "E.1 Установка\nНазвания графиков рекомендуется добавлять с помощью (Глава 4.1.6).",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Графическая библиотека plotly</span>"
    ]
  },
  {
    "objectID": "r/tools/plot/plotly.html#sec-r-tools-plotly-install",
    "href": "r/tools/plot/plotly.html#sec-r-tools-plotly-install",
    "title": "Приложение E — Графическая библиотека plotly",
    "section": "",
    "text": "```{r}\ninstall.packages('plotly')\n```\n\n\n\n\n\n\nСовет\n\n\n\nЕсли график строится успешно, то рекомендуется игнорировать сообщения и предупреждения с помощью message и warning см Глава 4.1.4\n```{r}\n#| warning: false\n#| message: false\n```\n\n\n\n\n\n\n\n\nВажное уведомление\n\n\n\nДля отображения графика во всех примерах требуется удалить последнее применение функции |&gt; pshow(). Например Пример E.1\n```{r}\nlibrary(plotly)\nx &lt;- seq(0, 2*pi, length.out=100)\ny &lt;- sin(x)           \nplot_ly(x = x, y = y,\n        type = 'scatter',\n        mode = 'lines') |&gt;\n        pshow()\n```\nДолжно стать\n```{r}\nlibrary(plotly)\nx &lt;- seq(0, 2*pi, length.out=100)\ny &lt;- sin(x)           \nplot_ly(x = x, y = y,\n        type = 'scatter',\n        mode = 'lines')\n```",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Графическая библиотека plotly</span>"
    ]
  },
  {
    "objectID": "r/tools/plot/plotly.html#sec-r-tools-plotly-line2d",
    "href": "r/tools/plot/plotly.html#sec-r-tools-plotly-line2d",
    "title": "Приложение E — Графическая библиотека plotly",
    "section": "E.2 2D График",
    "text": "E.2 2D График\n\nПример E.1 (Явные вычисления)  \n\nlibrary(plotly)\n1x &lt;- seq(0, 2*pi, length.out=100)\n2y &lt;- sin(x)\n3plot_ly(x = x, y = y,\n4        type = 'scatter',\n5        mode = 'lines') |&gt;\n  pshow()          \n\n\n1\n\nИспользуя функцию base::seq() создаём вектор x из 100 точек от \\(0\\) до \\(2\\pi\\).\n\n2\n\nПолучаем вектор y применяя функцию base::sin() к вектору x Глава 6.9\n\n3\n\nВызываем функцию plotly::plot_ly() определяя и передаем данные явным образом Глава 6.12.5.2\n\n4\n\nПараметр type = 'scatter' определяет тип графика: по точкам.\n\n5\n\nПараметр mode = 'lines' определяет тип отображения непрерывной линией\n\n\n\n\n\n\n\n\n\n\nПример E.2 (Неявные вычисления через объект формулы) Предыдущий пример можно упростить использовав специфичную для языка r синтаксическую конструкцию объекта формулы ?sec-r-lang-advanced-formula . Такой подход применяется если зависимость \\(y=f(x)\\) простая и встречается в коде только один раз.\n\nlibrary(plotly)\n1x &lt;- seq(0, 2*pi, length.out=100)\n2plot_ly(x = x,\n3        y = ~sin(x),\n4        type = 'scatter', mode = 'lines') |&gt;\n  pshow()                                  \n\n\n1\n\nИспользуя функцию base::seq() создаём вектор x из 100 точек от \\(0\\) до \\(2\\pi\\)\n\n2\n\nПервый аргумент x передаём явным образом.\n\n3\n\nВместо явного задания вектора y передаём в аргумент формулу ~sin(x).\n\n4\n\nОпределяем параметры отображения\n\n\n\n\n\n\n\n\n\n\nПример E.3 (Добавить маркеры)  \n\nlibrary(plotly)\n1x &lt;- seq(0, 2*pi, length.out=10)\n2plot_ly(x = x, y = ~sin(x),\n3        type = 'scatter',\n4        mode = 'lines + markers') |&gt;\n  pshow()\n\n\n1\n\nИспользуя функцию base::seq() создаём вектор x из 10 точек от \\(0\\) до \\(2\\pi\\)\n\n2\n\nПередаём данные\n\n3\n\nИспользуя тип графика по точкам\n\n4\n\nДля отображения маркеров используется параметр mode = lines + markers.\n\n\n\n\n\n\n\n\n\n\nПример E.4 (Объединить графики)  \n\nlibrary(plotly)\n1x &lt;- seq(0, 2*pi, length.out=100)\n2plot_ly(x = x, y = ~sin(x), type = 'scatter', mode = 'lines',\n3        name = 'sin(x)') |&gt;\n4  add_trace(x = x, y = ~cos(x), type = 'scatter', mode = 'lines',\n5            name = 'cos') |&gt;\n  pshow()                                                \n\n\n1\n\nИспользуя функцию base::seq() создаём вектор x из 100 точек от \\(0\\) до \\(2\\pi\\)\n\n2\n\nПередаём данные как в примерах выше\n\n3\n\nНазвание перовй линии определяется параметром name = 'sin(x)'. Полученная фигура передаётся в функцию plotly::add_trace() с помощью оператора конвейера ?sec-r-tools-basic-pipe.\n\n4\n\nПараметры plotly::add_trace() аналогичны параметрам plot_ly().\n\n5\n\nНазвание второй линии определяется параметром name = 'cos(x)'.",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Графическая библиотека plotly</span>"
    ]
  },
  {
    "objectID": "r/tools/plot/plotly.html#sec-r-tools-plotly-surface3d",
    "href": "r/tools/plot/plotly.html#sec-r-tools-plotly-surface3d",
    "title": "Приложение E — Графическая библиотека plotly",
    "section": "E.3 3D Поверхность",
    "text": "E.3 3D Поверхность\nОдин из способ построить 3D график это сгенерировать сетку точек в виде матрицы значений \\(z=f(x,y)\\).\n\nПример E.5 (Без масштаба осей) Общий вид графика сохраняется, однако вместо значений по осям x и y будет отложено количество точек, использованное для построения.\n\n1x &lt;- y &lt;- seq(0, pi/2, length.out = 100)\n2z &lt;- outer(x, y,\n3           \\(x,y) { sin(x*y) })  |&gt;\n4  t()\n\n5plot_ly(z = z,\n6        type = \"surface\") |&gt;\n  pshow() \n\n\n1\n\nИспользуя функцию base::seq() создаём вектор x из 100 точек от \\(0\\) до \\(\\frac{\\pi}{2}\\).\n\n2\n\nС помощью функции base::outer() ?sec-r-tools-basic-outer генерируем матрицу Глава 6.5 размером 100x100\n\n3\n\nДля каждой комбинации x,y будет вызвана переданная лямбда функция ?sec-r-lang-advanced-lambda . Матрица передаётся с помощью оператора конвейера ?sec-r-tools-basic-pipe в функцию транспонирования base::t().\n\n4\n\nМатрица транспонируется base::t() для соответствия осей матрицы осям графика.\n\n5\n\nПередаём для построения только z.\n\n6\n\nИспользуется тип графика поверхность.\n\n\n\n\n\n\n\n\n\n\nПример E.6 (С масштабом осей)  \n\n1x &lt;- y &lt;- seq(0, pi/2, length.out = 100)\n2z &lt;- outer(x, y,\n3           \\(x,y) { sin(x*y) })  |&gt;\n4  t()\n\n5plot_ly(z = z, x = x, y = y,\n6        type = \"surface\") |&gt;\n  pshow()                                \n\n\n1\n\nИспользуя функцию base::seq() создаём вектор x из 100 точек от \\(0\\) до \\(\\frac{\\pi}{2}\\).\n\n2\n\nС помощью функции base::outer() ?sec-r-tools-basic-outer генерируем матрицу Глава 6.5 размером 100x100\n\n3\n\nДля каждой комбинации x,y будет вызвана переданная лямбда функция ?sec-r-lang-advanced-lambda . Матрица передаётся с помощью оператора конвейера ?sec-r-tools-basic-pipe в функцию транспонирования base::t().\n\n4\n\nМатрица транспонируется base::t() для соответствия осей матрицы осям графика.\n\n5\n\nПередаём данные для построения, кроме z ещё и x с y.\n\n6\n\nИспользуется тип графика поверхность.",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Графическая библиотека plotly</span>"
    ]
  },
  {
    "objectID": "r/tools/plot/plotly.html#sec-r-tools-plotly-contour2d",
    "href": "r/tools/plot/plotly.html#sec-r-tools-plotly-contour2d",
    "title": "Приложение E — Графическая библиотека plotly",
    "section": "E.4 2D Контурный график",
    "text": "E.4 2D Контурный график\nКонтурные графики позволяют изображать 3D-данные на 2D-графиках. Каждый контур представляет одно значение z.\n\nПример E.7 (Без масштаба осей) Общий вид графика сохраняется, однако вместо значений по осям x и y будет отложено количество точек, использованное для построения.\n\n1x &lt;- y &lt;- seq(0, pi/2, length.out = 100)\n2z &lt;- outer(x, y,\n3           \\(x,y) { sin(x*y) })|&gt;\n4  t()\n\n5plot_ly(z = z,\n6        type='contour') |&gt;\n  pshow() \n\n\n1\n\nИспользуя функцию base::seq() создаём вектор x из 100 точек от \\(0\\) до \\(\\frac{\\pi}{2}\\).\n\n2\n\nС помощью функции base::outer() ?sec-r-tools-basic-outer генерируем матрицу Глава 6.5 размером 100x100\n\n3\n\nДля каждой комбинации x,y будет вызвана переданная лямбда функция ?sec-r-lang-advanced-lambda . Матрица передаётся с помощью оператора конвейера ?sec-r-tools-basic-pipe в функцию транспонирования base::t().\n\n4\n\nМатрица транспонируется base::t() для соответствия осей матрицы осям графика.\n\n5\n\nПередаём данные для построения.\n\n6\n\nИспользуется тип графика контурный.\n\n\n\n\n\n\n\n\n\n\nПример E.8 (С масштабом осей)  \n\n1x &lt;- y &lt;- seq(0, pi/2, length.out = 100)\n2z &lt;- outer(x, y,\n3           \\(x,y) { sin(x*y) })|&gt;\n4  t()\n\n5plot_ly(x = x, y = y, z = z,\n6        type='contour') |&gt;\n  pshow()                               \n\n\n1\n\nИспользуя функцию base::seq() создаём вектор x из 100 точек от \\(0\\) до \\(\\frac{\\pi}{2}\\).\n\n2\n\nС помощью функции base::outer() ?sec-r-tools-basic-outer генерируем матрицу Глава 6.5 размером 100x100\n\n3\n\nДля каждой комбинации x,y будет вызвана переданная лямда функция ?sec-r-lang-advanced-lambda . Матрица передаётся с помощью оператора конвейера ?sec-r-tools-basic-pipe в функцию транспонирования base::t().\n\n4\n\nМатрица транспонируется base::t() для соответствия осей матрицы осям графика.\n\n5\n\nПередаём данные для построения, кроме z ещё и x с y.\n\n6\n\nИспользуется тип графика контурный.",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Графическая библиотека plotly</span>"
    ]
  },
  {
    "objectID": "r/tools/plot/plotly.html#sec-r-tools-plotly-slice3d",
    "href": "r/tools/plot/plotly.html#sec-r-tools-plotly-slice3d",
    "title": "Приложение E — Графическая библиотека plotly",
    "section": "E.5 3D График плотности срезов",
    "text": "E.5 3D График плотности срезов\nСоздаёт контурный график по поверхности среза как функцию \\(u=f(x,y,z)\\).\n\nlibrary(plotly)\n\n1f &lt;- \\(x,y,z) x^2-5*y^2-3*z^2+x*y-2*x*z+2*y*z+11*x+2*y+18*z+10\n2x &lt;- y &lt;- z &lt;- seq(-5, 5, length.out = 20)\n3d &lt;- tidyr::crossing(x = x, y = y, z = z)\n4u &lt;- purrr::pmap_dbl(d,f)\n\n5plot_ly(data = d,\n6  type='isosurface',\n7  x = ~x, y = ~y, z = ~z,\n8  value = u,\n9  isomin = -100, isomax = 100,\n10  colorscale='RdBu',\n11  surface = list(show = TRUE, count = 1),\n12  slices = list(z = list(show = TRUE, locations = -5:5),\n13                y = list(show = TRUE, locations = 0)),\n14  caps = list(x = list(show = FALSE),\n15              y = list(show = FALSE))) |&gt;\n  pshow_protected()\n\n\n1\n\nЗадаём функцию \\(u=f(x,y,z)\\) с помощью лямда функции ?sec-r-lang-advanced-lambda.\n\n2\n\nИспользуя функцию base::seq() создаём вектора x,y,z из \\(20\\) точек от \\(-5\\) до \\(5\\).\n\n3\n\nС помощью функции ?sec-r-tools-tidyr-crossing генерируем датафрейм ?sec-r-tools-tibble размером 20x20x20 в котором будут все комбинации значений переменных x, y и z.\n\n4\n\nПрименяем функцию f к каждой строке датафрейма d с помощью функции purrr::pmap_dbl() ?sec-r-tools-purrr-pmap в результате получаем вектор u, который содержит значения функции для всех точек её области определения.\n\n5\n\nВызываем функцию построения графика plotly::plot_ly() и передаём туда датафрейм с координатами точек построения.\n\n6\n\nОпределяем тип графика контурные поверхности\n\n7\n\nС помощью формул ?sec-r-lang-advanced-formula показываем от каких переменных из датафрейма зависят оси.\n\n8\n\nПередаём вектор со значениями функции\n\n9\n\nОпределяем минимальное и максимальное значение u для отрисовки контурных линий.\n\n10\n\nВыбираем нестандартную цветовую палитру для лучшей визуализации.\n\n11\n\nДобавляем на график одну поверхность соответствующую уравнению \\(u=f(x,y,z)=const\\)\n\n12\n\nДобавляем 5 срезы по оси z от \\(-5\\) до \\(5\\) с шагом \\(1\\)\n\n13\n\nДобавляем один срез по оси y\n\n14\n\nОтключаем отображение координатной сетки по оси x\n\n15\n\nОтключаем отображение координатной сетки по оси y",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Графическая библиотека plotly</span>"
    ]
  },
  {
    "objectID": "r/tools/plot/plotly.html#sec-r-tools-plotly-combine",
    "href": "r/tools/plot/plotly.html#sec-r-tools-plotly-combine",
    "title": "Приложение E — Графическая библиотека plotly",
    "section": "E.6 Комбинированные графики",
    "text": "E.6 Комбинированные графики\nМожно добавлять элементы на график последовательно отображая их.\n\nlibrary(plotly)\nx &lt;- y &lt;- seq(0, pi/2, length.out = 100)\nz &lt;- outer(x, y, \\(x,y) { sin(x*y) })|&gt;t()\n\nfig &lt;- plot_ly(x = x, y = y, z = z, type='contour')\nfig |&gt; pshow()\n\n\n\n\n\nТеперь добавим линию\n\nfig &lt;- fig |&gt; add_trace(x = x,\n                        y = ~cos(x),\n                        type = 'scatter',\n                        mode = 'lines', \n                        name = 'cos')\nfig |&gt; pshow_protected()\n\n\n\n\n\n\nИ выделим точки на этой линии\n\nfig &lt;- fig |&gt; \n  add_trace(x = c(0.4, 0.6, 1),\n            y = cos(c(0.4,0.6,1)),\n            type = 'scatter',\n            mode = 'markers',\n            name = 'points',\n              marker = list(color = 'red'))\nfig |&gt; pshow_protected()",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Графическая библиотека plotly</span>"
    ]
  },
  {
    "objectID": "r/tools/plot/plotly.html#sec-r-tools-plotly-extra",
    "href": "r/tools/plot/plotly.html#sec-r-tools-plotly-extra",
    "title": "Приложение E — Графическая библиотека plotly",
    "section": "E.7 Дополнительные возможности",
    "text": "E.7 Дополнительные возможности",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Графическая библиотека plotly</span>"
    ]
  },
  {
    "objectID": "r/tools/solver/linear/lpsolve.html",
    "href": "r/tools/solver/linear/lpsolve.html",
    "title": "Приложение G — Решатель LPSolve",
    "section": "",
    "text": "G.1 lpSolve",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>Решатель LPSolve</span>"
    ]
  },
  {
    "objectID": "r/tools/solver/linear/lpsolve.html#sec-r-tools-solver-linear-lpsolve-lpsolve",
    "href": "r/tools/solver/linear/lpsolve.html#sec-r-tools-solver-linear-lpsolve-lpsolve",
    "title": "Приложение G — Решатель LPSolve",
    "section": "",
    "text": "G.1.1 Установка\n\n\n\n\n\n\nВажное уведомление\n\n\n\nУбедитесь в том, что Rtools установлены в системе Глава 1.2\n\n\n```{r}\ninstall.packages('lpSolve')\n```\n\n\nG.1.2 Модель\nНа основе примера Пример G.1. Для начала требуется определить целевую функцию \\(\\mathrm{Z}\\). В пакете lpsolve целевая функция задается как вектор Глава 6.3 коэффициентов.\n\nZ &lt;- c(11, 5, 4)\n\nОграничения задаются в виде матрицы коэффициентов \\(\\mathbf{A}\\). Пакет может работать с общей формулировкой задачи Глава 1 поэтому приведение к стандартной форме не требуется\n\nA &lt;- rbind(c(3, 2, 8),\n           c(2, 0, 1),\n           c(3, 3, 1))\n\n\n\n\n\n\n\nСовет\n\n\n\nЕсли требуется задать ограничения вида \\(x_i\\leq b_i, \\quad \\forall x_i\\) то рекомендуется задать коэффициенты матрицы \\(\\mathbf{A}\\) ограничений (единичную матрицу Определение 7.6) с помощью функции функцию base::diag(). Например\n\ndiag(3)\n\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n[3,]    0    0    1\n\n\n\n\nПравые части и знаки ограничений задаются отдельно\n\nB &lt;- c(11, 5, 13)\nS &lt;- c('&lt;=', '&lt;=', '&lt;=')\n\n\n\n\n\n\n\nСовет\n\n\n\nЕсли требуется задать много однотипных ограничен рекомендуемый применить функцию base::rep() . Например {r} B &lt;- rep('&lt;=', 10).\n\n\n\n\nG.1.3 Решение\nДля поиска решения вызывается функция lpSolve::lp()\n\nlibrary(lpSolve)\n\noptimum &lt;- lp(           \n1  direction = 'max',\n2  objective.in = Z,\n3  const.mat = A,\n4  const.dir = S,\n5  const.rhs = B,\n6  compute.sens = TRUE)\noptimum\n\n\n1\n\nЗадать направление оптимизации: максимизацию 'max' или минимизацию 'min'\n\n2\n\nЗадать целевую (objective) функцию вектором коэффициентов.\n\n3\n\nЗадать матрицу коэффициентов ограничений.\n\n4\n\nЗадать знаки ограничений символьным вектором\n\n5\n\nЗадать вектор правых частей ограничений.\n\n6\n\nДополнительно рассчитать чувствительность оптимального решения\n\n\n\n\nSuccess: the objective function is 36.25 \n\n\nМаксимальное значение целевой функции получается\n\noptimum$objval\n\n[1] 36.25\n\n\nЭто значение достигается при следующих значения переменных. Его можно получить из объекта решения optimum по ключу solution\n\noptimum$solution\n\n[1] 2.50 1.75 0.00\n\n\n\n\n\n\n\n\nСовет\n\n\n\nЕсли в задаче много переменных, то иногда бывает трудно определить какие из них приняли ненулевые значения. Отображения результатов можно упростить используя функцию base::which()\nНапример\n\nx &lt;- c(0,1,2,0,4,5,0,6,8,0,0,1)\nx\n\n [1] 0 1 2 0 4 5 0 6 8 0 0 1\n\n\nУзнать индексы ненулевых элементов\n\nind &lt;- which(x!=0)\nind\n\n[1]  2  3  5  6  8  9 12\n\n\nИ вывести только ненулевые элементы\n\nx[ind]\n\n[1] 1 2 4 5 6 8 1\n\n\n\n\n\n\nG.1.4 Анализ чувствительности оптимального решения\n\nЦелевой функции\nДиапазон в кортом можно изменять коэффициенты целевой функции ?sec-linear-simplex-sensetivity-objective не меняя при этом характер решения (точку, соответствующую оптимальному решению) можно определить следующим образом\n\noptimum$sens.coef.from\n\n[1]  7.5e+00  0.0e+00 -1.0e+30\n\noptimum$sens.coef.to\n\n[1] 1.000000e+30 7.333333e+00 2.175000e+01\n\n\nСоответственно точка \\(( 2.5,1.75,0 )\\) соответствующая оптимальному решению не сдвинется, если по одному изменять коэффициенты в следующих пределах\n\\[\n\\begin{aligned}\n&7.5  \\leq c_1 \\leq 10^{30}\\\\\n&0  \\leq c_2 \\leq 7.3333333\\\\\n&-10^{30}  \\leq c_3 \\leq 21.75\n\\end{aligned}\n\\]\n\n\nОграничений\nКоэффициенты чувствительности по ограничениям ?sec-linear-simplex-sensetivity-constraint (также встречается название двойственные значения).\n\noptimum$duals\n\n[1]   2.50   1.75   0.00   0.00   0.00 -17.75\n\n\nЭто значение показывает как измениться целевая функция при изменении правой части ограничения на единицу.\nНапример значение целевой функции измениться с \\(36.25\\) на \\(38.75\\) (шаг \\(2.5\\)) при изменении ограничения \\(3x_1+2x_2+8x_3 \\leq 11\\) на ограничение \\(3x_1+2x_2+8x_3 \\leq 12\\).\nОбратите внимание, количество двойственных значений гораздо больше, чем количество ограничений, которые были заданы в задаче изначально. Дело в том, что пакет неявным образом добавляет в модель ограничения вида \\(x_i \\geq 0 ,\\forall x_i\\), если другого не заданно. Это сделано для удобства разработчика.\nДалее определяется диапазон в котором действительно данное двойственное значение.\n\noptimum$sens.coef.from\n\n[1]  7.5e+00  0.0e+00 -1.0e+30\n\noptimum$sens.coef.from\n\n[1]  7.5e+00  0.0e+00 -1.0e+30\n\n\nТаким образом для первого ограничения \\(3x_1+2x_2+8x_3 \\leq 11\\) двойственное значение \\(2.5\\) сохраняется при изменении правой части \\(7.5 \\leq b_1 \\leq 7.5\\)\n\n\n\nG.1.5 Целочисленная модель\nДля решения задачи Пример G.1 в целых числах при построении модели добавляется параметр all.int=TRUE. В этом случае анализ чувствительности Глава G.1.4 не применим и параметр compute.sens = TRUE будет проигнорирован\n\noptimum &lt;- lp(           \n  direction = 'max',\n  objective.in = Z,\n  const.mat = A,\n  const.dir = S,\n  const.rhs = B,\n  all.int = TRUE)\noptimum\n\nSuccess: the objective function is 32 \n\noptimum$solution\n\n[1] 2 2 0\n\n\nАналогично для решения задачи двоичного программирования устанавливается параметр all.bin=TRUE\n\noptimum &lt;- lp(           \n  direction = 'max',\n  objective.in = Z,\n  const.mat = A,\n  const.dir = S,\n  const.rhs = B,\n  all.bin = TRUE)\noptimum\n\nSuccess: the objective function is 16 \n\noptimum$solution\n\n[1] 1 1 0\n\n\nЗадача целочисленного и двоичного программирования в пакете lpSolve решается методом ветвей и границ Глава 11.1.",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>Решатель LPSolve</span>"
    ]
  },
  {
    "objectID": "r/tools/solver/linear/lpsolve.html#sec-r-tools-solver-linear-lpsolve-lpsolveapi",
    "href": "r/tools/solver/linear/lpsolve.html#sec-r-tools-solver-linear-lpsolve-lpsolveapi",
    "title": "Приложение G — Решатель LPSolve",
    "section": "G.2 lpSolveAPI",
    "text": "G.2 lpSolveAPI\n\nG.2.1 Установка\n\n\n\n\n\n\nВажное уведомление\n\n\n\nУбедитесь в том, что Rtools установлены в системе Глава 1.2\n\n\n```{r}\ninstall.packages('lpSolveAPI')\n```\n\n\nG.2.2 Модель\nНа основе примера Пример G.1 создаём объект модели задачи линейного программирования lpSolveAPI::make.lp() с 3 переменными и 0 ограничений (будут добавлены позднее).\n\nlibrary(lpSolveAPI)\nlprob &lt;- make.lp(0, 3)\n\nДалее выбирается тип оптимизации lpSolveAPI::lp.control(), в данном случае максимизация. Вывод функции подавляется с помощью base::invisible(), чтобы отменить печать информации на экран.\n\ninvisible(lp.control(lprob, sense = 'max'))\n\nДалее задаются ограничения. Ограничения матрицы \\(\\mathbf{A}\\) вводятся построчно lpSolveAPI::add.constraint(). По умолчанию на переменные накладывается условие \\(\\forall{i}: x_i\\geq0\\)\n\nadd.constraint(lprob, c(3, 2, 8), '&lt;=', 11)\nadd.constraint(lprob, c(2, 0, 1), '&lt;=', 5)\nadd.constraint(lprob, c(3, 3, 1), '&lt;=', 13)\n\nЗадание целевой функции lpSolveAPI::set.objfn(). Объект модели можно конструировать в произвольном порядке\n\nset.objfn(lprob, c(11, 5, 4))\n\nИтоговое представление модели можно получить вызвав объект модели\n\nlprob\n\nModel name: \n            C1    C2    C3        \nMaximize    11     5     4        \nR1           3     2     8  &lt;=  11\nR2           2     0     1  &lt;=   5\nR3           3     3     1  &lt;=  13\nKind       Std   Std   Std        \nType      Real  Real  Real        \nUpper      Inf   Inf   Inf        \nLower        0     0     0        \n\n\n\n\nG.2.3 Решение\nДалее вызовом lpSolveAPI::solve() полученная модель решается. В случае успеха возвращается status_code == 0\n\nstatus_code &lt;- solve(lprob)\nstatus_code\n\n[1] 0\n\n\nНаилучшее значение целевой функции lpSolveAPI::get.objective()\n\nget.objective(lprob)\n\n[1] 36.25\n\n\nЗначение переменных, при которых достигнуто максимальное значение целевой функции lpSolveAPI::get.variables()\n\nget.variables(lprob)\n\n[1] 2.50 1.75 0.00\n\n\n\n\nG.2.4 Анализ чувствительности оптимального решения\n\nЦелевая функция\nПолучим список с двумя ключами objfrom и objtill с помощью функции lpSolveAPI::get.sensitivity.obj()\n\nget.sensitivity.obj(lprob)\n\n$objfrom\n[1]  7.5e+00  0.0e+00 -1.0e+30\n\n$objtill\n[1] 1.000000e+30 7.333333e+00 2.175000e+01\n\n\nСоответственно точка \\(( 2.5,1.75,0 )\\) соответствующая оптимальному решению не сдвинется, если по одному изменять коэффициенты в следующих пределах\n\\[\n\\begin{aligned}\n&7.5  \\leq c_1 \\leq 10^{30}\\\\\n&0  \\leq c_2 \\leq 7.3333333\\\\\n&-10^{30}  \\leq c_3 \\leq 21.75\n\\end{aligned}\n\\]\n\n\nОграничения\nДля анализа чувствительности ограничений применяется функция lpSolveAPI::get.sensitivity.rhs().\n\nget.sensitivity.rhs(lprob)\n\n$duals\n[1]   2.50   1.75   0.00   0.00   0.00 -17.75\n\n$dualsfrom\n[1]  7.500000e+00  4.666667e+00 -1.000000e+30 -1.000000e+30 -1.000000e+30\n[6] -2.439024e-02\n\n$dualstill\n[1] 1.116667e+01 7.333333e+00 1.000000e+30 1.000000e+30 1.000000e+30\n[6] 5.384615e-01\n\n\nЭто значение показывает как измениться целевая функция при изменении правой части ограничения на единицу.\nНапример значение целевой функции измениться с \\(36.25\\) на \\(38.75\\) (шаг \\(2.5\\)) при изменении ограничения \\(3x_1+2x_2+8x_3 \\leq 11\\) на ограничение \\(3x_1+2x_2+8x_3 \\leq 12\\).\nОбратите внимание, количество двойственных значений гораздо больше, чем количество ограничений, которые были заданы в задаче изначально. Дело в том, что пакет неявным образом добавляет в модель ограничения вида \\(x_i \\geq 0 ,\\forall x_i\\), если другого не заданно. Это сделано для удобства разработчика.\nТаким образом для первого ограничения \\(3x_1+2x_2+8x_3 \\leq 11\\) двойственное значение \\(2.5\\) сохраняется при изменении правой части \\(7.5 \\leq b_1 \\leq 11.1666667\\)\nset.objfn(LP, c(-mat[, 'score'], 0, 0))\nset.type(LP, n+1, \"binary\")\nset.type(LP, n+2, \"binary\")\nset.bounds(LP, lower = c(mat[, 'lb'], 0, 0))\nset.bounds(LP, upper = c(mat[, 'ub'], 1, 1))",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>Решатель LPSolve</span>"
    ]
  },
  {
    "objectID": "r/tools/solver/nonlinear/nloptr/analysis.html",
    "href": "r/tools/solver/nonlinear/nloptr/analysis.html",
    "title": "Приложение I — Nloptr. Анализ",
    "section": "",
    "text": "I.1 Подготовка\nПроцедура анализа построена на возможностях библиотеки Приложение C по подсчёту и логированию вызовов целевой функции.\nЗададим целевую функцию\nf &lt;- function(par)\n{\n  x &lt;- par[[1]]\n  y &lt;- par[[2]]\n  (x-1)^2 + (y-1)^2 + atan( (x-1)^2 * (y-2)^2 )^2\n}\nТакже для решателю могут быть переданы градиент\nf_g &lt;- function(par)\n{\n  x &lt;- par[[1]]\n  y &lt;- par[[2]]\n  \n  dx &lt;- 2*(-1 + x + ((-2 + y)^2*atan((1 + x)*(-2 + y)^2))/(1 + (1 + x)^2*(-2 + y)^4))\n  dy &lt;- 2*(1 + y + (2*(1 + x)*(-2 + y)*atan((1 + x)*(-2 + y)^2))/(1 + (1 + x)^2*(-2 + y)^4))\n  \n  c(dx,dy)\n}\nЗададим область прямоугольных ограничений для задчи выбранных произвольно от -5 до 5 по двум осям.\npar &lt;- ParamHelpers::makeNumericParamSet(\n    len = 2L,\n    lower = c(-5, -5),\n    upper = c(5, 5))\n\nobjfn &lt;- smoof::makeSingleObjectiveFunction(\n  fn = f,\n  par.set = par)\n\nobjfn_g &lt;- smoof::makeMultiObjectiveFunction(\n  fn = f_g,\n  par.set = par,\n  n.objectives = 2)\nПреобразуем ограничения к форме, принимаемой методом\n\\[\ny^2 - x^2 + 1 \\leq 0 \\\\\n\\]\nconstr_ineq &lt;- function(par)\n{\n  x &lt;- par[[1]]\n  y &lt;- par[[2]]\n  \n  y^2 - x^2 + 1\n}\nА также якобиан ограничений.\nconstr_ineq_jac &lt;- function(par)\n{\n  x &lt;- par[[1]]\n  y &lt;- par[[2]]\n  \n  c(-2*x,2*y)\n}\nИ их обёртки\nconstr_ineq_fn &lt;- smoof::makeMultiObjectiveFunction(\n  fn = constr_ineq,\n  par.set = par,\n  n.objectives = 2)\n\nconstr_ineq_jac_fn &lt;- smoof::makeMultiObjectiveFunction(\n  fn = constr_ineq_jac,\n  par.set = par,\n  n.objectives = 4)\nЗададим стартовую точку\nx0 &lt;- c(-4,2)\nИ определим функцию для отрисовки ограничений\nadd_constr &lt;- function(fig)\n{\n  xm &lt;- seq(-5, 1, length.out = 50) # отрицательная кривая\n  ymm &lt;- -sqrt(-1 + xm^2) # отрицательная ветвь\n  ymp &lt;- sqrt(-1 + xm^2) # положительная ветвь\n  \n  xp &lt;- seq(1, 5, length.out = 50)\n  ypm &lt;- -sqrt(-1 + xp^2) # отрицательная ветвь\n  ypp &lt;- sqrt(-1 + xp^2) # положительная ветвь\n  \n  purrr::reduce2(\n    list(xm, xm, xp, xp),\n    list(ymm, ymp, ypm, ypp),\n    \\(fig, x, y) plotly::add_trace(\n      fig,\n      x = x,\n      y = y,\n      type = \"scatter\",\n      mode = 'lines'\n    ) ,\n    .init = fig) |&gt;\n    pshow_safe()\n}",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>I</span>  <span class='chapter-title'>Nloptr. Анализ</span>"
    ]
  },
  {
    "objectID": "r/tools/solver/nonlinear/nloptr/analysis.html#sec-r-tools-solver-nonlinear-nloptr-assigment",
    "href": "r/tools/solver/nonlinear/nloptr/analysis.html#sec-r-tools-solver-nonlinear-nloptr-assigment",
    "title": "Приложение I — Nloptr. Анализ",
    "section": "",
    "text": "Важное уведомление\n\n\n\nПри использовании удалите вызов функции pshow()",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>I</span>  <span class='chapter-title'>Nloptr. Анализ</span>"
    ]
  },
  {
    "objectID": "r/tools/solver/nonlinear/nloptr/analysis.html#sec-r-tools-solver-nonlinear-nloptr-analysis-helper",
    "href": "r/tools/solver/nonlinear/nloptr/analysis.html#sec-r-tools-solver-nonlinear-nloptr-analysis-helper",
    "title": "Приложение I — Nloptr. Анализ",
    "section": "I.2 Загрузка вспомогательных функций",
    "text": "I.2 Загрузка вспомогательных функций\n\nsource('../../../../helper/sample.R')\nsource('../../../../helper/plotly.R')\nsource('../../../../helper/smoof.R')\nsource('../../../../helper/smoof_plotly.R')\nsource('../../../../helper/nloptr.R')\n\n\n\n\n\n\n\n⤓ sample.R\n⤓ plotly.R\n⤓ smoof.R\n⤓ smoof_plotly.R\n⤓ nloptr.R",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>I</span>  <span class='chapter-title'>Nloptr. Анализ</span>"
    ]
  },
  {
    "objectID": "r/tools/solver/nonlinear/nloptr/analysis.html#sec-r-tools-solver-nonlinear-nloptr-analysis-solution",
    "href": "r/tools/solver/nonlinear/nloptr/analysis.html#sec-r-tools-solver-nonlinear-nloptr-analysis-solution",
    "title": "Приложение I — Nloptr. Анализ",
    "section": "I.3 Решение задачи",
    "text": "I.3 Решение задачи\nРешим задачу методом Глава K.2.2\n\nres &lt;- nloptr::nloptr(\n  x0 = x0,\n  eval_f = f,\n  eval_grad_f = f_g,\n  eval_g_ineq = constr_ineq,\n  eval_jac_g_ineq = constr_ineq_jac,\n  opts = list(\n    algorithm = 'NLOPT_LD_CCSAQ',\n    xtol_rel = 1.0e-8\n  )\n)\n\nres\n\n\nCall:\n\nnloptr::nloptr(x0 = x0, eval_f = f, eval_grad_f = f_g, eval_g_ineq = constr_ineq, \n    eval_jac_g_ineq = constr_ineq_jac, opts = list(algorithm = \"NLOPT_LD_CCSAQ\", \n        xtol_rel = 1e-08))\n\n\nMinimization using NLopt version 2.10.0 \n\nNLopt solver status: 4 ( NLOPT_XTOL_REACHED: Optimization stopped because \nxtol_rel or xtol_abs (above) was reached. )\n\nNumber of Iterations....: 43 \nTermination conditions:  xtol_rel: 1e-08 \nNumber of inequality constraints:  1 \nNumber of equality constraints:    0 \nOptimal value of objective function:  7.82688736492515 \nOptimal value of controls: -1.019588 -0.1988947\n\n\nА также получим данные анализа работы алгоритма с помощью функции nloptr_trace из вспомогательного файла nloptr.R.\n\ntrace &lt;- nloptr_trace(\n  x0 = x0,\n  eval_f = objfn,\n  eval_grad_f = objfn_g,\n  eval_g_ineq = constr_ineq_fn,\n  eval_jac_g_ineq = constr_ineq_jac_fn,\n  opts = list(\n    algorithm = 'NLOPT_LD_CCSAQ',\n    xtol_rel = 1.0e-8\n  )\n)",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>I</span>  <span class='chapter-title'>Nloptr. Анализ</span>"
    ]
  },
  {
    "objectID": "r/tools/solver/nonlinear/nloptr/analysis.html#sec-r-tools-solver-nonlinear-nloptr-analysis-graphical",
    "href": "r/tools/solver/nonlinear/nloptr/analysis.html#sec-r-tools-solver-nonlinear-nloptr-analysis-graphical",
    "title": "Приложение I — Nloptr. Анализ",
    "section": "I.4 Графический анализ",
    "text": "I.4 Графический анализ\n\n```{r}\n#| label: graphical-contour\n\nfig &lt;- smoof_pcontour(objfn, 50) \n```\n\n\n```{r}\n#| label: graphical-eval-obj\n#| message: false\n#| warning: false\n#| fig-cap: \"Вычисления функции\"\n\nfig |&gt;\n  padd_eval_points(uni_sample(trace$eval$eval_f, 100)) |&gt;\n  padd_start_stop_points(trace$eval$eval_f) |&gt;\n  add_constr()\n```\n\n\n\nВычисления функции\n\n\nУсики показывают направление и модуль градиента\n\n```{r}\n#| label: graphical-eval-grad\n#| message: false\n#| warning: false\n#| fig-cap: \"Вычисления градиента функции\"\n\nfig |&gt;\n  padd_eval_points(uni_sample(trace$eval$eval_grad_f, 100)) |&gt;\n  padd_start_stop_points(trace$eval$eval_grad_f) |&gt;\n  add_constr()\n```\n\n\n\nВычисления градиента функции\n\n\n\n```{r}\n#| label: graphical-eval-constr\n#| message: false\n#| warning: false\n#| fig-cap: \"Вычисления ограничений\"\n\nfig |&gt;\n  padd_eval_points(uni_sample(trace$eval$eval_g_ineq, 100)) |&gt;\n  padd_start_stop_points(trace$eval$eval_f) |&gt;\n  add_constr()\n```\n\n\n\nВычисления ограничений\n\n\n\n```{r}\n#| label: graphical-eval-constr-jac\n#| message: false\n#| warning: false\n#| fig-cap: \"Вычисления якобиана ограничений\"\n\nfig |&gt;\n  padd_eval_points(uni_sample(trace$eval$eval_jac_g_ineq, 100)) |&gt;\n  padd_start_stop_points(trace$eval$eval_f) |&gt;\n  add_constr()\n```\n\n\n\nВычисления якобиана ограничений\n\n\n\n```{r}\n#| label: graphical-path\n#| message: false\n#| warning: false\n#| fig-cap: \"Путь оптимизации\"\n\nfig |&gt;\n  padd_path_points(trace$path) |&gt;\n  padd_start_stop_points(trace$eval$eval_f) |&gt;\n  add_constr()\n```\n\n\n\nПуть оптимизации",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>I</span>  <span class='chapter-title'>Nloptr. Анализ</span>"
    ]
  },
  {
    "objectID": "r/tools/solver/nonlinear/nloptr/analysis.html#sec-r-tools-solver-nonlinear-nloptr-analysis-count",
    "href": "r/tools/solver/nonlinear/nloptr/analysis.html#sec-r-tools-solver-nonlinear-nloptr-analysis-count",
    "title": "Приложение I — Nloptr. Анализ",
    "section": "I.5 Подсчёт числа вызовов",
    "text": "I.5 Подсчёт числа вызовов\n\ntrace$count |&gt;\n  knitr::kable()\n\n\n\n\nfunc\ncount\n\n\n\n\neval_f\n45\n\n\neval_grad_f\n44\n\n\neval_g_ineq\n46\n\n\neval_jac_g_ineq\n45",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>I</span>  <span class='chapter-title'>Nloptr. Анализ</span>"
    ]
  },
  {
    "objectID": "r/tools/solver/nonlinear/nloptr/local/unconstrained.html",
    "href": "r/tools/solver/nonlinear/nloptr/local/unconstrained.html",
    "title": "Приложение J — Nloptr. Локальная безуслованя",
    "section": "",
    "text": "J.1 Прямого поиска",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>J</span>  <span class='chapter-title'>Nloptr. Локальная безуслованя</span>"
    ]
  },
  {
    "objectID": "r/tools/solver/nonlinear/nloptr/local/unconstrained.html#sec-r-tools-solver-nonlinear-nloptr-local-unconstrained-directed",
    "href": "r/tools/solver/nonlinear/nloptr/local/unconstrained.html#sec-r-tools-solver-nonlinear-nloptr-local-unconstrained-directed",
    "title": "Приложение J — Nloptr. Локальная безуслованя",
    "section": "",
    "text": "J.1.1 Метод Нелдера-Мида\n\nres &lt;- nloptr::nloptr(\n  x0 = x0,\n  eval_f = f,\n  opts = list(algorithm = 'NLOPT_LN_NELDERMEAD', xtol_rel = 1.0e-8)\n)\n\ntrace &lt;- nloptr_trace(\n  x0 = x0,\n  eval_f = objfn,\n  opts = list(algorithm = 'NLOPT_LN_NELDERMEAD', xtol_rel = 1.0e-8)\n)\nres\n\n\nCall:\n\nnloptr::nloptr(x0 = x0, eval_f = f, opts = list(algorithm = \"NLOPT_LN_NELDERMEAD\", \n    xtol_rel = 1e-08))\n\n\nMinimization using NLopt version 2.10.0 \n\nNLopt solver status: 5 ( NLOPT_MAXEVAL_REACHED: Optimization stopped because \nmaxeval (above) was reached. )\n\nNumber of Iterations....: 100 \nTermination conditions:  xtol_rel: 1e-08 \nNumber of inequality constraints:  0 \nNumber of equality constraints:    0 \nCurrent value of objective function:  -1.99999999999819 \nCurrent value of controls: -7.139153e-07 0.9999998\n\n\n\n\n\n\nВычисления функции\n\n\n\n\nПуть оптимизации\n\n\n\n\n\n\n\nfunc\ncount\n\n\n\n\neval_f\n102\n\n\n\n\n\n\n\nJ.1.2 Метод локальной вариации\nPRAXIS (PRincipal AXIS)\n\nres &lt;- nloptr::nloptr(\n  x0 = x0,\n  eval_f = f,\n  opts = list(algorithm = 'NLOPT_LN_PRAXIS', xtol_rel = 1.0e-8)\n)\n\ntrace &lt;- nloptr_trace(\n  x0 = x0,\n  eval_f = objfn,\n  opts = list(algorithm = 'NLOPT_LN_PRAXIS', xtol_rel = 1.0e-8)\n)\nres\n\n\nCall:\n\nnloptr::nloptr(x0 = x0, eval_f = f, opts = list(algorithm = \"NLOPT_LN_PRAXIS\", \n    xtol_rel = 1e-08))\n\n\nMinimization using NLopt version 2.10.0 \n\nNLopt solver status: 4 ( NLOPT_XTOL_REACHED: Optimization stopped because \nxtol_rel or xtol_abs (above) was reached. )\n\nNumber of Iterations....: 34 \nTermination conditions:  xtol_rel: 1e-08 \nNumber of inequality constraints:  0 \nNumber of equality constraints:    0 \nOptimal value of objective function:  -2 \nOptimal value of controls: 0 1\n\n\n\n\n\n\nВычисления функции\n\n\n\n\nПуть оптимизации\n\n\n\n\n\n\n\nfunc\ncount\n\n\n\n\neval_f\n38\n\n\n\n\n\n\n\nJ.1.3 BOBYQA\n\nres &lt;- nloptr::nloptr(\n  x0 = x0,\n  eval_f = f,\n  lb = smoof::getLowerBoxConstraints(objfn),\n  ub = smoof::getUpperBoxConstraints(objfn),\n  opts = list(algorithm = 'NLOPT_LN_BOBYQA', xtol_rel = 1.0e-8)\n)\n\ntrace &lt;- nloptr_trace(\n  x0 = x0,\n  eval_f = objfn,\n  lb = smoof::getLowerBoxConstraints(objfn),\n  ub = smoof::getUpperBoxConstraints(objfn),\n  opts = list(algorithm = 'NLOPT_LN_BOBYQA', xtol_rel = 1.0e-8)\n)\nres\n\n\nCall:\n\nnloptr::nloptr(x0 = x0, eval_f = f, lb = smoof::getLowerBoxConstraints(objfn), \n    ub = smoof::getUpperBoxConstraints(objfn), opts = list(algorithm = \"NLOPT_LN_BOBYQA\", \n        xtol_rel = 1e-08))\n\n\nMinimization using NLopt version 2.10.0 \n\nNLopt solver status: 4 ( NLOPT_XTOL_REACHED: Optimization stopped because \nxtol_rel or xtol_abs (above) was reached. )\n\nNumber of Iterations....: 32 \nTermination conditions:  xtol_rel: 1e-08 \nNumber of inequality constraints:  0 \nNumber of equality constraints:    0 \nOptimal value of objective function:  -2 \nOptimal value of controls: -1.378786e-10 1\n\n\n\n\n\n\nВычисления функции\n\n\n\n\nПуть оптимизации\n\n\n\n\n\n\n\nfunc\ncount\n\n\n\n\neval_f\n34",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>J</span>  <span class='chapter-title'>Nloptr. Локальная безуслованя</span>"
    ]
  },
  {
    "objectID": "r/tools/solver/nonlinear/nloptr/local/unconstrained.html#sec-r-tools-solver-nonlinear-nloptr-local-unconstrained-gradient",
    "href": "r/tools/solver/nonlinear/nloptr/local/unconstrained.html#sec-r-tools-solver-nonlinear-nloptr-local-unconstrained-gradient",
    "title": "Приложение J — Nloptr. Локальная безуслованя",
    "section": "J.2 Градиентные",
    "text": "J.2 Градиентные\n\nJ.2.1 BFGS\nНа основе метода ньютона\n\nres &lt;- nloptr::nloptr(\n  x0 = x0,\n  eval_f = f,\n  eval_grad_f = f_g,\n  opts = list(algorithm = 'NLOPT_LD_LBFGS', xtol_rel = 1.0e-8)\n)\n\ntrace &lt;- nloptr_trace(\n  x0 = x0,\n  eval_f = objfn,\n  eval_grad_f = objfn_g,\n  opts = list(algorithm = 'NLOPT_LD_LBFGS', xtol_rel = 1.0e-8)\n)\nres\n\n\nCall:\n\nnloptr::nloptr(x0 = x0, eval_f = f, eval_grad_f = f_g, opts = list(algorithm = \"NLOPT_LD_LBFGS\", \n    xtol_rel = 1e-08))\n\n\nMinimization using NLopt version 2.10.0 \n\nNLopt solver status: 1 ( NLOPT_SUCCESS: Generic success return value. )\n\nNumber of Iterations....: 5 \nTermination conditions:  xtol_rel: 1e-08 \nNumber of inequality constraints:  0 \nNumber of equality constraints:    0 \nOptimal value of objective function:  -2 \nOptimal value of controls: -2.775558e-17 1\n\n\n\n\n\n\nВычисления функции\n\n\n\n\nВычисления градиента\n\n\n\n\nПуть оптимизации\n\n\n\n\n\n\n\nfunc\ncount\n\n\n\n\neval_f\n7\n\n\neval_grad_f\n6\n\n\n\n\n\n\n\nJ.2.2 Ньютона\nPreconditioned truncated Newton\n\nres &lt;- nloptr::nloptr(\n  x0 = x0,\n  eval_f = f,\n  eval_grad_f = f_g,\n  opts = list(algorithm = 'NLOPT_LD_TNEWTON_PRECOND_RESTART', xtol_rel = 1.0e-8)\n)\n\ntrace &lt;- nloptr_trace(\n  x0 = x0,\n  eval_f = objfn,\n  eval_grad_f = objfn_g,\n  opts = list(algorithm = 'NLOPT_LD_TNEWTON_PRECOND_RESTART', xtol_rel = 1.0e-8)\n)\nres\n\n\nCall:\n\nnloptr::nloptr(x0 = x0, eval_f = f, eval_grad_f = f_g, opts = list(algorithm = \"NLOPT_LD_TNEWTON_PRECOND_RESTART\", \n    xtol_rel = 1e-08))\n\n\nMinimization using NLopt version 2.10.0 \n\nNLopt solver status: 1 ( NLOPT_SUCCESS: Generic success return value. )\n\nNumber of Iterations....: 5 \nTermination conditions:  xtol_rel: 1e-08 \nNumber of inequality constraints:  0 \nNumber of equality constraints:    0 \nOptimal value of objective function:  -2 \nOptimal value of controls: 3.719599e-10 1\n\n\n\n\n\n\nВычисления функции\n\n\n\n\nВычисления градиента\n\n\n\n\nПуть оптимизации\n\n\n\n\n\n\n\nfunc\ncount\n\n\n\n\neval_f\n7\n\n\neval_grad_f\n6\n\n\n\n\n\n\n\nJ.2.3 Varmetric\nShifted limited-memory variable-metric\n\nres &lt;- nloptr::nloptr(\n  x0 = x0,\n  eval_f = f,\n  eval_grad_f = f_g,\n  opts = list(algorithm = 'NLOPT_LD_VAR2', xtol_rel = 1.0e-8)\n)\n\ntrace &lt;- nloptr_trace(\n  x0 = x0,\n  eval_f = objfn,\n  eval_grad_f = objfn_g,\n  opts = list(algorithm = 'NLOPT_LD_VAR2', xtol_rel = 1.0e-8)\n)\nres\n\n\nCall:\n\nnloptr::nloptr(x0 = x0, eval_f = f, eval_grad_f = f_g, opts = list(algorithm = \"NLOPT_LD_VAR2\", \n    xtol_rel = 1e-08))\n\n\nMinimization using NLopt version 2.10.0 \n\nNLopt solver status: 1 ( NLOPT_SUCCESS: Generic success return value. )\n\nNumber of Iterations....: 5 \nTermination conditions:  xtol_rel: 1e-08 \nNumber of inequality constraints:  0 \nNumber of equality constraints:    0 \nOptimal value of objective function:  -2 \nOptimal value of controls: 3.330669e-16 1\n\n\n\n\n\n\nВычисления функции\n\n\n\n\nВычисления градиента\n\n\n\n\nПуть оптимизации\n\n\n\n\n\n\n\nfunc\ncount\n\n\n\n\neval_f\n7\n\n\neval_grad_f\n6",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>J</span>  <span class='chapter-title'>Nloptr. Локальная безуслованя</span>"
    ]
  },
  {
    "objectID": "r/tools/solver/nonlinear/nloptr/local/constrained/inequality.html",
    "href": "r/tools/solver/nonlinear/nloptr/local/constrained/inequality.html",
    "title": "Приложение K — Nloptr. Локальная. Ограничения неравенства",
    "section": "",
    "text": "K.1 Прямого поиска",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>K</span>  <span class='chapter-title'>Nloptr. Локальная. Ограничения неравенства</span>"
    ]
  },
  {
    "objectID": "r/tools/solver/nonlinear/nloptr/local/constrained/inequality.html#sec-r-tools-solver-nonlinear-nloptr-local-constrained-inequality-directed",
    "href": "r/tools/solver/nonlinear/nloptr/local/constrained/inequality.html#sec-r-tools-solver-nonlinear-nloptr-local-constrained-inequality-directed",
    "title": "Приложение K — Nloptr. Локальная. Ограничения неравенства",
    "section": "",
    "text": "K.1.1 COBYLA\n\nres &lt;- nloptr::nloptr(\n  x0 = x0,\n  eval_f = f,\n  eval_g_ineq = constr_ineq,\n  opts = list(\n    algorithm = 'NLOPT_LN_COBYLA',\n    xtol_rel = 1.0e-8)\n)\n\ntrace &lt;- nloptr_trace(\n  x0 = x0,\n  eval_f = objfn,\n  eval_g_ineq = constr_ineq_fn,\n  opts = list(\n    algorithm = 'NLOPT_LN_COBYLA',\n    xtol_rel = 1.0e-8)\n)\nres\n\n\nCall:\nnloptr::nloptr(x0 = x0, eval_f = f, eval_g_ineq = constr_ineq, \n    opts = list(algorithm = \"NLOPT_LN_COBYLA\", xtol_rel = 1e-08))\n\n\nMinimization using NLopt version 2.10.0 \n\nNLopt solver status: 4 ( NLOPT_XTOL_REACHED: Optimization stopped because \nxtol_rel or xtol_abs (above) was reached. )\n\nNumber of Iterations....: 86 \nTermination conditions:  xtol_rel: 1e-08 \nNumber of inequality constraints:  2 \nNumber of equality constraints:    0 \nOptimal value of objective function:  2 \nOptimal value of controls: 1 -2\n\n\n\n\n\n\nВычисления функции\n\n\n\n\n\n\nВычисления ограничений\n\n\n\n\n\n\nПуть оптимизации\n\n\n\n\n\n\n\nfunc\ncount\n\n\n\n\neval_f\n88\n\n\neval_g_ineq\n89",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>K</span>  <span class='chapter-title'>Nloptr. Локальная. Ограничения неравенства</span>"
    ]
  },
  {
    "objectID": "r/tools/solver/nonlinear/nloptr/local/constrained/inequality.html#sec-r-tools-solver-nonlinear-nloptr-local-constrained-inequality-gradient",
    "href": "r/tools/solver/nonlinear/nloptr/local/constrained/inequality.html#sec-r-tools-solver-nonlinear-nloptr-local-constrained-inequality-gradient",
    "title": "Приложение K — Nloptr. Локальная. Ограничения неравенства",
    "section": "K.2 Градиентные",
    "text": "K.2 Градиентные\n\nK.2.1 Method moving asymptotes\n\nres &lt;- nloptr::nloptr(\n  x0 = x0,\n  eval_f = f,\n  eval_grad_f = f_g,\n  eval_g_ineq = constr_ineq,\n  eval_jac_g_ineq = constr_ineq_jac,\n  opts = list(\n    algorithm = 'NLOPT_LD_MMA',\n    xtol_rel = 1.0e-8\n  )\n)\n\ntrace &lt;- nloptr_trace(\n  x0 = x0,\n  eval_f = objfn,\n  eval_grad_f = objfn_g,\n  eval_g_ineq = constr_ineq_fn,\n  eval_jac_g_ineq = constr_ineq_jac_fn,\n  opts = list(\n    algorithm = 'NLOPT_LD_MMA',\n    xtol_rel = 1.0e-8\n  )\n)\nres\n\n\nCall:\n\nnloptr::nloptr(x0 = x0, eval_f = f, eval_grad_f = f_g, eval_g_ineq = constr_ineq, \n    eval_jac_g_ineq = constr_ineq_jac, opts = list(algorithm = \"NLOPT_LD_MMA\", \n        xtol_rel = 1e-08))\n\n\nMinimization using NLopt version 2.10.0 \n\nNLopt solver status: 4 ( NLOPT_XTOL_REACHED: Optimization stopped because \nxtol_rel or xtol_abs (above) was reached. )\n\nNumber of Iterations....: 60 \nTermination conditions:  xtol_rel: 1e-08 \nNumber of inequality constraints:  2 \nNumber of equality constraints:    0 \nOptimal value of objective function:  1.99999993829419 \nOptimal value of controls: 1.000001 -2.000003\n\n\n\n\n\n\nВычисления функции\n\n\n\n\n\n\nВычисления градиента функции\n\n\n\n\n\n\nВычисления ограничений\n\n\n\n\n\n\nВычисления якобиана ограничений\n\n\n\n\n\n\nПуть оптимизации\n\n\n\n\n\n\n\nfunc\ncount\n\n\n\n\neval_f\n62\n\n\neval_grad_f\n61\n\n\neval_g_ineq\n63\n\n\neval_jac_g_ineq\n62\n\n\n\n\n\n\n\nK.2.2 CCSAQ\n\nres &lt;- nloptr::nloptr(\n  x0 = x0,\n  eval_f = f,\n  eval_grad_f = f_g,\n  eval_g_ineq = constr_ineq,\n  eval_jac_g_ineq = constr_ineq_jac,\n  opts = list(\n    algorithm = 'NLOPT_LD_CCSAQ',\n    xtol_rel = 1.0e-8\n  )\n)\n\ntrace &lt;- nloptr_trace(\n  x0 = x0,\n  eval_f = objfn,\n  eval_grad_f = objfn_g,\n  eval_g_ineq = constr_ineq_fn,\n  eval_jac_g_ineq = constr_ineq_jac_fn,\n  opts = list(\n    algorithm = 'NLOPT_LD_CCSAQ',\n    xtol_rel = 1.0e-8\n  )\n)\nres\n\n\nCall:\n\nnloptr::nloptr(x0 = x0, eval_f = f, eval_grad_f = f_g, eval_g_ineq = constr_ineq, \n    eval_jac_g_ineq = constr_ineq_jac, opts = list(algorithm = \"NLOPT_LD_CCSAQ\", \n        xtol_rel = 1e-08))\n\n\nMinimization using NLopt version 2.10.0 \n\nNLopt solver status: 4 ( NLOPT_XTOL_REACHED: Optimization stopped because \nxtol_rel or xtol_abs (above) was reached. )\n\nNumber of Iterations....: 15 \nTermination conditions:  xtol_rel: 1e-08 \nNumber of inequality constraints:  2 \nNumber of equality constraints:    0 \nOptimal value of objective function:  2.00000000462507 \nOptimal value of controls: 0.9999985 -1.999997\n\n\n\n\n\n\nВычисления функции\n\n\n\n\n\n\nВычисления градиента функции\n\n\n\n\n\n\nВычисления ограничений\n\n\n\n\n\n\nВычисления якобиана ограничений\n\n\n\n\n\n\nПуть оптимизации\n\n\n\n\n\n\n\nfunc\ncount\n\n\n\n\neval_f\n17\n\n\neval_grad_f\n16\n\n\neval_g_ineq\n18\n\n\neval_jac_g_ineq\n17\n\n\n\n\n\n\n\nK.2.3 SSQLP\n\nres &lt;- nloptr::nloptr(\n  x0 = x0,\n  eval_f = f,\n  eval_grad_f = f_g,\n  eval_g_ineq = constr_ineq,\n  eval_jac_g_ineq = constr_ineq_jac,\n  opts = list(\n    algorithm = 'NLOPT_LD_SLSQP',\n    xtol_rel = 1.0e-8\n  )\n)\n\ntrace &lt;- nloptr_trace(\n  x0 = x0,\n  eval_f = objfn,\n  eval_grad_f = objfn_g,\n  eval_g_ineq = constr_ineq_fn,\n  eval_jac_g_ineq = constr_ineq_jac_fn,\n  opts = list(\n    algorithm = 'NLOPT_LD_SLSQP',\n    xtol_rel = 1.0e-8\n  )\n)\nres\n\n\nCall:\n\nnloptr::nloptr(x0 = x0, eval_f = f, eval_grad_f = f_g, eval_g_ineq = constr_ineq, \n    eval_jac_g_ineq = constr_ineq_jac, opts = list(algorithm = \"NLOPT_LD_SLSQP\", \n        xtol_rel = 1e-08))\n\n\nMinimization using NLopt version 2.10.0 \n\nNLopt solver status: 4 ( NLOPT_XTOL_REACHED: Optimization stopped because \nxtol_rel or xtol_abs (above) was reached. )\n\nNumber of Iterations....: 5 \nTermination conditions:  xtol_rel: 1e-08 \nNumber of inequality constraints:  2 \nNumber of equality constraints:    0 \nOptimal value of objective function:  2 \nOptimal value of controls: 1 -2\n\n\n\n\n\n\nВычисления функции\n\n\n\n\n\n\nВычисления градиента функции\n\n\n\n\n\n\nВычисления ограничений\n\n\n\n\n\n\nВычисления якобиана ограничений\n\n\n\n\n\n\nПуть оптимизации\n\n\n\n\n\n\n\nfunc\ncount\n\n\n\n\neval_f\n7\n\n\neval_grad_f\n6\n\n\neval_g_ineq\n8\n\n\neval_jac_g_ineq\n7",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>K</span>  <span class='chapter-title'>Nloptr. Локальная. Ограничения неравенства</span>"
    ]
  },
  {
    "objectID": "r/tools/solver/nonlinear/nloptr/local/constrained/equality.html",
    "href": "r/tools/solver/nonlinear/nloptr/local/constrained/equality.html",
    "title": "Приложение L — Nloptr. Локальная. Ограничения равенства",
    "section": "",
    "text": "L.1 Градиентные",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>L</span>  <span class='chapter-title'>Nloptr. Локальная. Ограничения равенства</span>"
    ]
  },
  {
    "objectID": "r/tools/solver/nonlinear/nloptr/local/constrained/equality.html#sec-r-tools-solver-nonlinear-nloptr-local-constrained-equality-gradient",
    "href": "r/tools/solver/nonlinear/nloptr/local/constrained/equality.html#sec-r-tools-solver-nonlinear-nloptr-local-constrained-equality-gradient",
    "title": "Приложение L — Nloptr. Локальная. Ограничения равенства",
    "section": "",
    "text": "L.1.1 SSQLP\n\nres &lt;- nloptr::nloptr(\n  x0 = x0,\n  eval_f = f,\n  eval_grad_f = f_g,\n  eval_g_eq = constr_eq,\n  eval_jac_g_eq = constr_eq_jac,\n  opts = list(\n    algorithm = 'NLOPT_LD_SLSQP',\n    xtol_rel = 1.0e-8\n  )\n)\n\ntrace &lt;- nloptr_trace(\n  x0 = x0,\n  eval_f = objfn,\n  eval_grad_f = objfn_g,\n  eval_g_eq = constr_eq_fn,\n  eval_jac_g_eq = constr_eq_jac_fn,\n  opts = list(\n    algorithm = 'NLOPT_LD_SLSQP',\n    xtol_rel = 1.0e-8\n  )\n)\nres\n\n\nCall:\n\nnloptr::nloptr(x0 = x0, eval_f = f, eval_grad_f = f_g, eval_g_eq = constr_eq, \n    eval_jac_g_eq = constr_eq_jac, opts = list(algorithm = \"NLOPT_LD_SLSQP\", \n        xtol_rel = 1e-08))\n\n\nMinimization using NLopt version 2.10.0 \n\nNLopt solver status: 4 ( NLOPT_XTOL_REACHED: Optimization stopped because \nxtol_rel or xtol_abs (above) was reached. )\n\nNumber of Iterations....: 22 \nTermination conditions:  xtol_rel: 1e-08 \nNumber of inequality constraints:  0 \nNumber of equality constraints:    1 \nOptimal value of objective function:  1 \nOptimal value of controls: -1.337528e-16 -2\n\n\n\n\n\n\nВычисления функции\n\n\n\n\n\n\nВычисления градиента функции\n\n\n\n\n\n\nВычисления ограничений\n\n\n\n\n\n\nВычисления якобиана ограничений\n\n\n\n\n\n\nПуть оптимизации\n\n\n\n\n\n\n\nfunc\ncount\n\n\n\n\neval_f\n24\n\n\neval_grad_f\n23\n\n\neval_g_eq\n25\n\n\neval_jac_g_eq\n24",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>L</span>  <span class='chapter-title'>Nloptr. Локальная. Ограничения равенства</span>"
    ]
  },
  {
    "objectID": "r/tools/solver/evolutionary/analysis.html",
    "href": "r/tools/solver/evolutionary/analysis.html",
    "title": "Приложение M — Анализ эволюционного алгоритма",
    "section": "",
    "text": "Подключаем вспомогательные функции\n\nsource('../../../helper/sample.R')\nsource('../../../helper/plotly.R')\nsource('../../../helper/smoof.R')\nsource('../../../helper/smoof_plotly.R')\n\n\n\n\n\n\n\n⤓ sample.R\n⤓ plotly.R\n⤓ smoof.R\n⤓ smoof_plotly.R\n\n\n\nВыберем тестовую функцию из библиотеки smoof и добавим обёртку для подсчёта числа вызовов\n\nobjfn &lt;- smoof::makeAckleyFunction(2) |&gt; \n  smoof::addLoggingWrapper(logg.x = TRUE, size  = 1e4L)\n\nпостроим её график и посчитаем число вызовов\n\nsmoof_pcontour(objfn, 30)\n\n\nsmoof_pcontour(objfn, 30) |&gt; pshow()\n\n\n\n\n\nФункция была вызвана\n\nsmoof::getLoggedValues(objfn, compact = TRUE) |&gt; nrow()\n\n[1] 900\n\n\nТеперь рассмотрим характеристики этой функции. Область поиска определяется через следующие вызовы\n\nsmoof::getLowerBoxConstraints(objfn)\n\n     x1      x2 \n-32.768 -32.768 \n\nsmoof::getUpperBoxConstraints(objfn)\n\n    x1     x2 \n32.768 32.768 \n\n\nХарактеристики функции\n\nsmoof::getAvailableTags()\n\n [1] \"unimodal\"                  \"multimodal\"               \n [3] \"separable\"                 \"non-separable\"            \n [5] \"convex\"                    \"non-convex\"               \n [7] \"continuous\"                \"discontinuous\"            \n [9] \"scalable\"                  \"non-scalable\"             \n[11] \"differentiable\"            \"non-differentiable\"       \n[13] \"low-conditioned\"           \"moderate-conditioned\"     \n[15] \"highly-conditioned\"        \"adequate-global-structure\"\n[17] \"weak-global-structure\"     \"single-objective\"         \n[19] \"multi-objective\"          \n\n\nОпределяется глобальный минимум или максимум\n\nsmoof::shouldBeMinimized(objfn)\n\n[1] TRUE\n\n\n\nsmoof::getGlobalOptimum(objfn)\n\n$param\n  x1 x2\n1  0  0\n\n$value\n[1] 0\n\n$is.minimum\n[1] TRUE\n\n\nМожно получить краткую информацию о функции за раз\n\nobjfn\n\nSingle-objective function\nName: 2-d Ackley Function\nDescription: no description\nTags: single-objective, continuous, multimodal, differentiable, non-separable, scalable\nNoisy: FALSE\nMinimize: TRUE\nConstraints: TRUE\nNumber of parameters: 2\n           Type len Def        Constr Req Tunable Trafo\nx numericvector   2   - -32.8 to 32.8   -    TRUE     -\nGlobal optimum objective value of 0.0000 at\n  x1 x2\n1  0  0\n\n\n\n\n\n\n\n\nВажное уведомление\n\n\n\nДля воспроизводимости результатов необходимо инициализировать генератор случайных чисел постоянным значением. Для инициализации в R используется base::set.seed(). Если библиотека использует для собственный генератор, то инициализируйте его как указано в документации. Например через параметр control = list(seed = 42)",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>M</span>  <span class='chapter-title'>Анализ эволюционного алгоритма</span>"
    ]
  },
  {
    "objectID": "r/tools/solver/evolutionary/gensa.html",
    "href": "r/tools/solver/evolutionary/gensa.html",
    "title": "Приложение N — GenSA Имитации отжига",
    "section": "",
    "text": "f &lt;- smoof::makeSphereFunction(2)\n\n\nlf &lt;- smoof::addLoggingWrapper(f, logg.x = TRUE, size  = 1e5L)\nres &lt;- GenSA::GenSA(\n  par = c(3, 3),\n  fn = lf,\n  lower = smoof::getLowerBoxConstraints(f),\n  upper = smoof::getUpperBoxConstraints(f),\n  control = list(simple.function = TRUE, nb.stop.improvement = 15))\n\n\nrdf &lt;- smoof::getLoggedValues(lf, compact = TRUE) |&gt; rlog_sample(100)\n\nsmoof_pcontour(f, 30) |&gt; \n  padd_eval_points(rdf) |&gt;\n  pshow()",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>N</span>  <span class='chapter-title'>GenSA Имитации отжига</span>"
    ]
  },
  {
    "objectID": "r/tools/solver/evolutionary/pso.html",
    "href": "r/tools/solver/evolutionary/pso.html",
    "title": "Приложение O — PSO метод роя частиц",
    "section": "",
    "text": "f &lt;- smoof::makeSphereFunction(2)\n\n\nlf &lt;- smoof::addLoggingWrapper(f, logg.x = TRUE, size  = 1e5L)\nres &lt;- pso::psoptim(\n  par = c(3, 3),\n  fn = lf,\n  lower = smoof::getLowerBoxConstraints(f),\n  upper = smoof::getUpperBoxConstraints(f),\n  control = list(abstol = 1e-6)\n)\n\nrdf &lt;- smoof::getLoggedValues(lf, compact = TRUE) |&gt; log_sample(100)\n\nsmoof_pcontour(f, 30) |&gt; \n  padd_eval_points(rdf) |&gt;\n  pshow()",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>O</span>  <span class='chapter-title'>PSO метод роя частиц</span>"
    ]
  },
  {
    "objectID": "r/tools/solver/evolutionary/ga.html",
    "href": "r/tools/solver/evolutionary/ga.html",
    "title": "Приложение P — GA обобщенный генетический алгоритм",
    "section": "",
    "text": "f &lt;- smoof::makeSphereFunction(2)\n\n\nlf &lt;- smoof::addLoggingWrapper(f, logg.x = TRUE, size  = 1e5L)\n\nres &lt;- GA::ga(type = 'real-valued', \n         fitness = \\(x)  -lf(x),\n         lower = smoof::getLowerBoxConstraints(f), \n         upper = smoof::getUpperBoxConstraints(f), \n         popSize = 50, \n         maxiter = 1000, \n         run = 20,\n         monitor = FALSE)\n\nrdf &lt;- smoof::getLoggedValues(lf, compact = TRUE) |&gt; log_sample(100)\n\nsmoof_pcontour(f, 30) |&gt; \n  padd_eval_points(rdf) |&gt;\n  pshow()",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>P</span>  <span class='chapter-title'>GA обобщенный генетический алгоритм</span>"
    ]
  },
  {
    "objectID": "r/tools/solver/evolutionary/tsp.html",
    "href": "r/tools/solver/evolutionary/tsp.html",
    "title": "Приложение Q — TSP задача коммивояжера",
    "section": "",
    "text": "data('USCA50', package = 'TSP')\nmethods &lt;- c('nearest_insertion', \n             'farthest_insertion', \n             'cheapest_insertion', \n             'arbitrary_insertion', \n             'nn', \n             'repetitive_nn', \n             'two_opt')\nsapply(methods, \n       \\(m) TSP::solve_TSP(USCA50, method = m), \n       simplify = FALSE)\n\n$nearest_insertion\nobject of class 'TOUR' \nresult of method 'nearest_insertion' for 50 cities\ntour length: 17400 \n\n$farthest_insertion\nobject of class 'TOUR' \nresult of method 'farthest_insertion' for 50 cities\ntour length: 15316 \n\n$cheapest_insertion\nobject of class 'TOUR' \nresult of method 'cheapest_insertion' for 50 cities\ntour length: 16830 \n\n$arbitrary_insertion\nobject of class 'TOUR' \nresult of method 'arbitrary_insertion' for 50 cities\ntour length: 15080 \n\n$nn\nobject of class 'TOUR' \nresult of method 'nn' for 50 cities\ntour length: 15387 \n\n$repetitive_nn\nobject of class 'TOUR' \nresult of method 'repetitive_nn' for 50 cities\ntour length: 15167 \n\n$two_opt\nobject of class 'TOUR' \nresult of method 'two_opt' for 50 cities\ntour length: 17157",
    "crumbs": [
      "Приложения",
      "Язык программирования R",
      "<span class='chapter-number'>Q</span>  <span class='chapter-title'>TSP задача коммивояжера</span>"
    ]
  }
]